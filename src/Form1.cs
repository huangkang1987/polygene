using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.IO;
using System.Threading;
using System.Text;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Diagnostics;
using System.Threading.Tasks;
using LinearAlgebra = MathNet.Numerics.LinearAlgebra;

namespace PolyGene
{
    public partial class Form1 : System.Windows.Forms.Form
    {
        #region CLASS

        public class GENOBODY
        {
            public Dictionary<int, int> alleles = new Dictionary<int, int>();
            public int[] alleles2; //sort in descending order of replicates
            public long pattern = 0;
            public double hwecoef
            {
                get
                {
                    switch (pattern)
                    {
                        default: return 1;
                        case 0x1: return 1.0;
                        case 0x2: return 1.0;
                        case 0x11: return 2.0;
                        case 0x3: return 1.0;
                        case 0x21: return 3.0;
                        case 0x111: return 6.0;
                        case 0x4: return 1.0;
                        case 0x31: return 4.0;
                        case 0x22: return 6.0;
                        case 0x211: return 12.0;
                        case 0x1111: return 24.0;
                        case 0x5: return 1.0;
                        case 0x41: return 5.0;
                        case 0x32: return 10.0;
                        case 0x311: return 20.0;
                        case 0x221: return 30.0;
                        case 0x2111: return 60.0;
                        case 0x11111: return 120.0;
                        case 0x6: return 1.0;
                        case 0x51: return 6.0;
                        case 0x42: return 15.0;
                        case 0x411: return 30.0;
                        case 0x33: return 20.0;
                        case 0x321: return 60.0;
                        case 0x3111: return 120.0;
                        case 0x222: return 90.0;
                        case 0x2211: return 180.0;
                        case 0x21111: return 360.0;
                        case 0x111111: return 720.0;
                        case 0x7: return 1.0;
                        case 0x61: return 7.0;
                        case 0x52: return 21.0;
                        case 0x511: return 42.0;
                        case 0x43: return 35.0;
                        case 0x421: return 105.0;
                        case 0x4111: return 210.0;
                        case 0x331: return 140.0;
                        case 0x322: return 210.0;
                        case 0x3211: return 420.0;
                        case 0x31111: return 840.0;
                        case 0x2221: return 630.0;
                        case 0x22111: return 1260.0;
                        case 0x211111: return 2520.0;
                        case 0x1111111: return 5040.0;
                        case 0x8: return 1.0;
                        case 0x71: return 8.0;
                        case 0x62: return 28.0;
                        case 0x611: return 56.0;
                        case 0x53: return 56.0;
                        case 0x521: return 168.0;
                        case 0x5111: return 336.0;
                        case 0x44: return 70.0;
                        case 0x431: return 280.0;
                        case 0x422: return 420.0;
                        case 0x4211: return 840.0;
                        case 0x41111: return 1680.0;
                        case 0x332: return 560.0;
                        case 0x3311: return 1120.0;
                        case 0x3221: return 1680.0;
                        case 0x32111: return 3360.0;
                        case 0x311111: return 6720.0;
                        case 0x2222: return 2520.0;
                        case 0x22211: return 5040.0;
                        case 0x221111: return 10080.0;
                        case 0x2111111: return 20160.0;
                        case 0x11111111: return 40320.0;
                        case 0x9: return 1.0;
                        case 0x81: return 9.0;
                        case 0x72: return 36.0;
                        case 0x711: return 72.0;
                        case 0x63: return 84.0;
                        case 0x621: return 252.0;
                        case 0x6111: return 504.0;
                        case 0x54: return 126.0;
                        case 0x531: return 504.0;
                        case 0x522: return 756.0;
                        case 0x5211: return 1512.0;
                        case 0x51111: return 3024.0;
                        case 0x441: return 630.0;
                        case 0x432: return 1260.0;
                        case 0x4311: return 2520.0;
                        case 0x4221: return 3780.0;
                        case 0x42111: return 7560.0;
                        case 0x411111: return 15120.0;
                        case 0x333: return 1680.0;
                        case 0x3321: return 5040.0;
                        case 0x33111: return 10080.0;
                        case 0x3222: return 7560.0;
                        case 0x32211: return 15120.0;
                        case 0x321111: return 30240.0;
                        case 0x3111111: return 60480.0;
                        case 0x22221: return 22680.0;
                        case 0x222111: return 45360.0;
                        case 0x2211111: return 90720.0;
                        case 0x21111111: return 181440.0;
                        case 0x111111111: return 362880.0;
                        case 0xA: return 1.0;
                        case 0x91: return 10.0;
                        case 0x82: return 45.0;
                        case 0x811: return 90.0;
                        case 0x73: return 120.0;
                        case 0x721: return 360.0;
                        case 0x7111: return 720.0;
                        case 0x64: return 210.0;
                        case 0x631: return 840.0;
                        case 0x622: return 1260.0;
                        case 0x6211: return 2520.0;
                        case 0x61111: return 5040.0;
                        case 0x55: return 252.0;
                        case 0x541: return 1260.0;
                        case 0x532: return 2520.0;
                        case 0x5311: return 5040.0;
                        case 0x5221: return 7560.0;
                        case 0x52111: return 15120.0;
                        case 0x511111: return 30240.0;
                        case 0x442: return 3150.0;
                        case 0x4411: return 6300.0;
                        case 0x433: return 4200.0;
                        case 0x4321: return 12600.0;
                        case 0x43111: return 25200.0;
                        case 0x4222: return 18900.0;
                        case 0x42211: return 37800.0;
                        case 0x421111: return 75600.0;
                        case 0x4111111: return 151200.0;
                        case 0x3331: return 16800.0;
                        case 0x3322: return 25200.0;
                        case 0x33211: return 50400.0;
                        case 0x331111: return 100800.0;
                        case 0x32221: return 75600.0;
                        case 0x322111: return 151200.0;
                        case 0x3211111: return 302400.0;
                        case 0x31111111: return 604800.0;
                        case 0x22222: return 113400.0;
                        case 0x222211: return 226800.0;
                        case 0x2221111: return 453600.0;
                        case 0x22111111: return 907200.0;
                        case 0x211111111: return 1814400.0;
                        case 0x1111111111: return 3628800.0;
                    }
                }
            }
            public uint hash = 0xFFFFFFFF;

            public Dictionary<uint, GENOBODY> gametes = null;

            public GENOBODY(IEnumerable<int> als)
            {
                //als do not need to be sorted
                int ploidy = 0;
                foreach (int a in als)
                {
                    if (alleles.ContainsKey(a))
                        alleles[a]++;
                    else
                        alleles[a] = 1;
                    ploidy++;
                }

                pattern = GetPattern();
                alleles2 = Count2Type(ploidy);
                GetHash();
            }


            public override bool Equals(object obj)
            {
                var obj2 = (GENOBODY)obj;
                return hash == obj2.hash;
            }

            public override int GetHashCode()
            {
                return (int)hash;
            }

            public Dictionary<int, int> Type2Count()
            {
                Dictionary<int, int> re = new Dictionary<int, int>();
                foreach (int k in alleles2)
                {
                    if (!re.ContainsKey(k))
                        re[k] = 0;
                    re[k]++;
                }
                return re;
            }

            public int[] Count2Type(int ploidy)
            {
                int[] re = new int[ploidy];
                int c = 0;
                foreach (var a in from o in alleles orderby o.Value descending, o.Key ascending select o)
                    for (int i = 0; i < a.Value; ++i)
                        re[c++] = a.Key;
                return re;
            }

            public long GetPattern()
            {
                long ap = 0;
                foreach (var b in alleles.OrderByDescending(a => a.Value))
                    ap = (ap << 4) | (long)b.Value;
                return ap;
            }

            public int GetRefMode()
            {
                //used in Huang mom relatedness estimator
                int score = GetS2Index();
                switch (alleles2.Length)
                {
                    case 1:
                        switch (score)
                        {
                            case 0: return 1;
                            default: return 0;
                        }
                    case 2:
                        switch (score)
                        {
                            case 0: return 1;
                            case 1: return 2;
                            default: return 0;
                        }
                    case 3:
                        switch (score)
                        {
                            case 0: return 1;
                            case 1: return 2;
                            case 3: return 3;
                            default: return 0;
                        }
                    case 4:
                        switch (score)
                        {
                            case 0: return 1;
                            case 1: return 2;
                            case 2: return 3;
                            case 3: return 4;
                            case 6: return 5;
                            default: return 0;
                        }
                    case 5:
                        switch (score)
                        {
                            case 0: return 1;
                            case 1: return 2;
                            case 2: return 3;
                            case 3: return 4;
                            case 4: return 5;
                            case 6: return 6;
                            case 10: return 7;
                            default: return 0;
                        }
                    case 6:
                        switch (score)
                        {
                            case 0: return 1;
                            case 1: return 2;
                            case 2: return 3;
                            case 3: return alleles.Count == 3 ? 4 : 5;
                            case 4: return 6;
                            case 6: return alleles.Count == 2 ? 7 : 8;
                            case 7: return 9;
                            case 10: return 10;
                            case 15: return 11;
                            default: return 0;
                        }
                    case 7:
                        switch (score)
                        {
                            case 0: return 1;
                            case 1: return 2;
                            case 2: return 3;
                            case 3: return alleles.Count == 4 ? 4 : 5;
                            case 4: return 6;
                            case 5: return 7;
                            case 6: return alleles.Count == 3 ? 8 : 9;
                            case 7: return 10;
                            case 9: return 11;
                            case 10: return 12;
                            case 11: return 13;
                            case 15: return 14;
                            case 21: return 15;
                            default: return 0;
                        }
                    case 8:
                        switch (score)
                        {
                            case 0: return 1;
                            case 1: return 2;
                            case 2: return 3;
                            case 3: return alleles.Count == 5 ? 4 : 6;
                            case 4: return alleles.Count == 4 ? 5 : 7;
                            case 5: return 8;
                            case 6: return alleles.Count == 4 ? 9 : 11;
                            case 7: return alleles.Count == 3 ? 10 : 12;
                            case 8: return 13;
                            case 9: return 14;
                            case 10: return 16;
                            case 11: return 17;
                            case 12: return 15;
                            case 13: return 18;
                            case 15: return 19;
                            case 16: return 20;
                            case 21: return 21;
                            case 28: return 22;
                            default: return 0;
                        }
                    default: return 0;
                }
            }

            public int GetS2Index()
            {
                //used in Huang mom relatedness estimator
                switch (pattern)
                {
                    case 0x1: return 0;
                    case 0x2: return 1;
                    case 0x11: return 0;
                    case 0x3: return 3;
                    case 0x21: return 1;
                    case 0x111: return 0;
                    case 0x4: return 6;
                    case 0x31: return 3;
                    case 0x22: return 2;
                    case 0x211: return 1;
                    case 0x1111: return 0;
                    case 0x5: return 10;
                    case 0x41: return 6;
                    case 0x32: return 4;
                    case 0x311: return 3;
                    case 0x221: return 2;
                    case 0x2111: return 1;
                    case 0x11111: return 0;
                    case 0x6: return 15;
                    case 0x51: return 10;
                    case 0x42: return 7;
                    case 0x411: return 6;
                    case 0x33: return 6;
                    case 0x321: return 4;
                    case 0x3111: return 3;
                    case 0x222: return 3;
                    case 0x2211: return 2;
                    case 0x21111: return 1;
                    case 0x111111: return 0;
                    case 0x7: return 21;
                    case 0x61: return 15;
                    case 0x52: return 11;
                    case 0x511: return 10;
                    case 0x43: return 9;
                    case 0x421: return 7;
                    case 0x4111: return 6;
                    case 0x331: return 6;
                    case 0x322: return 5;
                    case 0x3211: return 4;
                    case 0x31111: return 3;
                    case 0x2221: return 3;
                    case 0x22111: return 2;
                    case 0x211111: return 1;
                    case 0x1111111: return 0;
                    case 0x8: return 28;
                    case 0x71: return 21;
                    case 0x62: return 16;
                    case 0x611: return 15;
                    case 0x53: return 13;
                    case 0x521: return 11;
                    case 0x5111: return 10;
                    case 0x44: return 12;
                    case 0x431: return 9;
                    case 0x422: return 8;
                    case 0x4211: return 7;
                    case 0x41111: return 6;
                    case 0x332: return 7;
                    case 0x3311: return 6;
                    case 0x3221: return 5;
                    case 0x32111: return 4;
                    case 0x311111: return 3;
                    case 0x2222: return 4;
                    case 0x22211: return 3;
                    case 0x221111: return 2;
                    case 0x2111111: return 1;
                    case 0x11111111: return 0;
                    case 0x9: return 36;
                    case 0x81: return 28;
                    case 0x72: return 22;
                    case 0x711: return 21;
                    case 0x63: return 18;
                    case 0x621: return 16;
                    case 0x6111: return 15;
                    case 0x54: return 16;
                    case 0x531: return 13;
                    case 0x522: return 12;
                    case 0x5211: return 11;
                    case 0x51111: return 10;
                    case 0x441: return 12;
                    case 0x432: return 10;
                    case 0x4311: return 9;
                    case 0x4221: return 8;
                    case 0x42111: return 7;
                    case 0x411111: return 6;
                    case 0x333: return 9;
                    case 0x3321: return 7;
                    case 0x33111: return 6;
                    case 0x3222: return 6;
                    case 0x32211: return 5;
                    case 0x321111: return 4;
                    case 0x3111111: return 3;
                    case 0x22221: return 4;
                    case 0x222111: return 3;
                    case 0x2211111: return 2;
                    case 0x21111111: return 1;
                    case 0x111111111: return 0;
                    case 0xA: return 45;
                    case 0x91: return 36;
                    case 0x82: return 29;
                    case 0x811: return 28;
                    case 0x73: return 24;
                    case 0x721: return 22;
                    case 0x7111: return 21;
                    case 0x64: return 21;
                    case 0x631: return 18;
                    case 0x622: return 17;
                    case 0x6211: return 16;
                    case 0x61111: return 15;
                    case 0x55: return 20;
                    case 0x541: return 16;
                    case 0x532: return 14;
                    case 0x5311: return 13;
                    case 0x5221: return 12;
                    case 0x52111: return 11;
                    case 0x511111: return 10;
                    case 0x442: return 13;
                    case 0x4411: return 12;
                    case 0x433: return 12;
                    case 0x4321: return 10;
                    case 0x43111: return 9;
                    case 0x4222: return 9;
                    case 0x42211: return 8;
                    case 0x421111: return 7;
                    case 0x4111111: return 6;
                    case 0x3331: return 9;
                    case 0x3322: return 8;
                    case 0x33211: return 7;
                    case 0x331111: return 6;
                    case 0x32221: return 6;
                    case 0x322111: return 5;
                    case 0x3211111: return 4;
                    case 0x31111111: return 3;
                    case 0x22222: return 5;
                    case 0x222211: return 4;
                    case 0x2221111: return 3;
                    case 0x22111111: return 2;
                    case 0x211111111: return 1;
                    case 0x1111111111: return 0;
                }
                return 0;
            }

            public double GetHIndex()
            {
                switch (pattern)
                {
                    case 0x1: return 0.000000000000000;
                    case 0x2: return 0.000000000000000;
                    case 0x11: return 1.000000000000000;
                    case 0x3: return 0.000000000000000;
                    case 0x21: return 0.666666666666667;
                    case 0x111: return 1.000000000000000;
                    case 0x4: return 0.000000000000000;
                    case 0x31: return 0.500000000000000;
                    case 0x22: return 0.666666666666667;
                    case 0x211: return 0.833333333333333;
                    case 0x1111: return 1.000000000000000;
                    case 0x5: return 0.000000000000000;
                    case 0x41: return 0.400000000000000;
                    case 0x32: return 0.600000000000000;
                    case 0x311: return 0.700000000000000;
                    case 0x221: return 0.800000000000000;
                    case 0x2111: return 0.900000000000000;
                    case 0x11111: return 1.000000000000000;
                    case 0x6: return 0.000000000000000;
                    case 0x51: return 0.333333333333333;
                    case 0x42: return 0.533333333333333;
                    case 0x411: return 0.600000000000000;
                    case 0x33: return 0.600000000000000;
                    case 0x321: return 0.733333333333333;
                    case 0x3111: return 0.800000000000000;
                    case 0x222: return 0.800000000000000;
                    case 0x2211: return 0.866666666666667;
                    case 0x21111: return 0.933333333333333;
                    case 0x111111: return 1.000000000000000;
                    case 0x7: return 0.000000000000000;
                    case 0x61: return 0.285714285714286;
                    case 0x52: return 0.476190476190476;
                    case 0x511: return 0.523809523809524;
                    case 0x43: return 0.571428571428572;
                    case 0x421: return 0.666666666666667;
                    case 0x4111: return 0.714285714285714;
                    case 0x331: return 0.714285714285714;
                    case 0x322: return 0.761904761904762;
                    case 0x3211: return 0.809523809523809;
                    case 0x31111: return 0.857142857142857;
                    case 0x2221: return 0.857142857142857;
                    case 0x22111: return 0.904761904761905;
                    case 0x211111: return 0.952380952380952;
                    case 0x1111111: return 1.000000000000000;
                    case 0x8: return 0.000000000000000;
                    case 0x71: return 0.250000000000000;
                    case 0x62: return 0.428571428571429;
                    case 0x611: return 0.464285714285714;
                    case 0x53: return 0.535714285714286;
                    case 0x521: return 0.607142857142857;
                    case 0x5111: return 0.642857142857143;
                    case 0x44: return 0.571428571428571;
                    case 0x431: return 0.678571428571429;
                    case 0x422: return 0.714285714285714;
                    case 0x4211: return 0.750000000000000;
                    case 0x41111: return 0.785714285714286;
                    case 0x332: return 0.750000000000000;
                    case 0x3311: return 0.785714285714286;
                    case 0x3221: return 0.821428571428571;
                    case 0x32111: return 0.857142857142857;
                    case 0x311111: return 0.892857142857143;
                    case 0x2222: return 0.857142857142857;
                    case 0x22211: return 0.892857142857143;
                    case 0x221111: return 0.928571428571429;
                    case 0x2111111: return 0.964285714285714;
                    case 0x11111111: return 1.000000000000000;
                    case 0x9: return 0.000000000000000;
                    case 0x81: return 0.222222222222222;
                    case 0x72: return 0.388888888888889;
                    case 0x711: return 0.416666666666667;
                    case 0x63: return 0.500000000000000;
                    case 0x621: return 0.555555555555556;
                    case 0x6111: return 0.583333333333333;
                    case 0x54: return 0.555555555555556;
                    case 0x531: return 0.638888888888889;
                    case 0x522: return 0.666666666666667;
                    case 0x5211: return 0.694444444444444;
                    case 0x51111: return 0.722222222222222;
                    case 0x441: return 0.666666666666667;
                    case 0x432: return 0.722222222222222;
                    case 0x4311: return 0.750000000000000;
                    case 0x4221: return 0.777777777777778;
                    case 0x42111: return 0.805555555555556;
                    case 0x411111: return 0.833333333333333;
                    case 0x333: return 0.750000000000000;
                    case 0x3321: return 0.805555555555556;
                    case 0x33111: return 0.833333333333333;
                    case 0x3222: return 0.833333333333333;
                    case 0x32211: return 0.861111111111111;
                    case 0x321111: return 0.888888888888889;
                    case 0x3111111: return 0.916666666666667;
                    case 0x22221: return 0.888888888888889;
                    case 0x222111: return 0.916666666666667;
                    case 0x2211111: return 0.944444444444444;
                    case 0x21111111: return 0.972222222222222;
                    case 0x111111111: return 1.000000000000000;
                    case 0xA: return 0.000000000000000;
                    case 0x91: return 0.200000000000000;
                    case 0x82: return 0.355555555555555;
                    case 0x811: return 0.377777777777778;
                    case 0x73: return 0.466666666666667;
                    case 0x721: return 0.511111111111111;
                    case 0x7111: return 0.533333333333333;
                    case 0x64: return 0.533333333333333;
                    case 0x631: return 0.600000000000000;
                    case 0x622: return 0.622222222222222;
                    case 0x6211: return 0.644444444444444;
                    case 0x61111: return 0.666666666666667;
                    case 0x55: return 0.555555555555556;
                    case 0x541: return 0.644444444444444;
                    case 0x532: return 0.688888888888889;
                    case 0x5311: return 0.711111111111111;
                    case 0x5221: return 0.733333333333333;
                    case 0x52111: return 0.755555555555555;
                    case 0x511111: return 0.777777777777778;
                    case 0x442: return 0.711111111111111;
                    case 0x4411: return 0.733333333333333;
                    case 0x433: return 0.733333333333333;
                    case 0x4321: return 0.777777777777778;
                    case 0x43111: return 0.800000000000000;
                    case 0x4222: return 0.800000000000000;
                    case 0x42211: return 0.822222222222222;
                    case 0x421111: return 0.844444444444444;
                    case 0x4111111: return 0.866666666666667;
                    case 0x3331: return 0.800000000000000;
                    case 0x3322: return 0.822222222222222;
                    case 0x33211: return 0.844444444444444;
                    case 0x331111: return 0.866666666666667;
                    case 0x32221: return 0.866666666666667;
                    case 0x322111: return 0.888888888888889;
                    case 0x3211111: return 0.911111111111111;
                    case 0x31111111: return 0.933333333333333;
                    case 0x22222: return 0.888888888888889;
                    case 0x222211: return 0.911111111111111;
                    case 0x2221111: return 0.933333333333333;
                    case 0x22111111: return 0.955555555555555;
                    case 0x211111111: return 0.977777777777778;
                    case 0x1111111111: return 1.000000000000000;
                }
                return 0;
            }

            public double GetPxlk2()
            {
                switch (pattern)
                {
                    case 0x1: return 1.000000000000000;
                    case 0x2: return 1.000000000000000;
                    case 0x11: return 0.500000000000000;
                    case 0x3: return 1.000000000000000;
                    case 0x21: return 0.555555555555556;
                    case 0x111: return 0.333333333333333;
                    case 0x4: return 1.000000000000000;
                    case 0x31: return 0.625000000000000;
                    case 0x22: return 0.500000000000000;
                    case 0x211: return 0.375000000000000;
                    case 0x1111: return 0.250000000000000;
                    case 0x5: return 1.000000000000000;
                    case 0x41: return 0.680000000000000;
                    case 0x32: return 0.520000000000000;
                    case 0x311: return 0.440000000000000;
                    case 0x221: return 0.360000000000000;
                    case 0x2111: return 0.280000000000000;
                    case 0x11111: return 0.200000000000000;
                    case 0x6: return 1.000000000000000;
                    case 0x51: return 0.722222222222222;
                    case 0x42: return 0.555555555555556;
                    case 0x411: return 0.500000000000000;
                    case 0x33: return 0.500000000000000;
                    case 0x321: return 0.388888888888889;
                    case 0x3111: return 0.333333333333333;
                    case 0x222: return 0.333333333333333;
                    case 0x2211: return 0.277777777777778;
                    case 0x21111: return 0.222222222222222;
                    case 0x111111: return 0.166666666666667;
                    case 0x7: return 1.000000000000000;
                    case 0x61: return 0.755102040816326;
                    case 0x52: return 0.591836734693878;
                    case 0x511: return 0.551020408163265;
                    case 0x43: return 0.510204081632653;
                    case 0x421: return 0.428571428571429;
                    case 0x4111: return 0.387755102040816;
                    case 0x331: return 0.387755102040816;
                    case 0x322: return 0.346938775510204;
                    case 0x3211: return 0.306122448979592;
                    case 0x31111: return 0.265306122448980;
                    case 0x2221: return 0.265306122448980;
                    case 0x22111: return 0.224489795918367;
                    case 0x211111: return 0.183673469387755;
                    case 0x1111111: return 0.142857142857143;
                    case 0x8: return 1.000000000000000;
                    case 0x71: return 0.781250000000000;
                    case 0x62: return 0.625000000000000;
                    case 0x611: return 0.593750000000000;
                    case 0x53: return 0.531250000000000;
                    case 0x521: return 0.468750000000000;
                    case 0x5111: return 0.437500000000000;
                    case 0x44: return 0.500000000000000;
                    case 0x431: return 0.406250000000000;
                    case 0x422: return 0.375000000000000;
                    case 0x4211: return 0.343750000000000;
                    case 0x41111: return 0.312500000000000;
                    case 0x332: return 0.343750000000000;
                    case 0x3311: return 0.312500000000000;
                    case 0x3221: return 0.281250000000000;
                    case 0x32111: return 0.250000000000000;
                    case 0x311111: return 0.218750000000000;
                    case 0x2222: return 0.250000000000000;
                    case 0x22211: return 0.218750000000000;
                    case 0x221111: return 0.187500000000000;
                    case 0x2111111: return 0.156250000000000;
                    case 0x11111111: return 0.125000000000000;
                    case 0x9: return 1.000000000000000;
                    case 0x81: return 0.802469135802469;
                    case 0x72: return 0.654320987654321;
                    case 0x711: return 0.629629629629630;
                    case 0x63: return 0.555555555555556;
                    case 0x621: return 0.506172839506173;
                    case 0x6111: return 0.481481481481481;
                    case 0x54: return 0.506172839506173;
                    case 0x531: return 0.432098765432099;
                    case 0x522: return 0.407407407407407;
                    case 0x5211: return 0.382716049382716;
                    case 0x51111: return 0.358024691358025;
                    case 0x441: return 0.407407407407407;
                    case 0x432: return 0.358024691358025;
                    case 0x4311: return 0.333333333333333;
                    case 0x4221: return 0.308641975308642;
                    case 0x42111: return 0.283950617283951;
                    case 0x411111: return 0.259259259259259;
                    case 0x333: return 0.333333333333333;
                    case 0x3321: return 0.283950617283951;
                    case 0x33111: return 0.259259259259259;
                    case 0x3222: return 0.259259259259259;
                    case 0x32211: return 0.234567901234568;
                    case 0x321111: return 0.209876543209877;
                    case 0x3111111: return 0.185185185185185;
                    case 0x22221: return 0.209876543209877;
                    case 0x222111: return 0.185185185185185;
                    case 0x2211111: return 0.160493827160494;
                    case 0x21111111: return 0.135802469135802;
                    case 0x111111111: return 0.111111111111111;
                    case 0xA: return 0.100000000000000;
                    case 0x91: return 0.820000000000000;
                    case 0x82: return 0.680000000000000;
                    case 0x811: return 0.660000000000000;
                    case 0x73: return 0.580000000000000;
                    case 0x721: return 0.540000000000000;
                    case 0x7111: return 0.520000000000000;
                    case 0x64: return 0.520000000000000;
                    case 0x631: return 0.460000000000000;
                    case 0x622: return 0.440000000000000;
                    case 0x6211: return 0.420000000000000;
                    case 0x61111: return 0.400000000000000;
                    case 0x55: return 0.500000000000000;
                    case 0x541: return 0.420000000000000;
                    case 0x532: return 0.380000000000000;
                    case 0x5311: return 0.360000000000000;
                    case 0x5221: return 0.340000000000000;
                    case 0x52111: return 0.320000000000000;
                    case 0x511111: return 0.300000000000000;
                    case 0x442: return 0.360000000000000;
                    case 0x4411: return 0.340000000000000;
                    case 0x433: return 0.340000000000000;
                    case 0x4321: return 0.300000000000000;
                    case 0x43111: return 0.280000000000000;
                    case 0x4222: return 0.280000000000000;
                    case 0x42211: return 0.260000000000000;
                    case 0x421111: return 0.240000000000000;
                    case 0x4111111: return 0.220000000000000;
                    case 0x3331: return 0.280000000000000;
                    case 0x3322: return 0.260000000000000;
                    case 0x33211: return 0.240000000000000;
                    case 0x331111: return 0.220000000000000;
                    case 0x32221: return 0.220000000000000;
                    case 0x322111: return 0.200000000000000;
                    case 0x3211111: return 0.180000000000000;
                    case 0x31111111: return 0.160000000000000;
                    case 0x22222: return 0.200000000000000;
                    case 0x222211: return 0.180000000000000;
                    case 0x2221111: return 0.160000000000000;
                    case 0x22111111: return 0.140000000000000;
                    case 0x211111111: return 0.120000000000000;
                    case 0x1111111111: return 0.100000000000000;
                }
                return 0;
            }

            public void GetHoDiallelic(double w, IDictionary<int, double> D)
            {
                int v = alleles2.Length;
                foreach (var a in alleles)
                    D[a.Key] += a.Value * (v - a.Value) * w;
            }

            public uint GetHash()
            {
                if (hash != 0xFFFFFFFF) return hash;
                if (alleles2.Length == 0) hash = 0;
                else hash = HashGenotype(alleles2);
                return hash;
            }

            public GENOBODY GetSecondSemiGenotype(GENOBODY subset)
            {
                int[] als = new int[alleles2.Length - subset.alleles2.Length];
                int c = 0;
                foreach (int a in alleles.Keys)
                {
                    int rep = alleles[a] - GetDictionaryValue(subset.alleles, a);
                    for (int i = 0; i < rep; ++i)
                        als[c++] = a;
                }
                return new GENOBODY(als);
            }

            public bool IsSemiGenotype(GENOBODY subset)
            {
                foreach (int a in subset.alleles.Keys)
                    if (!alleles.ContainsKey(a) || alleles[a] < subset.alleles[a])
                        return false;
                return true;
            }

            public double TransitionalGameteFrequency(double[] alpha, GENOBODY g)
            {
                //from G to g
                int v = alleles2.Length;
                if (g.alleles2.Length * 2 != v) return 0;

                int dr_max = v / 4;
                int[] als = alleles.Keys.ToArray();
                int h = alleles.Count;
                double re = 0;

                for (int i = 0; i <= dr_max; ++i)
                {
                    double comi = alpha[i] / (BINOMIAL[v, i] * BINOMIAL[v - i, v / 2 - 2 * i]);
                    switch (i)
                    {
                        case 2:
                            for (int j1 = 0; j1 < h; ++j1)
                            {
                                for (int j2 = j1; j2 < h; ++j2)
                                {
                                    double pr1 = 1;
                                    for (int k = 0; k < h; ++k)
                                    {
                                        int a = als[k], nk = alleles[a], mk = GetDictionaryValue(g.alleles, a);
                                        int jk = (j1 == k ? 1 : 0) + (j2 == k ? 1 : 0);
                                        if (Math.Max(0, mk - nk) <= jk && jk <= Math.Min(nk, mk / 2))
                                            pr1 *= BINOMIAL[nk, jk] * BINOMIAL[nk - jk, mk - 2 * jk];
                                        else
                                        {
                                            pr1 = 0;
                                            break;
                                        }
                                    }
                                    re += pr1 * comi;
                                }
                            }
                            break;
                        case 1:
                            for (int j1 = 0; j1 < h; ++j1)
                            {
                                double pr2 = 1;
                                for (int k = 0; k < h; ++k)
                                {
                                    int a = als[k], nk = alleles[a], mk = GetDictionaryValue(g.alleles, a);
                                    int jk = (j1 == k ? 1 : 0);
                                    if (Math.Max(0, mk - nk) <= jk && jk <= Math.Min(nk, mk / 2))
                                        pr2 *= BINOMIAL[nk, jk] * BINOMIAL[nk - jk, mk - 2 * jk];
                                    else
                                    {
                                        pr2 = 0;
                                        break;
                                    }
                                }
                                re += pr2 * comi;
                            }
                            break;
                        case 0:
                            double pr3 = 1;
                            for (int k = 0; k < h; ++k)
                            {
                                int a = als[k], nk = alleles[a], mk = GetDictionaryValue(g.alleles, a);
                                int jk = 0;
                                if (Math.Max(0, mk - nk) <= jk && jk <= Math.Min(nk, mk / 2))
                                    pr3 *= BINOMIAL[nk, jk] * BINOMIAL[nk - jk, mk - 2 * jk];
                                else
                                {
                                    pr3 = 0;
                                    break;
                                }
                            }
                            re += pr3 * comi;
                            break;
                    }
                }

                return re;
            }

            public double GFZ(IDictionary<int, double> fre, double f)
            {
                int ploidy = alleles2.Length;
                switch (ploidy)
                {
                    case 0:
                        return 1;
                    case 1:
                        return fre[alleles2[0]];
                    case 2:
                        double pa = fre[alleles2[0]], pb = fre[alleles2[1]];
                        return alleles2[0] == alleles2[1] ?
                            f * pa + (1.0 - f) * pa * pa :
                            2.0 * (1.0 - f) * pa * pb;
                    default:
                        double re = hwecoef, re2 = 1, F = 1.0 / f - 1;
                        if (F < 1e-20) F = 1e-20;
                        if (F > 1e20) F = 1e20;
                        foreach (var b in alleles)
                        {
                            double Fp = fre[b.Key] * F;
                            for (int j = 0, len = b.Value; j < len; ++j)
                                re *= Fp + j;
                        }
                        for (int j = 0; j < ploidy; ++j)
                            re2 *= F + j;
                        return re / re2;
                }
            }

            public double GFZ(IDictionary<int, double> fre, double[] alpha)
            {
                int ploidy = alleles2.Length;
                if (ploidy <= 2 || ploidy % 2 == 1)
                {
                    double re = hwecoef;
                    foreach (int a in alleles2)
                        re *= fre[a];
                    return re;
                }

                switch (ploidy)
                {
                    case 4:
                        switch (pattern)
                        {
                            case 0x4: return GFZ4_iiii(alpha[1], fre[alleles2[0]]);
                            case 0x31: return GFZ4_iiij(alpha[1], fre[alleles2[0]], fre[alleles2[3]]);
                            case 0x22: return GFZ4_iijj(alpha[1], fre[alleles2[0]], fre[alleles2[2]]);
                            case 0x211: return GFZ4_iijk(alpha[1], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[3]]);
                            case 0x1111: return GFZ4_ijkl(alpha[1], fre[alleles2[0]], fre[alleles2[1]], fre[alleles2[2]], fre[alleles2[3]]);
                        }
                        return -1;
                    case 6:
                        switch (pattern)
                        {
                            case 0x6: return GFZ6_iiiiii(alpha[1], fre[alleles2[0]]);
                            case 0x51: return GFZ6_iiiiij(alpha[1], fre[alleles2[0]], fre[alleles2[5]]);
                            case 0x42: return GFZ6_iiiijj(alpha[1], fre[alleles2[0]], fre[alleles2[4]]);
                            case 0x411: return GFZ6_iiiijk(alpha[1], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[5]]);
                            case 0x33: return GFZ6_iiijjj(alpha[1], fre[alleles2[0]], fre[alleles2[3]]);
                            case 0x321: return GFZ6_iiijjk(alpha[1], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[5]]);
                            case 0x3111: return GFZ6_iiijkl(alpha[1], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[4]], fre[alleles2[5]]);
                            case 0x222: return GFZ6_iijjkk(alpha[1], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[4]]);
                            case 0x2211: return GFZ6_iijjkl(alpha[1], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[4]], fre[alleles2[5]]);
                            case 0x21111: return GFZ6_iijklm(alpha[1], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[3]], fre[alleles2[4]], fre[alleles2[5]]);
                            case 0x111111: return GFZ6_ijklmn(alpha[1], fre[alleles2[0]], fre[alleles2[1]], fre[alleles2[2]], fre[alleles2[3]], fre[alleles2[4]], fre[alleles2[5]]);
                            default: return -1;
                        }
                    case 8:
                        switch (pattern)
                        {
                            case 0x8: return GFZ8_iiiiiiii(alpha[1], alpha[2], fre[alleles2[0]]);
                            case 0x71: return GFZ8_iiiiiiij(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[7]]);
                            case 0x62: return GFZ8_iiiiiijj(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[6]]);
                            case 0x611: return GFZ8_iiiiiijk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[6]], fre[alleles2[7]]);
                            case 0x53: return GFZ8_iiiiijjj(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[5]]);
                            case 0x521: return GFZ8_iiiiijjk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[5]], fre[alleles2[7]]);
                            case 0x5111: return GFZ8_iiiiijkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]]);
                            case 0x44: return GFZ8_iiiijjjj(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]]);
                            case 0x431: return GFZ8_iiiijjjk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[7]]);
                            case 0x422: return GFZ8_iiiijjkk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[6]]);
                            case 0x4211: return GFZ8_iiiijjkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[6]], fre[alleles2[7]]);
                            case 0x41111: return GFZ8_iiiijklm(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]]);
                            case 0x332: return GFZ8_iiijjjkk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[6]]);
                            case 0x3311: return GFZ8_iiijjjkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[6]], fre[alleles2[7]]);
                            case 0x3221: return GFZ8_iiijjkkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[5]], fre[alleles2[7]]);
                            case 0x32111: return GFZ8_iiijjklm(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]]);
                            case 0x311111: return GFZ8_iiijklmn(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[4]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]]);
                            case 0x2222: return GFZ8_iijjkkll(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[4]], fre[alleles2[6]]);
                            case 0x22211: return GFZ8_iijjkklm(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[4]], fre[alleles2[6]], fre[alleles2[7]]);
                            case 0x221111: return GFZ8_iijjklmn(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[4]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]]);
                            case 0x2111111: return GFZ8_iijklmno(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[3]], fre[alleles2[4]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]]);
                            case 0x11111111: return GFZ8_ijklmnop(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[1]], fre[alleles2[2]], fre[alleles2[3]], fre[alleles2[4]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]]);
                            default: return -1;
                        }
                    case 10:
                        switch (pattern)
                        {
                            case 0xA: return GFZ10_iiiiiiiiii(alpha[1], alpha[2], fre[alleles2[0]]);
                            case 0x91: return GFZ10_iiiiiiiiij(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[9]]);
                            case 0x82: return GFZ10_iiiiiiiijj(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[8]]);
                            case 0x811: return GFZ10_iiiiiiiijk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x73: return GFZ10_iiiiiiijjj(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[7]]);
                            case 0x721: return GFZ10_iiiiiiijjk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[7]], fre[alleles2[9]]);
                            case 0x7111: return GFZ10_iiiiiiijkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x64: return GFZ10_iiiiiijjjj(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[6]]);
                            case 0x631: return GFZ10_iiiiiijjjk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[6]], fre[alleles2[9]]);
                            case 0x622: return GFZ10_iiiiiijjkk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[6]], fre[alleles2[8]]);
                            case 0x6211: return GFZ10_iiiiiijjkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[6]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x61111: return GFZ10_iiiiiijklm(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[6]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x55: return GFZ10_iiiiijjjjj(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[5]]);
                            case 0x541: return GFZ10_iiiiijjjjk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[5]], fre[alleles2[9]]);
                            case 0x532: return GFZ10_iiiiijjjkk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[5]], fre[alleles2[8]]);
                            case 0x5311: return GFZ10_iiiiijjjkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[5]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x5221: return GFZ10_iiiiijjkkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[5]], fre[alleles2[7]], fre[alleles2[9]]);
                            case 0x52111: return GFZ10_iiiiijjklm(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[5]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x511111: return GFZ10_iiiiijklmn(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x442: return GFZ10_iiiijjjjkk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[8]]);
                            case 0x4411: return GFZ10_iiiijjjjkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x433: return GFZ10_iiiijjjkkk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[7]]);
                            case 0x4321: return GFZ10_iiiijjjkkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[7]], fre[alleles2[9]]);
                            case 0x43111: return GFZ10_iiiijjjklm(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x4222: return GFZ10_iiiijjkkll(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[6]], fre[alleles2[8]]);
                            case 0x42211: return GFZ10_iiiijjkklm(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[6]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x421111: return GFZ10_iiiijjklmn(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[6]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x4111111: return GFZ10_iiiijklmno(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x3331: return GFZ10_iiijjjkkkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[6]], fre[alleles2[9]]);
                            case 0x3322: return GFZ10_iiijjjkkll(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[6]], fre[alleles2[8]]);
                            case 0x33211: return GFZ10_iiijjjkklm(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[6]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x331111: return GFZ10_iiijjjklmn(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[6]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x32221: return GFZ10_iiijjkkllm(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[5]], fre[alleles2[7]], fre[alleles2[9]]);
                            case 0x322111: return GFZ10_iiijjkklmn(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[5]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x3211111: return GFZ10_iiijjklmno(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x31111111: return GFZ10_iiijklmnop(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[4]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x22222: return GFZ10_iijjkkllmm(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[4]], fre[alleles2[6]], fre[alleles2[8]]);
                            case 0x222211: return GFZ10_iijjkkllmn(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[4]], fre[alleles2[6]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x2221111: return GFZ10_iijjkklmno(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[4]], fre[alleles2[6]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x22111111: return GFZ10_iijjklmnop(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[4]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x211111111: return GFZ10_iijklmnopq(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[3]], fre[alleles2[4]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            case 0x1111111111: return GFZ10_ijklmnopqr(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[1]], fre[alleles2[2]], fre[alleles2[3]], fre[alleles2[4]], fre[alleles2[5]], fre[alleles2[6]], fre[alleles2[7]], fre[alleles2[8]], fre[alleles2[9]]);
                            default: return -1;
                        }
                }
                return -1;
            }

            public double GFG(IDictionary<int, double> fre, double[] alpha)
            {
                int ploidy = alleles2.Length;
                if (ploidy == 1)
                    return fre[alleles2[0]];

                switch (ploidy)
                {
                    case 2:
                        switch (pattern)
                        {
                            case 0x2: return GFG4_ii(alpha[1], fre[alleles2[0]]);
                            case 0x11: return GFG4_ij(alpha[1], fre[alleles2[0]], fre[alleles2[1]]);
                        }
                        return -1;
                    case 3:
                        switch (pattern)
                        {
                            case 0x3: return GFG6_iii(alpha[1], fre[alleles2[0]]);
                            case 0x21: return GFG6_iij(alpha[1], fre[alleles2[0]], fre[alleles2[2]]);
                            case 0x111: return GFG6_ijk(alpha[1], fre[alleles2[0]], fre[alleles2[1]], fre[alleles2[2]]);
                        }
                        return -1;
                    case 4:
                        switch (pattern)
                        {
                            case 0x4: return GFG8_iiii(alpha[1], alpha[2], fre[alleles2[0]]);
                            case 0x31: return GFG8_iiij(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]]);
                            case 0x22: return GFG8_iijj(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]]);
                            case 0x211: return GFG8_iijk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[3]]);
                            case 0x1111: return GFG8_ijkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[1]], fre[alleles2[2]], fre[alleles2[3]]);
                        }
                        return -1;
                    case 5:
                        switch (pattern)
                        {
                            case 0x5: return GFG10_iiiii(alpha[1], alpha[2], fre[alleles2[0]]);
                            case 0x41: return GFG10_iiiij(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[4]]);
                            case 0x32: return GFG10_iiijj(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]]);
                            case 0x311: return GFG10_iiijk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[3]], fre[alleles2[4]]);
                            case 0x221: return GFG10_iijjk(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[4]]);
                            case 0x2111: return GFG10_iijkl(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[2]], fre[alleles2[3]], fre[alleles2[4]]);
                            case 0x11111: return GFG10_ijklm(alpha[1], alpha[2], fre[alleles2[0]], fre[alleles2[1]], fre[alleles2[2]], fre[alleles2[3]], fre[alleles2[4]]);
                        }
                        return -1;
                }
                return -1;
            }

            public double GetIAMDist()
            {
                double re = 0;
                for (int i = 0; i < alleles2.Length; ++i)
                    for (int j = 0; j < i; ++j)
                        re += alleles2[i] == alleles2[j] ? 0 : 1;
                return re;
            }

            public double GetIAMDist(GENOBODY B)
            {
                double re = 0;
                foreach (int a in alleles2)
                    foreach (int b in B.alleles2)
                        re += a == b ? 0 : 1;
                return re;
            }

            public double GetSMMDist(double NULLSQDIST)
            {
                double re = 0;
                for (int i = 0; i < alleles2.Length; ++i)
                    for (int j = 0; j < i; ++j)
                        if (alleles2[i] == alleles2[j]) continue;
                        else if (alleles2[i] == NULL_ALLELE || alleles2[j] == NULL_ALLELE)
                            re += NULLSQDIST;
                        else if (alleles2[i] != alleles2[j])
                            re += (alleles2[i] - alleles2[j]) * (alleles2[i] - alleles2[j]);
                return re;
            }

            public double GetSMMDist(double NULLSQDIST, GENOBODY B)
            {
                double re = 0;
                foreach (int a in alleles2)
                    foreach (int b in B.alleles2)
                        if (a == b) continue;
                        else if (a == NULL_ALLELE || b == NULL_ALLELE)
                            re += NULLSQDIST;
                        else if (a != b)
                            re += (a - b) * (a - b);
                return re;
            }

            public void GetGametes(int clay, int max, int cidx, bool allowdr, double[] alpha, int[] gals, ConcurrentDictionary<uint, GENOBODY> ggamete)
            {
                if (clay == 0)
                {
                    if (gametes == null)
                        gametes = new Dictionary<uint, GENOBODY>();
                    else
                        return;
                }

                if (clay == max)
                {
                    GENOBODY g = new GENOBODY(gals);
                    if (!ggamete.ContainsKey(g.hash))
                        ggamete[g.hash] = g;
                    else
                        g = ggamete[g.hash];

                    gametes[g.hash] = g;
                }
                else
                {
                    if (allowdr && alpha[0] < 0.999999999999999)
                    {
                        //DR
                        gals[clay] = alleles2[cidx];
                        GetGametes(clay + 1, max, cidx + 1, false, alpha, gals, ggamete);
                    }

                    if (allowdr) cidx++;

                    for (int i = cidx; i < alleles2.Length; ++i)
                    {
                        //next different
                        if (i > cidx && gals[clay] == alleles2[i]) continue;
                        gals[clay] = alleles2[i]; //No DR
                        GetGametes(clay + 1, max, i, true, alpha, gals, ggamete);
                    }
                }
            }

        }

        public class GENOTYPE
        {
            public GENOBODY body;//shared part to save memory

            public Dictionary<int, int> alleles
            {
                get { return body.alleles; }
                //set { body.alleles = value; }
            }
            public int[] alleles2 //sort in descending order of replicates
            {
                get { return body.alleles2; }
                //set { body.alleles2 = value; }
            }
            public long pattern
            {
                get { return body.pattern; }
                //set { body.pattern = value; }
            }
            public double hwecoef
            {
                get { return body.hwecoef; }
                //set { body.hwecoef = value; }
            }
            public uint hash
            {
                get { return body.GetHash(); }
                //set { body.hash = value; }
            }
            public int ploidy
            {
                get { return alleles2.Length; }
                //set { body.hash = value; }
            }
            public Dictionary<uint, GENOBODY> gametes
            {
                get { return body.gametes; }
                //set { body.hash = value; }
            }

            public double prior = 0;
            public double poster = 0;
            public double count = 0;

            public override bool Equals(object obj)
            {
                var obj2 = (GENOTYPE)obj;
                return hash == obj2.hash;
            }

            public override int GetHashCode()
            {
                return (int)hash;
            }

            public GENOTYPE(IEnumerable<int> als)
            {
                body = new GENOBODY(als);
            }

            public GENOTYPE(GENOBODY gb)
            {
                body = gb;
            }

            public int GetRefMode()
            {
                return body.GetRefMode();
            }

            public int GetS2Index()
            {
                return body.GetS2Index();
            }

            public double GetHIndex()
            {
                return body.GetHIndex();
            }

            public double GetPxlk2()
            {
                return body.GetPxlk2();
            }

            public void GetHoDiallelic(double w, Dictionary<int, double> D)
            {
                body.GetHoDiallelic(w, D);
            }

            public double GetIAMDist()
            {
                return body.GetIAMDist();
            }

            public double GetIAMDist(GENOTYPE B)
            {
                return body.GetIAMDist(B.body);
            }

            public double GetSMMDist(double NULLSQDIST)
            {
                return body.GetSMMDist(NULLSQDIST);
            }

            public double GetSMMDist(double NULLSQDIST, GENOTYPE B)
            {
                return body.GetSMMDist(NULLSQDIST, B.body);
            }

            public double GFZ(Dictionary<int, double> fre, double f)
            {
                return body.GFZ(fre, f);
            }

            public double GFZ(Dictionary<int, double> fre, double[] alpha)
            {
                return body.GFZ(fre, alpha);
            }

            public double GFG(Dictionary<int, double> fre, double[] alpha)
            {
                return body.GFG(fre, alpha);
            }

            public GENOBODY GetSecondSemiGenotype(GENOBODY first)
            {
                return body.GetSecondSemiGenotype(first);
            }

            public bool IsSemiGenotype(GENOBODY semi)
            {
                return body.IsSemiGenotype(semi);
            }

            public double TransitionalGameteFrequency(double[] alpha, GENOBODY g)
            {
                return body.TransitionalGameteFrequency(alpha, g);
            }

            private double CondDeltaSub(Dictionary<int, int> x, Dictionary<int, int> y, double coef, int rd, KeyValuePair<int, double>[] fre, int k, double g)
            {
                int a = fre[k].Key;
                double f = fre[k].Value;
                int xk = x.ContainsKey(a) ? x[a] : 0, yk = y.ContainsKey(a) ? y[a] : 0;
                int mink = Math.Min(rd, Math.Min(xk, yk));
                double re = 0;

                if (k == fre.Length - 1)
                {
                    if (rd <= mink)
                    {
                        int zk = rd;
                        double gk = f * g;
                        re = coef / (Factorial(xk - zk) * Factorial(zk) * Factorial(yk - zk));
                        for (int j = 0; j < xk + yk - zk; ++j)
                            re *= gk + j;
                    }
                }
                else
                {
                    for (int zk = 0; zk <= mink; ++zk)
                    {
                        double c2 = 1.0 / (Factorial(xk - zk) * Factorial(zk) * Factorial(yk - zk));
                        double gk = f * g;
                        for (int j = 0; j < xk + yk - zk; ++j)
                            c2 *= gk + j;
                        re += CondDeltaSub(x, y, coef * c2, rd - zk, fre, k + 1, g);
                    }
                }
                return re;
            }

            public double CondDelta(GENOTYPE y, int d, KeyValuePair<int, double>[] fre, double f)
            {
                //Heritability paper Eqn A9
                if (alleles.Count == 0) return 0;
                if (f <= 1e-6) f = 1e-6;
                if (f >= 0.999999) f = 0.999999;

                int v = ploidy;
                double g = 1.0 / f - 1, coef = 1.0;
                for (int j = 0; j < v + v - d; ++j)
                    coef *= g + j;
                coef = Factorial(v - d) * Factorial(d) * Factorial(v - d) / coef;
                return CondDeltaSub(alleles, y.alleles, coef, d, fre, 0, g);
            }

            public void MousseauProb(GENOTYPE b, double f, KeyValuePair<int, double>[] fre, ref double prfs)
            {
                //Mousseau 1998, get posterior prob of full-sibs
                int v = ploidy;
                double[] prd = new double[v + 1];

                for (int d = 0; d <= v; ++d)
                    prd[d] = CondDelta(b, d, fre, f);

                switch (v)
                {
                    case 2:
                        prfs *= (0.25 * prd[0] + 0.5 * prd[1] + 0.25 * prd[2]) / prd[0];
                        break;
                    case 4:
                        prfs *= (1 * prd[0] / 36.0 + 2 * prd[1] / 9.0 + 1 * prd[2] / 2.0 + 2 * prd[3] / 9.0 + 1 * prd[4] / 36.0) / prd[0];
                        break;
                    case 6:
                        prfs *= (1 * prd[0] / 400.0 + 9 * prd[1] / 200.0 + 99 * prd[2] / 400.0 + 41 * prd[3] / 100.0 + 99 * prd[4] / 400.0 + 9 * prd[5] / 200.0 + 1 * prd[6] / 400.0) / prd[0];
                        break;
                    case 8:
                        prfs *= (1 * prd[0] / 4900.0 + 8 * prd[1] / 1225.0 + 82 * prd[2] / 1225.0 + 296 * prd[3] / 1225.0 + 181 * prd[4] / 490.0 + 296 * prd[5] / 1225.0 + 82 * prd[6] / 1225.0 + 8 * prd[7] / 1225.0 + 1 * prd[8] / 4900.0) / prd[0];
                        break;
                    case 10:
                        prfs *= (1 * prd[0] / 63504.0 + 25 * prd[1] / 31752.0 + 275 * prd[2] / 21168.0 + 325 * prd[3] / 3969.0 + 1075 * prd[4] / 4536.0 + 253 * prd[5] / 756.0 + 1075 * prd[6] / 4536.0 + 325 * prd[7] / 3969.0 + 275 * prd[8] / 21168.0 + 25 * prd[9] / 31752.0 + 1 * prd[10] / 63504.0) / prd[0];
                        break;
                }
            }

            public void ThomasProb(GENOTYPE b, double f, KeyValuePair<int, double>[] fre, ref double prxfs, ref double prxhs)
            {
                //Thomas 2000, get posterior prob of half-sibs and full-sibs
                int v = ploidy;
                double[] prd = new double[v + 1];

                for (int d = 0; d <= v; ++d)
                    prd[d] = CondDelta(b, d, fre, f);

                switch (v)
                {
                    case 2:
                        prxfs *= (0.25 * prd[0] + 0.5 * prd[1] + 0.25 * prd[2]) / prd[0];
                        prxhs *= (0.5 * prd[0] + 0.5 * prd[1]) / prd[0];
                        break;
                    case 4:
                        prxfs *= (1 * prd[0] / 36.0 + 2 * prd[1] / 9.0 + 1 * prd[2] / 2.0 + 2 * prd[3] / 9.0 + 1 * prd[4] / 36.0) / prd[0];
                        prxhs *= (1 * prd[0] / 6.0 + 2 * prd[1] / 3.0 + 1 * prd[2] / 6.0) / prd[0];
                        break;
                    case 6:
                        prxfs *= (1 * prd[0] / 400.0 + 9 * prd[1] / 200.0 + 99 * prd[2] / 400.0 + 41 * prd[3] / 100.0 + 99 * prd[4] / 400.0 + 9 * prd[5] / 200.0 + 1 * prd[6] / 400.0) / prd[0];
                        prxhs *= (1 * prd[0] / 20.0 + 9 * prd[1] / 20.0 + 9 * prd[2] / 20.0 + 1 * prd[3] / 20.0) / prd[0];
                        break;
                    case 8:
                        prxfs *= (1 * prd[0] / 4900.0 + 8 * prd[1] / 1225.0 + 82 * prd[2] / 1225.0 + 296 * prd[3] / 1225.0 + 181 * prd[4] / 490.0 + 296 * prd[5] / 1225.0 + 82 * prd[6] / 1225.0 + 8 * prd[7] / 1225.0 + 1 * prd[8] / 4900.0) / prd[0];
                        prxhs *= (1 * prd[0] / 70.0 + 8 * prd[1] / 35.0 + 18 * prd[2] / 35.0 + 8 * prd[3] / 35.0 + 1 * prd[4] / 70.0) / prd[0];
                        break;
                    case 10:
                        prxfs *= (1 * prd[0] / 63504.0 + 25 * prd[1] / 31752.0 + 275 * prd[2] / 21168.0 + 325 * prd[3] / 3969.0 + 1075 * prd[4] / 4536.0 + 253 * prd[5] / 756.0 + 1075 * prd[6] / 4536.0 + 325 * prd[7] / 3969.0 + 275 * prd[8] / 21168.0 + 25 * prd[9] / 31752.0 + 1 * prd[10] / 63504.0) / prd[0];
                        prxhs *= (1 * prd[0] / 252.0 + 25 * prd[1] / 252.0 + 25 * prd[2] / 63.0 + 25 * prd[3] / 63.0 + 25 * prd[4] / 252.0 + 1 * prd[5] / 252.0) / prd[0];
                        break;
                }
            }

            public GENOTYPE GetDummyGenotypeTruncate(Random rnd)
            {
                int a = rnd.Next(ploidy);
                int b = NextAvoid(rnd, ploidy, a);
                return new GENOTYPE(new int[2] { alleles2[a], alleles2[b] });
            }

            public GENOTYPE[] GetDummyGenotypeSplit(Random rnd)
            {
                int[] seq = new int[ploidy];
                GetRandSeq(seq, rnd);
                GENOTYPE[] re = new GENOTYPE[ploidy / 2];
                for (int i = 0; i < ploidy; i += 2)
                    re[i] = new GENOTYPE(new int[2] { alleles2[seq[i]], alleles2[seq[i + 1]] });
                return re;
            }
        }

        public class PHENOBODY
        {
            public uint hash;
            public int[] alleles;
            public GENOBODY[] genotypes;
            public int ploidy;
            public Dictionary<uint, GENOBODY> gametes = null;
            public Dictionary<uint, List<GENOBODY>> semigenotypes = null;

            public PHENOBODY(int _ploidy, int[] als, bool copy)
            {
                //als may have duplicated alleles
                ploidy = _ploidy;
                alleles = copy ? als.ToArray() : als;
                GetHash();
            }

            public void GetHash()
            {
                Array.Sort(alleles);
                if (alleles.Length == 0)
                    hash = 0;
                else
                    hash = HashPhenotype(ploidy, alleles);
            }

            public void GetGenotypes()
            {
                //obtained hidden genotypes
                lock (this)
                {
                    if (genotypes != null) return;

                    if (alleles.Length > ploidy || (hash == 0 && !CONSIDER_NULL))
                    {
                        genotypes = new GENOBODY[0];
                        return;
                    }

                    //for genotype input, rem = 0 and extract 1 genotypes
                    int rem = ploidy - alleles.Length;

                    if (rem > 0)
                    {
                        //for missing data and consider null alleles
                        //YYYY is extracted and poster prob < 1 to calculate allele frequency

                        List<int> allele_nodup = alleles.Distinct().ToList();
                        if (CONSIDER_NULL) allele_nodup.Add(NULL_ALLELE);

                        genotypes = new GENOBODY[(int)BINOMIAL[rem + allele_nodup.Count - 1, rem]];

                        int[] als = new int[ploidy];
                        Array.Copy(alleles, als, alleles.Length);
                        int cp = 0;
                        GetGenotypeSub(alleles.Length, 0, als, allele_nodup.ToArray(), ref cp);
                    }
                    else
                        genotypes = new GENOBODY[] { new GENOBODY(alleles) };
                }
                //does not need to save genotypes into a global dict
                //because this is a PHENOBODY, and has been saved in a global dict
            }

            private void GetGenotypeSub(int clay, int cidx, int[] als, int[] can, ref int cp)
            {
                if (clay == ploidy)
                    genotypes[cp++] = new GENOBODY(als);
                else for (int i = cidx; i < can.Length; ++i)
                {
                    als[clay] = can[i];
                    GetGenotypeSub(clay + 1, i, als, can, ref cp);
                }
            }

            public void GetGametes(double[] alpha, ConcurrentDictionary<uint, GENOBODY> ggamete)
            {
                //obtain gametes for hidden genotypes
                lock (this)
                {
                    //parentage analysis
                    if (gametes != null || hash == 0) return;

                    gametes = new Dictionary<uint, GENOBODY>();
                    int[] gals = new int[ploidy / 2];
                    foreach (GENOBODY gb in genotypes)
                    {
                        gb.GetGametes(0, ploidy / 2, 0, false, alpha, gals, ggamete);
                        foreach (GENOBODY ga in gb.gametes.Values)
                            gametes[ga.hash] = ga;
                    }
                }
            }

            public bool IsSemiGenotypePair(GENOBODY first, GENOBODY second)
            {
                foreach (int a in alleles)
                    if (!first.alleles.ContainsKey(a) && !second.alleles.ContainsKey(a))
                        return false;
                return true;
            }

            public void GetSemiGenotypes(ConcurrentDictionary<uint, GENOBODY> gdict, bool isgeno)
            {
                lock (this)
                {
                    if (semigenotypes != null) return;

                    semigenotypes = new Dictionary<uint, List<GENOBODY>>();

                    if (alleles.Length > ploidy || hash == 0)
                        return;

                    if (isgeno)
                        GetSemiGenotypesSubGeno(0, 0, new int[ploidy / 2], gdict);
                    else
                    {
                        GetSemiGenotypesSubPheno(0, 0, new int[ploidy / 2], gdict);

                        foreach(var kv in semigenotypes)
                        {
                            List<GENOBODY> ls = kv.Value;
                            GENOBODY ga = ls[0];

                            foreach (var vv in semigenotypes.Values)
                            {
                                GENOBODY gb = vv[0];
                                if (IsSemiGenotypePair(ga, gb))
                                    ls.Add(gb);
                            }
                        }
                    }
                }
            }

            public void GetSemiGenotypesSubGeno(int clay, int cidx, int[] als, ConcurrentDictionary<uint, GENOBODY> gdict)
            {
                if (clay == ploidy / 2)
                {
                    GENOBODY a = new GENOBODY(als), b = genotypes[0].GetSecondSemiGenotype(a);
                    if (a.hash == b.hash)
                    {
                        if (semigenotypes.ContainsKey(a.hash)) return;
                        if (!gdict.ContainsKey(a.hash))
                            gdict[a.hash] = a;
                        else
                            a = gdict[a.hash];
                        semigenotypes.Add(a.hash, new List<GENOBODY>() { a, a });
                    }
                    else
                    {
                        if (semigenotypes.ContainsKey(a.hash) || semigenotypes.ContainsKey(b.hash)) return;
                        if (!gdict.ContainsKey(a.hash))
                            gdict[a.hash] = a;
                        else
                            a = gdict[a.hash];
                        if (!gdict.ContainsKey(b.hash))
                            gdict[b.hash] = b;
                        else
                            b = gdict[b.hash];

                        semigenotypes.Add(a.hash, new List<GENOBODY>() { a, b });
                        semigenotypes.Add(b.hash, new List<GENOBODY>() { b, a });
                    }
                }
                else
                {
                    for (int i = cidx; i < (clay == 0 ? 1 : alleles.Length); ++i)
                    {
                        //aoivd to sample the same allele as previous loop
                        if (i > cidx && als[clay] == alleles[i]) continue;
                        als[clay] = alleles[i];
                        GetSemiGenotypesSubGeno(clay + 1, i + 1, als, gdict);
                    }
                }
            }

            public void GetSemiGenotypesSubPheno(int clay, int cidx, int[] als, ConcurrentDictionary<uint, GENOBODY> gdict)
            {
                if (clay == ploidy / 2)
                {
                    GENOBODY a = new GENOBODY(als);
                    if (!gdict.ContainsKey(a.hash))
                        gdict[a.hash] = a;
                    else
                        a = gdict[a.hash];

                    semigenotypes.Add(a.hash, new List<GENOBODY>() { a });
                }
                else
                {
                    int len = alleles.Length + (CONSIDER_NULL ? 1 : 0);
                    for (int i = cidx; i < len; ++i)
                    {
                        als[clay] = i < alleles.Length ? alleles[i] : NULL_ALLELE;
                        GetSemiGenotypesSubPheno(clay + 1, i, als, gdict);
                    }
                }
            }
        }

        public class PHENOTYPE
        {
            //phenotype
            public PHENOBODY body;
            public GENOTYPE[] genotypes = null; //save priori, poster, count
            public GENOTYPE[][] semigenotypes = null;
            public double prob = -1;//in subpop
            public int count = 0;//in subpop
            public /*Concurrent*/Dictionary<int, double> freq = null;//in subpop

            public uint hash
            {
                get { return body.hash; }
                //set { body.hash = value; }
            }
            public int[] alleles//no duplicate alleles
            {
                get { return body.alleles; }
                //set { body.alleles = value; }
            }
            public int ploidy
            {
                get { return body.ploidy; }
                //set { body.ploidy = value; }
            }

            public PHENOTYPE(PHENOBODY pb)
            {
                body = pb;
            }

            public PHENOTYPE(int _ploidy, int[] nodup, bool copy)
            {
                body = new PHENOBODY(_ploidy, nodup, copy);
            }

            public PHENOTYPE(PHENOTYPE ph)
            {
                count = 0;
                body = ph.body;

                if (ph.genotypes == null) return;

                genotypes = new GENOTYPE[ph.genotypes.Length];
                for (int i = 0; i < genotypes.Length; ++i)
                    genotypes[i] = new GENOTYPE(ph.genotypes[i].body);
            }

            public void GetGenotypes()
            {
                lock (this)
                {
                    if (genotypes != null) return;
                    body.GetGenotypes();
                    genotypes = new GENOTYPE[body.genotypes.Length];
                    for (int i = 0; i < genotypes.Length; ++i)
                        genotypes[i] = new GENOTYPE(body.genotypes[i]);
                }
            }

            public void GetSemiGenotypes(ConcurrentDictionary<uint, GENOBODY> gdict, bool isgeno)
            {
                lock (this)
                {
                    if (semigenotypes != null) return;
                    body.GetSemiGenotypes(gdict, isgeno);

                    Dictionary<uint, GENOTYPE> buf = new Dictionary<uint, GENOTYPE>();
                    foreach (List<GENOBODY> ls in body.semigenotypes.Values)
                    {
                        GENOBODY gb = ls[0];
                        buf[gb.hash] = new GENOTYPE(gb);
                    }

                    int cp = 0;
                    semigenotypes = new GENOTYPE[body.semigenotypes.Count][];
                    foreach (List<GENOBODY> ls in body.semigenotypes.Values)
                    {
                        GENOTYPE[] arr = new GENOTYPE[ls.Count];
                        int j = 0;
                        foreach (GENOBODY ga in ls)
                            arr[j++] = buf[ga.hash];
                        semigenotypes[cp++] = arr;
                    }
                }
            }

            public PHENOTYPE GetPhenotype()
            {
                //convert into observed phenotype
                return new PHENOTYPE(alleles.Length,
                    alleles.Where(a => a != NULL_ALLELE).Distinct().ToArray(), false);
            }

            public void GetGametes(double[] alpha, ConcurrentDictionary<uint, GENOBODY> ggamete)
            {
                body.GetGametes(alpha, ggamete);
            }

            public double PFZ(bool isgenotype, Dictionary<int, double> fre, double f, double beta = 0)
            {
                double re = 0;
                foreach (GENOTYPE gh in genotypes)
                    re += gh.GFZ(fre, f);

                return isgenotype ? re : re * (1 - beta) + (hash == 0 ? beta : 0);
            }

            public double PFZ(Dictionary<int, double> fre1, double f1, Dictionary<int, double> fre2, double f2)
            {
                foreach (GENOTYPE[] a in semigenotypes)
                {
                    GENOTYPE ga = a[0];
                    ga.prior = ga.GFZ(fre1, f1);
                    ga.poster = ga.GFZ(fre2, f2);
                }

                double re = 0;
                foreach (GENOTYPE[] a in semigenotypes)
                {
                    GENOTYPE ga = a[0];
                    double s1 = 0;
                    int len2 = a.Length;
                    for (int j = 1; j < len2; ++j)
                        s1 += a[j].poster;
                    re += ga.prior * s1;
                }
                return re;
            }

            public double PFZ(bool isgenotype, Dictionary<int, double> fre, double[] alpha, double beta)
            {
                if (ploidy == 0)
                    return 0;

                if (isgenotype)
                {
                    double re = 0;
                    foreach (GENOTYPE gh in genotypes)
                        re += gh.GFZ(fre, alpha);
                    return re;
                }

                if (!CONSIDER_NULL) switch (ploidy)
                    {
                        case 1:
                            switch (alleles.Length)
                            {
                                case 0: return beta;
                                case 1: return (1 - beta) * fre[alleles[0]];
                            }
                            break;
                        case 2:
                            switch (alleles.Length)
                            {
                                case 0: return beta;
                                case 1: return (1 - beta) * fre[alleles[0]] * fre[alleles[0]];
                                case 2: return (1 - beta) * 2 * fre[alleles[0]] * fre[alleles[1]];
                            }
                            break;
                        case 3:
                            switch (alleles.Length)
                            {
                                case 0: return beta;
                                case 1: return (1 - beta) * PFZ3_i(fre[alleles[0]]);
                                case 2: return (1 - beta) * PFZ3_ij(fre[alleles[0]], fre[alleles[1]]);
                                case 3: return (1 - beta) * PFZ3_ijk(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]);
                            }
                            break;
                        case 4:
                            switch (alleles.Length)
                            {
                                case 0: return beta;
                                case 1: return (1 - beta) * PFZ4_i(alpha[1], fre[alleles[0]]);
                                case 2: return (1 - beta) * PFZ4_ij(alpha[1], fre[alleles[0]], fre[alleles[1]]);
                                case 3: return (1 - beta) * PFZ4_ijk(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]);
                                case 4: return (1 - beta) * PFZ4_ijkl(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]);
                            }
                            break;
                        case 5:
                            switch (alleles.Length)
                            {
                                case 0: return beta;
                                case 1: return (1 - beta) * PFZ5_i(fre[alleles[0]]);
                                case 2: return (1 - beta) * PFZ5_ij(fre[alleles[0]], fre[alleles[1]]);
                                case 3: return (1 - beta) * PFZ5_ijk(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]);
                                case 4: return (1 - beta) * PFZ5_ijkl(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]);
                                case 5: return (1 - beta) * PFZ5_ijklm(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]]);
                            }
                            break;
                        case 6:
                            switch (alleles.Length)
                            {
                                case 0: return beta;
                                case 1: return (1 - beta) * PFZ6_i(alpha[1], fre[alleles[0]]);
                                case 2: return (1 - beta) * PFZ6_ij(alpha[1], fre[alleles[0]], fre[alleles[1]]);
                                case 3: return (1 - beta) * PFZ6_ijk(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]);
                                case 4: return (1 - beta) * PFZ6_ijkl(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]);
                                case 5: return (1 - beta) * PFZ6_ijklm(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]]);
                                case 6: return (1 - beta) * PFZ6_ijklmn(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]]);
                            }
                            break;
                        case 7:
                            switch (alleles.Length)
                            {
                                case 0: return beta;
                                case 1: return (1 - beta) * PFZ7_i(fre[alleles[0]]);
                                case 2: return (1 - beta) * PFZ7_ij(fre[alleles[0]], fre[alleles[1]]);
                                case 3: return (1 - beta) * PFZ7_ijk(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]);
                                case 4: return (1 - beta) * PFZ7_ijkl(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]);
                                case 5: return (1 - beta) * PFZ7_ijklm(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]]);
                                case 6: return (1 - beta) * PFZ7_ijklmn(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]]);
                                case 7: return (1 - beta) * PFZ7_ijklmno(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]]);
                            }
                            break;
                        case 8:
                            switch (alleles.Length)
                            {
                                case 0: return beta;
                                case 1: return (1 - beta) * PFZ8_i(alpha[1], alpha[2], fre[alleles[0]]);
                                case 2: return (1 - beta) * PFZ8_ij(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]]);
                                case 3: return (1 - beta) * PFZ8_ijk(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]);
                                case 4: return (1 - beta) * PFZ8_ijkl(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]);
                                case 5: return (1 - beta) * PFZ8_ijklm(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]]);
                                case 6: return (1 - beta) * PFZ8_ijklmn(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]]);
                                case 7: return (1 - beta) * PFZ8_ijklmno(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]]);
                                case 8: return (1 - beta) * PFZ8_ijklmnop(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]]);
                            }
                            break;
                        case 9:
                            switch (alleles.Length)
                            {
                                case 0: return beta;
                                case 1: return (1 - beta) * PFZ9_i(fre[alleles[0]]);
                                case 2: return (1 - beta) * PFZ9_ij(fre[alleles[0]], fre[alleles[1]]);
                                case 3: return (1 - beta) * PFZ9_ijk(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]);
                                case 4: return (1 - beta) * PFZ9_ijkl(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]);
                                case 5: return (1 - beta) * PFZ9_ijklm(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]]);
                                case 6: return (1 - beta) * PFZ9_ijklmn(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]]);
                                case 7: return (1 - beta) * PFZ9_ijklmno(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]]);
                                case 8: return (1 - beta) * PFZ9_ijklmnop(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]]);
                                case 9: return (1 - beta) * PFZ9_ijklmnopq(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]], fre[alleles[8]]);
                            }
                            break;
                        case 10:
                            switch (alleles.Length)
                            {
                                case 0: return beta;
                                case 1: return (1 - beta) * PFZ10_i(alpha[1], alpha[2], fre[alleles[0]]);
                                case 2: return (1 - beta) * PFZ10_ij(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]]);
                                case 3: return (1 - beta) * PFZ10_ijk(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]);
                                case 4: return (1 - beta) * PFZ10_ijkl(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]);
                                case 5: return (1 - beta) * PFZ10_ijklm(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]]);
                                case 6: return (1 - beta) * PFZ10_ijklmn(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]]);
                                case 7: return (1 - beta) * PFZ10_ijklmno(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]]);
                                case 8: return (1 - beta) * PFZ10_ijklmnop(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]]);
                                case 9: return (1 - beta) * PFZ10_ijklmnopq(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]], fre[alleles[8]]);
                                case 10: return (1 - beta) * PFZ10_ijklmnopqr(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]], fre[alleles[8]], fre[alleles[9]]);
                            }
                            break;
                    }
                else
                    switch (ploidy)
                    {
                        case 1:
                            switch (alleles.Length)
                            {
                                case 0: return beta + (1 - beta) * fre[NULL_ALLELE];
                                case 1: return (1 - beta) * fre[alleles[0]];
                            }
                            break;
                        case 2:
                            switch (alleles.Length)
                            {
                                case 0: return beta + (1 - beta) * fre[NULL_ALLELE] * fre[NULL_ALLELE];
                                case 1: return (1 - beta) * (fre[alleles[0]] * fre[alleles[0]] + 2 * fre[alleles[0]] * fre[NULL_ALLELE]);
                                case 2: return (1 - beta) * (2 * fre[alleles[0]] * fre[alleles[1]]);
                            }
                            break;
                        case 3:
                            switch (alleles.Length)
                            {
                                case 0: return beta + (1 - beta) * PFZ3_i(fre[alleles[NULL_ALLELE]]);
                                case 1: return (1 - beta) * (PFZ3_i(fre[alleles[0]]) + PFZ3_ij(fre[alleles[0]], fre[NULL_ALLELE]));
                                case 2: return (1 - beta) * (PFZ3_ij(fre[alleles[0]], fre[alleles[1]]) + PFZ3_ijk(fre[alleles[0]], fre[alleles[1]], fre[NULL_ALLELE]));
                                case 3: return (1 - beta) * (PFZ3_ijk(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]));
                            }
                            break;
                        case 4:
                            switch (alleles.Length)
                            {
                                case 0: return beta + (1 - beta) * PFZ4_i(alpha[1], fre[alleles[NULL_ALLELE]]);
                                case 1: return (1 - beta) * (PFZ4_i(alpha[1], fre[alleles[0]]) + PFZ4_ij(alpha[1], fre[alleles[0]], fre[NULL_ALLELE]));
                                case 2: return (1 - beta) * (PFZ4_ij(alpha[1], fre[alleles[0]], fre[alleles[1]]) + PFZ4_ijk(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[NULL_ALLELE]));
                                case 3: return (1 - beta) * (PFZ4_ijk(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]) + PFZ4_ijkl(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[NULL_ALLELE]));
                                case 4: return (1 - beta) * (PFZ4_ijkl(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]));
                            }
                            break;
                        case 5:
                            switch (alleles.Length)
                            {
                                case 0: return beta + (1 - beta) * PFZ5_i(fre[alleles[NULL_ALLELE]]);
                                case 1: return (1 - beta) * (PFZ5_i(fre[alleles[0]]) + PFZ5_ij(fre[alleles[0]], fre[NULL_ALLELE]));
                                case 2: return (1 - beta) * (PFZ5_ij(fre[alleles[0]], fre[alleles[1]]) + PFZ5_ijk(fre[alleles[0]], fre[alleles[1]], fre[NULL_ALLELE]));
                                case 3: return (1 - beta) * (PFZ5_ijk(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]) + PFZ5_ijkl(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[NULL_ALLELE]));
                                case 4: return (1 - beta) * (PFZ5_ijkl(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]) + PFZ5_ijklm(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[NULL_ALLELE]));
                                case 5: return (1 - beta) * (PFZ5_ijklm(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]]));
                            }
                            break;
                        case 6:
                            switch (alleles.Length)
                            {
                                case 0: return beta + (1 - beta) * PFZ6_i(alpha[1], fre[alleles[NULL_ALLELE]]);
                                case 1: return (1 - beta) * (PFZ6_i(alpha[1], fre[alleles[0]]) + PFZ6_ij(alpha[1], fre[alleles[0]], fre[NULL_ALLELE]));
                                case 2: return (1 - beta) * (PFZ6_ij(alpha[1], fre[alleles[0]], fre[alleles[1]]) + PFZ6_ijk(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[NULL_ALLELE]));
                                case 3: return (1 - beta) * (PFZ6_ijk(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]) + PFZ6_ijkl(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[NULL_ALLELE]));
                                case 4: return (1 - beta) * (PFZ6_ijkl(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]) + PFZ6_ijklm(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[NULL_ALLELE]));
                                case 5: return (1 - beta) * (PFZ6_ijklm(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]]) + PFZ6_ijklmn(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[NULL_ALLELE]));
                                case 6: return (1 - beta) * (PFZ6_ijklmn(alpha[1], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]]));
                            }
                            break;
                        case 7:
                            switch (alleles.Length)
                            {
                                case 0: return beta + (1 - beta) * PFZ7_i(fre[alleles[NULL_ALLELE]]);
                                case 1: return (1 - beta) * (PFZ7_i(fre[alleles[0]]) + PFZ7_ij(fre[alleles[0]], fre[NULL_ALLELE]));
                                case 2: return (1 - beta) * (PFZ7_ij(fre[alleles[0]], fre[alleles[1]]) + PFZ7_ijk(fre[alleles[0]], fre[alleles[1]], fre[NULL_ALLELE]));
                                case 3: return (1 - beta) * (PFZ7_ijk(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]) + PFZ7_ijkl(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[NULL_ALLELE]));
                                case 4: return (1 - beta) * (PFZ7_ijkl(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]) + PFZ7_ijklm(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[NULL_ALLELE]));
                                case 5: return (1 - beta) * (PFZ7_ijklm(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]]) + PFZ7_ijklmn(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[NULL_ALLELE]));
                                case 6: return (1 - beta) * (PFZ7_ijklmn(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]]) + PFZ7_ijklmno(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[NULL_ALLELE]));
                                case 7: return (1 - beta) * (PFZ7_ijklmno(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]]));
                            }
                            break;
                        case 8:
                            switch (alleles.Length)
                            {
                                case 0: return beta + (1 - beta) * PFZ8_i(alpha[1], alpha[2], fre[alleles[NULL_ALLELE]]);
                                case 1: return (1 - beta) * (PFZ8_i(alpha[1], alpha[2], fre[alleles[0]]) + PFZ8_ij(alpha[1], alpha[2], fre[alleles[0]], fre[NULL_ALLELE]));
                                case 2: return (1 - beta) * (PFZ8_ij(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]]) + PFZ8_ijk(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[NULL_ALLELE]));
                                case 3: return (1 - beta) * (PFZ8_ijk(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]) + PFZ8_ijkl(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[NULL_ALLELE]));
                                case 4: return (1 - beta) * (PFZ8_ijkl(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]) + PFZ8_ijklm(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[NULL_ALLELE]));
                                case 5: return (1 - beta) * (PFZ8_ijklm(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]]) + PFZ8_ijklmn(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[NULL_ALLELE]));
                                case 6: return (1 - beta) * (PFZ8_ijklmn(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]]) + PFZ8_ijklmno(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[NULL_ALLELE]));
                                case 7: return (1 - beta) * (PFZ8_ijklmno(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]]) + PFZ8_ijklmnop(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[NULL_ALLELE]));
                                case 8: return (1 - beta) * (PFZ8_ijklmnop(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]]));
                            }
                            break;
                        case 9:
                            switch (alleles.Length)
                            {
                                case 0: return beta + (1 - beta) * PFZ9_i(fre[alleles[NULL_ALLELE]]);
                                case 1: return (1 - beta) * (PFZ9_i(fre[alleles[0]]) + PFZ9_ij(fre[alleles[0]], fre[NULL_ALLELE]));
                                case 2: return (1 - beta) * (PFZ9_ij(fre[alleles[0]], fre[alleles[1]]) + PFZ9_ijk(fre[alleles[0]], fre[alleles[1]], fre[NULL_ALLELE]));
                                case 3: return (1 - beta) * (PFZ9_ijk(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]) + PFZ9_ijkl(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[NULL_ALLELE]));
                                case 4: return (1 - beta) * (PFZ9_ijkl(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]) + PFZ9_ijklm(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[NULL_ALLELE]));
                                case 5: return (1 - beta) * (PFZ9_ijklm(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]]) + PFZ9_ijklmn(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[NULL_ALLELE]));
                                case 6: return (1 - beta) * (PFZ9_ijklmn(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]]) + PFZ9_ijklmno(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[NULL_ALLELE]));
                                case 7: return (1 - beta) * (PFZ9_ijklmno(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]]) + PFZ9_ijklmnop(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[NULL_ALLELE]));
                                case 8: return (1 - beta) * (PFZ9_ijklmnop(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]]) + PFZ9_ijklmnopq(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]], fre[NULL_ALLELE]));
                                case 9: return (1 - beta) * (PFZ9_ijklmnopq(fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]], fre[alleles[8]]));
                            }
                            break;
                        case 10:
                            switch (alleles.Length)
                            {
                                case 0: return beta + (1 - beta) * PFZ10_i(alpha[1], alpha[2], fre[alleles[NULL_ALLELE]]);
                                case 1: return (1 - beta) * (PFZ10_i(alpha[1], alpha[2], fre[alleles[0]]) + PFZ10_ij(alpha[1], alpha[2], fre[alleles[0]], fre[NULL_ALLELE]));
                                case 2: return (1 - beta) * (PFZ10_ij(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]]) + PFZ10_ijk(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[NULL_ALLELE]));
                                case 3: return (1 - beta) * (PFZ10_ijk(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]]) + PFZ10_ijkl(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[NULL_ALLELE]));
                                case 4: return (1 - beta) * (PFZ10_ijkl(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]]) + PFZ10_ijklm(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[NULL_ALLELE]));
                                case 5: return (1 - beta) * (PFZ10_ijklm(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]]) + PFZ10_ijklmn(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[NULL_ALLELE]));
                                case 6: return (1 - beta) * (PFZ10_ijklmn(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]]) + PFZ10_ijklmno(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[NULL_ALLELE]));
                                case 7: return (1 - beta) * (PFZ10_ijklmno(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]]) + PFZ10_ijklmnop(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[NULL_ALLELE]));
                                case 8: return (1 - beta) * (PFZ10_ijklmnop(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]]) + PFZ10_ijklmnopq(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]], fre[NULL_ALLELE]));
                                case 9: return (1 - beta) * (PFZ10_ijklmnopq(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]], fre[alleles[8]]) + PFZ10_ijklmnopqr(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]], fre[alleles[8]], fre[NULL_ALLELE]));
                                case 10: return (1 - beta) * (PFZ10_ijklmnopqr(alpha[1], alpha[2], fre[alleles[0]], fre[alleles[1]], fre[alleles[2]], fre[alleles[3]], fre[alleles[4]], fre[alleles[5]], fre[alleles[6]], fre[alleles[7]], fre[alleles[8]], fre[alleles[9]]));
                            }
                            break;
                    }
                return 0;
            }

            public double GetIAMDist()
            {
                double re = 0;
                foreach (GENOTYPE gh in genotypes)
                    re += gh.poster * gh.GetIAMDist();
                return re;
            }

            public double GetIAMDist(PHENOTYPE B)
            {
                double re = 0;
                foreach (GENOTYPE ga in genotypes)
                    foreach (GENOTYPE gb in B.genotypes)
                        re += ga.poster * gb.poster * ga.GetIAMDist(gb);
                return re;
            }

            public double GetSMMDist(double NULLSQDIST)
            {
                double re = 0;
                foreach (GENOTYPE gh in genotypes)
                    re += gh.poster * gh.GetSMMDist(NULLSQDIST);
                return re;
            }

            public double GetSMMDist(double NULLSQDIST, PHENOTYPE B)
            {
                double re = 0;
                foreach (GENOTYPE ga in genotypes)
                    foreach (GENOTYPE gb in B.genotypes)
                        re += ga.poster * gb.poster * ga.GetSMMDist(NULLSQDIST, gb);
                return re;
            }

            public double GetTrueIAMDist()
            {
                //for genotype
                double re = 0;
                for (int i = 0; i < alleles.Length; ++i)
                    for (int j = 0; j < i; ++j)
                        re += alleles[i] == alleles[j] ? 0 : 1;
                return re;
            }

            public double GetTrueIAMDist(PHENOTYPE B)
            {
                //for genotype
                double re = 0;
                foreach (int a in alleles)
                    foreach (int b in B.alleles)
                        re += a == b ? 0 : 1;
                return re;
            }

            public double GetTrueSMMDist(double NULLSQDIST)
            {
                double re = 0;
                for (int i = 0; i < alleles.Length; ++i)
                    for (int j = 0; j < i; ++j)
                        if (alleles[i] == NULL_ALLELE && alleles[j] == NULL_ALLELE) continue;
                        else if (alleles[i] == NULL_ALLELE || alleles[j] == NULL_ALLELE)
                            re += NULLSQDIST;
                        else if (alleles[i] != alleles[j])
                            re += (alleles[i] - alleles[j]) * (alleles[i] - alleles[j]);
                return re;
            }

            public double GetTrueSMMDist(PHENOTYPE B, double NULLSQDIST)
            {
                double re = 0;
                foreach (int a in alleles)
                    foreach (int b in B.alleles)
                        if (a == NULL_ALLELE && b == NULL_ALLELE) continue;
                        else if (a == NULL_ALLELE || b == NULL_ALLELE)
                            re += NULLSQDIST;
                        else if (a != b)
                            re += (a - b) * (a - b);
                return re;
            }

            public double GetHIndex()
            {
                double re = 0;
                foreach (GENOTYPE gh in genotypes)
                    re += gh.poster * gh.GetHIndex();
                return re;
            }

            public double GetHardyHidx(int v)
            {
                //only used for phenotypes
                if (ISGENOTYPE)
                {
                    if (genotypes.Length == 1)
                        return genotypes[0].GetHIndex();
                    else
                        return 0;
                }

                if (v == 1) switch (alleles.Length)
                    {
                        case 0: return 0;
                        default: return 0;
                    }
                if (v == 2) switch (alleles.Length)
                    {
                        case 0: return 0;
                        case 1: return 0;
                        default: return 1;
                    }
                if (v == 3) switch (alleles.Length)
                    {
                        case 0: return 0;
                        case 1: return 0;
                        case 2: return 2.0 / 3;
                        default: return 1;
                    }
                if (v == 4) switch (alleles.Length)
                    {
                        case 0: return 0;
                        case 1: return 0;
                        case 2: return 7.0 / 12;
                        case 3: return 5.0 / 6;
                        default: return 1;
                    }
                if (v == 5) switch (alleles.Length)
                    {
                        case 0: return 0;
                        case 1: return 0;
                        case 2: return 1.0 / 2;
                        case 3: return 3.0 / 4;
                        case 4: return 9.0 / 10;
                        default: return 1;
                    }
                if (v == 6) switch (alleles.Length)
                    {
                        case 0: return 0;
                        case 1: return 0;
                        case 2: return 22.0 / 45;
                        case 3: return 32.0 / 45;
                        case 4: return 5.0 / 6;
                        case 5: return 14.0 / 15;
                        default: return 1;
                    }
                if (v == 7) switch (alleles.Length)
                    {
                        case 0: return 0;
                        case 1: return 0;
                        case 2: return 4.0 / 9;
                        case 3: return 2.0 / 3;
                        case 4: return 50.0 / 63;
                        case 5: return 37.0 / 42;
                        case 6: return 20.0 / 21;
                        default: return 1;
                    }
                if (v == 8) switch (alleles.Length)
                    {
                        case 0: return 0;
                        case 1: return 0;
                        case 2: return 25.0 / 56;
                        case 3: return 9.0 / 14;
                        case 4: return 27.0 / 35;
                        case 5: return 71.0 / 84;
                        case 6: return 51.0 / 56;
                        case 7: return 27.0 / 28;
                        default: return 1;
                    }
                if (v == 9) switch (alleles.Length)
                    {
                        case 0: return 0;
                        case 1: return 0;
                        case 2: return 8.0 / 15;
                        case 3: return 74.0 / 105;
                        case 4: return 107.0 / 135;
                        case 5: return 193.0 / 225;
                        case 6: return 122.0 / 135;
                        case 7: return 17.0 / 18;
                        case 8: return 44.0 / 45;
                        default: return 1;
                    }
                if (v == 10) switch (alleles.Length)
                    {
                        case 0: return 0;
                        case 1: return 0;
                        case 2: return 19.0 / 45;
                        case 3: return 11.0 / 18;
                        case 4: return 59.0 / 81;
                        case 5: return 254.0 / 315;
                        case 6: return 193.0 / 225;
                        case 7: return 122.0 / 135;
                        case 8: return 42.0 / 45;
                        case 9: return 44.0 / 45;
                        default: return 1;
                    }
                return 0;
            }

            public GENOTYPE GetRandomGenotype(Random rnd)
            {
                if (genotypes.Length == 0)
                    return null;
                double m = rnd.NextDouble();
                for (int i = 0; i < genotypes.Length; ++i)
                    if (genotypes[i].poster < m)
                        return genotypes[i];
                return genotypes[genotypes.Length - 1];
            }

            public void MousseauProb(Dictionary<ulong, double> dict, PHENOTYPE b, double f, KeyValuePair<int, double>[] fre, ref double prfs)
            {
                //Mousseau 1998, get posterior prob of full-sibs
                ulong id = ((ulong)hash << 32) | b.hash;
                if (dict.ContainsKey(id))
                    prfs *= dict[id];
                else
                {
                    double prfs1 = 1;
                    foreach (GENOTYPE ga in genotypes)
                        foreach (GENOTYPE gb in b.genotypes)
                            ga.MousseauProb(gb, f, fre, ref prfs1);
                    dict[id] = prfs1;
                    prfs *= prfs1;
                }
            }

            public void ThomasProb(Dictionary<ulong, Thomas2000SibRateEntry> dict, PHENOTYPE b, double f, KeyValuePair<int, double>[] fre, ref double prxfs, ref double prxhs)
            {
                //Thomas 2000, get posterior prob of half-sibs and full-sibs
                ulong id = ((ulong)hash << 32) | b.hash;
                if (dict.ContainsKey(id))
                {
                    prxfs *= dict[id].fs;
                    prxhs *= dict[id].hs;
                }
                else
                {
                    double prxfs1 = 1, prxhs1 = 1;
                    foreach (GENOTYPE ga in genotypes)
                        foreach (GENOTYPE gb in b.genotypes)
                            ga.ThomasProb(gb, f, fre, ref prxfs1, ref prxhs1);
                    dict[id] = new Thomas2000SibRateEntry(prxfs1, prxhs1);
                    prxfs *= dict[id].fs;
                    prxhs *= dict[id].hs;
                }
            }

            public static bool IsMismatch(PHENOTYPE o, PHENOTYPE a)
            {
                if (o.hash == 0 || a.hash == 0) return false;
                foreach (GENOTYPE go in o.genotypes)
                    foreach (GENOBODY gga in a.body.gametes.Values)
                        if (go.IsSemiGenotype(gga))
                            return false;
                return true;
            }

            public static bool IsMismatch(PHENOTYPE o, PHENOTYPE a, PHENOTYPE m)
            {
                if (o.hash == 0 || a.hash == 0) return false;
                if (m.hash == 0) return IsMismatch(o, a);
                foreach (GENOTYPE go in o.genotypes)
                    foreach (GENOBODY gga in a.body.gametes.Values)
                        if (go.IsSemiGenotype(gga) && m.body.gametes.ContainsKey(go.GetSecondSemiGenotype(gga).hash))
                            return false;
                return true;
            }
        }

        public class IND
        {
            public int id;
            public string name;
            public int ploidy;
            public SUBPOP subpop;
            public PHENOTYPE[] g;
            public double[] coordinate;
            public double[] quantitative;

            //public bool isfixed = false;
            public double SS1 = 0, SS2 = 0;

            public IND(int _id, string _name, int _ploidy, SUBPOP _subpop)
            {
                id = _id;
                name = _name;
                ploidy = _ploidy;
                subpop = _subpop;
            }

            public IND(int L)
            {
                g = new PHENOTYPE[L];
            }

            public void GetGametes(ConcurrentDictionary<uint, GENOBODY>[,] ggamete)
            {
                for (int l = 0; l < g.Length; ++l)
                    g[l].GetGametes(all.ALPHA[l, ploidy], ggamete[ploidy, l]);
            }

            public int LociTyped()
            {
                int re = 0;
                for (int i = 0; i < g.Length; ++i)
                    if (g[i].hash != 0)
                        re++;
                return re;
            }

            public int LociTyped(IND a)
            {
                if (a == null)
                    return 0;
                int re = 0;
                for (int i = 0; i < g.Length; ++i)
                    if (g[i].hash != 0 && a.g[i].hash != 0)
                        re++;
                return re;
            }

            public int LociTyped(IND a, IND b)
            {
                if (a == null || b == null)
                    return 0;
                int re = 0;
                for (int i = 0; i < g.Length; ++i)
                    if (g[i].hash != 0 && a.g[i].hash != 0 && b.g[i].hash != 0)
                        re++;
                return re;
            }

            public int Mismatch(IND a)
            {
                if (a == null) return 0;
                int re = 0;
                for (int i = 0; i < g.Length; ++i)
                    if (PHENOTYPE.IsMismatch(g[i], a.g[i]))
                        re++;
                return re;
            }

            public int Mismatch(IND a, IND m)
            {
                if (a == null || m == null) return 0;
                int re = 0;
                for (int i = 0; i < g.Length; ++i)
                    if (PHENOTYPE.IsMismatch(g[i], a.g[i], m.g[i]))
                        re++;
                return re;
            }

            public void WriteGenotype(StringBuilder w, Random rnd)
            {
                for (int i = 0; i < g.Length; ++i)
                {
                    w.Append("\t");
                    if (rnd.NextDouble() > SIMPOP_BETA_RATIO)
                    {
                        int[] als = (SIMPOP_OUTPUT_GENOTYPE ? g[i] : g[i].GetPhenotype()).alleles.ToArray();
                        for (int j = 0; j < als.Length; ++j)
                        {
                            if (j != 0) w.Append(",");
                            w.Append(als[j].ToString());
                        }
                    }
                }
                w.Append("\r\n");
            }
        }

        public class LOC
        {
            public int id;
            public int nhaplotypes;
            public int nphenotypes;
            public string name = "";
            public double rs = 0;// -1 for PRCS, -2 for CES
            public double s = 0;
            public double beta = 0;
            public double AE = 0;
            public Dictionary<int, double> freq = new Dictionary<int, double>();
            public Dictionary<int, double>[] freq2;//moments of individual allele frequency, used in Moran's I
            public DRE_GENERATOR root;

            public LOC()
            {

            }

            public LOC(string _name, int _id)
            {
                name = _name;
                id = _id;
            }

            public LOC(LOC r, bool copyfreq)
            {
                id = r.id;
                name = r.name;
                freq = copyfreq ? Clone(r.freq) : CloneKey(r.freq);
            }

            public class DRE_GENERATOR
            {
                public double sumprob;
                public Dictionary<int, DRE_GENERATOR> nodes;
            }

            public Dictionary<int, double> GetMappingFreq(Dictionary<int, int> amap)
            {
                Dictionary<int, double> re = new Dictionary<int, double>();
                foreach (var kv in amap)
                {
                    if (!re.ContainsKey(kv.Value)) 
                        re[kv.Value] = 0;
                    re[kv.Value] += freq[kv.Key];
                }
                return re;
            }

            public void Generator(int ploidy, double[] alpha)
            {
                //to generate genotypes according to dre
                root = new DRE_GENERATOR();

                List<int> g_alleles2 = freq.Keys.ToList();
                g_alleles2.Sort();
                int[] g_alleles = g_alleles2.ToArray();
                int[] c_alleles = new int[ploidy];
                SetVal(c_alleles, -999);
                double lambda = 0;
                for (int i = 1; i < alpha.Length; ++i)
                    lambda += alpha[i] * i;
                double f = (8 * lambda + s * ploidy) / (8 * lambda + ploidy * (s + ploidy - s * ploidy));
                GeneratorSub(0, ploidy, 0, root, alpha, f, g_alleles, c_alleles);
            }

            private double GeneratorSub(int clay, int max, int cidx, DRE_GENERATOR node, double[] alpha, double f, int[] g_alleles, int[] c_alleles)
            {
                if (clay == max)
                {
                    GENOBODY gb = new GENOBODY(c_alleles);
                    node.sumprob = CONSIDER_SELFING ? gb.GFZ(freq, f) : gb.GFZ(freq, alpha);//allow
                    if (all != null) Interlocked.Add(ref all.ProgressValue, 1);
                }
                else
                {
                    node.nodes = new Dictionary<int, DRE_GENERATOR>();
                    for (int i = cidx; i < g_alleles.Length; ++i)
                    {
                        c_alleles[clay] = g_alleles[i];
                        node.nodes[c_alleles[clay]] = new DRE_GENERATOR();
                        node.sumprob += GeneratorSub(clay + 1, max, i, node.nodes[c_alleles[clay]], alpha, f, g_alleles, c_alleles);
                    }
                    for (int i = cidx; i < g_alleles.Length; ++i)
                    {
                        var t = node.nodes[g_alleles[i]];
                        t.sumprob /= node.sumprob;
                    }
                }
                return node.sumprob;
            }

            public int GetRandomAllele(Random rnd)
            {
                if (freq.Count == 0)
                    return -999;
                double t = rnd.NextDouble();
                int kbak = 0;
                foreach (int k in freq.Keys)
                    if (t < freq[k])
                        return k;
                    else
                    {
                        kbak = k;
                        t -= freq[k];
                    }
                return kbak;
            }

            public PHENOTYPE CreatePhenotype(Random rnd, int ploidy, int l)
            {
                //founder simulation and parentage simulation
                //get genotype
                int[] als = new int[ploidy];

                if (root == null || root.nodes == null) //HWE mode
                    for (int i = 0; i < ploidy; ++i)
                        als[i] = GetRandomAllele(rnd);
                else
                {
                    //DRE mode
                    DRE_GENERATOR node = root;
                    for (int i = 0; i < ploidy; ++i)
                    {
                        double mode = rnd.NextDouble();
                        foreach (var a in node.nodes)
                        {
                            if (mode < a.Value.sumprob)
                            {
                                als[i] = a.Key;
                                node = a.Value;
                                break;
                            }
                            else
                                mode -= a.Value.sumprob;
                        }
                    }
                }

                return new PHENOTYPE(ploidy, als, false);
            }

            public void Unite(SUBPOP[] subpops, int l)
            {
                freq = CloneKey(subpops[0].loc[l].freq);
                foreach (SUBPOP tp in subpops)
                {
                    beta += tp.loc[l].beta * tp.loc[l].nhaplotypes;
                    s += tp.loc[l].beta * tp.loc[l].nhaplotypes;
                    AddMul(freq, tp.loc[l].freq, tp.loc[l].nhaplotypes);
                }
                beta /= nhaplotypes;
                s /= nhaplotypes;
                Unify(freq);
            }
        }

        public class HAPLOTYPE
        {
            //public int[] id;
            public IND ind;
            public Dictionary<int, double>[] allele;

            public HAPLOTYPE()
            {

            }

            public HAPLOTYPE(HAPLOTYPE r)
            {
                //id = Clone(r.id);
                allele = r.allele;
                ind = r.ind;
            }

        }

        public class SUBPOP
        {
            public POP parent;
            public string name;
            public LOC[] loc = null;
            public IND[] inds = null;
            public Dictionary<uint, PHENOTYPE>[] phenotype;
            public SUBPOP region;
            public SUBPOP[] subpops = null;
            public int ploidy;
            public int nhaplotypes = 0;
            public int id;
            public int n;
            public int L;
            public double SS1 = 0, SS2 = 0;
            public double s;//used in Hardy's selfing rate estimator
            public double[] Msl;
            public double[] coordinate;

            public SUBPOP(POP _parent)
            {
                parent = _parent;
                coordinate = new double[_parent.ncoordinate];
            }

            public SUBPOP(int _id, string _name, int _L)
            {
                id = _id;
                name = _name;
                L = _L;
            }

            public void RearrangeInds(List<IND> inds2)
            {
                if (subpops != null && subpops.Length > 0)
                    foreach (SUBPOP s in subpops)
                        s.RearrangeInds(inds2);
                else
                    inds2.AddRange(inds);
            }

            public double GetRegionHomozygosity(int lay, int l, ref double weight)
            {
                if (lay == 0)
                {
                    double tw2 = loc[l].nhaplotypes;
                    weight += tw2;
                    return tw2 / loc[l].AE;
                }

                double re = 0;
                foreach (SUBPOP tr in subpops)
                    re += tr.GetRegionHomozygosity(lay - 1, l, ref weight);
                return re;
            }

            public static Dictionary<int, double> UniteFrequency(SUBPOP[] subpops, int l, ref int vt)
            {
                Dictionary<int, double> allele = CloneKey(subpops[0].loc[l].freq);
                vt = 0;
                foreach (SUBPOP tp in subpops)
                {
                    AddMul(allele, tp.loc[l].freq, tp.loc[l].nhaplotypes);
                    vt += tp.loc[l].nhaplotypes;
                }
                Unify(allele);
                return allele;
            }

            public void GetMsl()
            {
                double[] Pslk2 = new double[L];

                for (int l = 0; l < L; ++l)
                    Pslk2[l] = SumSquare(loc[l].freq);

                Msl = POP.M_Nomura2008(NRRATE, Pslk2, inds, 1, null);//necessary
            }

            public double s2f(double s, int v, int l)
            {
                double lambda = all.LAMBDA[l, v];
                return (8 * lambda + s * v) / (8 * lambda + v * (s + v - s * v));
            }

            double f2s(double f, int v, int l)
            {
                double lambda = all.LAMBDA[l, v];
                return (8 * f * lambda + f * v * v - 8 * lambda) / (v * (1 - f + f * v));
            }

            public double PFZ(PHENOTYPE ph, int l)
            {
                return CONSIDER_SELFING ?
                    ph.PFZ(ISGENOTYPE, loc[l].freq, s2f(loc[l].s, ph.ploidy, l), loc[l].beta) :
                    ph.PFZ(ISGENOTYPE, loc[l].freq, all.ALPHA[l, ph.ploidy], loc[l].beta);
            }

            public void GetGenoPoster(PHENOTYPE ph, int l)
            {
                //calculate the poster and priori probability of hidden genotypes
                if (ph.prob == -1) lock (ph)
                {
                    if (ph.prob == -1)
                    {
                        double spr = 0;

                        ph.freq = new /*Concurrent*/Dictionary<int, double>();
                        foreach (int a in ph.alleles)
                            ph.freq[a] = 0;

                        if (CONSIDER_NULL && ph.alleles.Length < ph.ploidy)
                            ph.freq[NULL_ALLELE] = 0;

                        foreach (GENOTYPE gh in ph.genotypes)
                        {
                            gh.prior = CONSIDER_SELFING ?
                                gh.GFZ(loc[l].freq, s2f(loc[l].s, ph.ploidy, l)) :
                                gh.GFZ(loc[l].freq, all.ALPHA[l, ph.ploidy]);
                            spr += gh.prior;
                        }

                        ph.prob = spr * (1 - loc[l].beta) + (ph.hash == 0 ? loc[l].beta : 0);
                        if (CONSIDER_NULL && CONSIDER_NEGATIVE)
                            spr = ph.prob / (1 - loc[l].beta);

                        for (int i = 0; i < ph.genotypes.Length; ++i)
                        {
                            GENOTYPE gh = ph.genotypes[i];
                            gh.poster = gh.prior / spr;
                            foreach (var x in gh.alleles)
                                ph.freq[x.Key] += gh.poster * x.Value / ph.ploidy;
                        }

                        if (CONSIDER_NULL && CONSIDER_NEGATIVE && ph.hash == 0)
                        {
                            double w1 = ph.genotypes[0].poster, w2 = 1 - w1;
                            foreach (var kv in loc[l].freq)
                                ph.freq[kv.Key] = kv.Value * w2;
                            ph.freq[NULL_ALLELE] += w1;
                        }
                    }
                }
            }

            public double EMSub(int l)
            {
                //em algorithm for population p, locus l, return phenotypic likelihood
                double s = loc[l].s, f = s2f(s, ploidy, l);
                double beta1 = CONSIDER_NEGATIVE ? 0.05 : 0, beta2 = 0, lnLPheno = 0;

                Dictionary<int, double> fre1 = loc[l].freq, fre2 = Clone(fre1);
                var keys = fre1.Keys.ToArray();
                var alpha = all.ALPHA[l, ploidy];
                foreach (int a in keys)
                    fre1[a] = 1.0 / keys.Length;

                for (int count = 0; count < MAX_EMITER; ++count)
                {
                    //double lnL = 0;
                    foreach (int a in keys)
                    {
                        fre2[a] = fre1[a];
                        fre1[a] = MINALLELEFREQSQ;
                    }
                    beta2 = beta1;
                    beta1 = 0;

                    double scountneg = 0;
                    foreach (PHENOTYPE ph in phenotype[l].Values)
                    {
                        if (ph.count == 0) continue;
                        scountneg += ph.count;
                        if (ph.hash == 0 && !CONSIDER_NEGATIVE && !CONSIDER_NULL) continue;

                        double spr = 0;
                        foreach (GENOTYPE gh in ph.genotypes)
                        {
                            gh.prior = CONSIDER_SELFING ? gh.GFZ(fre2, f) : gh.GFZ(fre2, alpha);
                            spr += gh.prior;
                        }

                        ph.prob = spr = (ph.hash == 0 ? beta2 : 0) + (1 - beta2) * spr;

                        if (ph.hash == 0 && CONSIDER_NEGATIVE && beta2 > 0)
                            beta1 = ph.count * beta2 / spr;

                        if (spr < MINALLELEFREQ) continue;

                        double invspr = (1 - beta2) * ph.count / spr;
                        foreach (GENOTYPE gh in ph.genotypes)
                        {
                            double ci = gh.prior * invspr;
                            foreach (int a in gh.alleles.Keys)
                                fre1[a] += ci * gh.alleles[a] + MINALLELEFREQSQ;
                        }
                    }
                    beta1 /= scountneg;
                    Unify(fre1);

                    double maxdiff = 0;
                    foreach (int a in keys)
                    {
                        double diff = Math.Abs(fre2[a] - fre1[a]);
                        if (diff > maxdiff)
                            maxdiff = diff;
                    }
                    if (maxdiff < MAX_EMDIFF || count == MAX_EMITER - 1)
                    {
                        foreach (PHENOTYPE ph in phenotype[l].Values)
                        {
                            if (ph.hash == 0 && !CONSIDER_NEGATIVE && !CONSIDER_NULL) continue;
                            if (ph.prob > MINALLELEFREQSQ) lnLPheno += ph.count * Math.Log(ph.prob);
                            ph.prob = -1;
                        }
                        break;
                    }
                }

                loc[l].beta = beta1;
                return lnLPheno;
            }

            public double HardySelfingEstimator()
            {
                double re = 0;
                if (SELFING_ESTIMATOR == SelfingRateEstimator.HardyFz)
                {
                    // f global
                    double alpha = 0, f1 = 0, f2 = 0;
                    for (int l = 0; l < L; ++l)
                    {
                        if (loc[l].nphenotypes <= 1) continue;

                        double he = 1.0, hil = 0, nv = 0;//expected heterozygosity, sum of observed heterozygosity across inds, number of visible phenotypes
                        Dictionary<int, double> fre = CloneKey(loc[l].freq); //allele frequency vector
                        foreach (int a in loc[l].freq.Keys) fre[a] = 0; //initialize 
                        if (ploidy >= 4 && ploidy % 2 == 0)
                            for (int i = 1; i <= (ploidy >> 2); ++i)
                                alpha += all.ALPHA[l, ploidy][i] * i; //number of IBDR alleles in gamete

                        foreach (PHENOTYPE ph in phenotype[l].Values)
                        {
                            if (ph.count == 0 || ph.hash == 0) continue;
                            nv += ph.count; //number of visible phenotype
                            double na = ph.count / ph.alleles.Length;
                            foreach (int a in ph.alleles)
                                fre[a] += na; // summing allele copies
                            hil += ph.GetHardyHidx(ploidy) * ph.count; //suming observed heterozygosity
                        }

                        Unify(fre);
                        foreach (double af in fre.Values)
                            he -= af * af;

                        f1 += hil;
                        f2 += nv * nv / (nv - 1) * (he - (ploidy - 1) / (ploidy * nv * nv) * hil);// Hardy (2016) eqn 10
                    }
                    if (f1 == 0 && f2 == 0)
                        re = 0;
                    else
                    {
                        double f = 1.0 - f1 / f2; // Hardy (2016) eqn 10
                        alpha /= L; //averaging alpha
                        alpha /= (ploidy / 2) * (ploidy / 2 - 1) / 2; //convert to Hardy's double-reduction rate, the probability of sampling two IBDR alleles in gamete without replacement
                        if (ploidy < 4 || ploidy % 2 == 1) alpha = 0;//prevent underflow
                        if (f < 1e-10) f = 1e-10;//prevent underflow
                        re = (ploidy * f - (ploidy - 2) * (1 - f) * alpha) / (1 + (ploidy - 1) * f);// Hardy (2016) eqn 15
                        if (re < 1e-10) re = 1e-10;
                    }
                }
                else if (SELFING_ESTIMATOR == SelfingRateEstimator.Hardyg2z)
                {
                    //g2z global
                    double[] M = new double[L];//num of inds with missing data
                    double[,] MM = new double[L, L];//num of inds with missing data at both loci
                    for (int l = 0; l < L; ++l)
                        M[l] = inds.Count(i => i.g[l].hash == 0);
                    for (int l1 = 0; l1 < L; ++l1)
                        for (int l2 = l1 + 1; l2 < L; ++l2)
                            MM[l1, l2] = MM[l2, l1] = inds.Count(i => i.g[l1].hash == 0 && i.g[l2].hash == 0);

                    double n = inds.Length;//number of individuals in this ploidy

                    double g1 = 0, g2 = 0, alpha = 0;
                    for (int l1 = 0; l1 < L; ++l1)
                    {
                        if (loc[l1].nphenotypes <= 1) continue;
                        if (ploidy >= 4 && ploidy % 2 == 0)
                            for (int i = 1; i <= (ploidy >> 2); ++i)
                                alpha += all.ALPHA[l1, ploidy][i] * i;

                        for (int l2 = 0; l2 < l1; ++l2)
                        {
                            if (l1 == l2 || loc[l2].nphenotypes <= 1) continue;
                            double hlm = 0, hl = 0, hm = 0;
                            for (int i = 0; i < n; ++i)
                            {
                                double h1 = inds[i].g[l1].GetHardyHidx(ploidy);
                                double h2 = inds[i].g[l2].GetHardyHidx(ploidy);

                                hl += h1;
                                hm += h2;
                                hlm += h1 * h2;
                            }

                            g1 += hlm;
                            g2 += (n - M[l1] - M[l2] + MM[l1, l2]) /
                                  ((n - 1) * (n - M[l1] - M[l2]) + M[l1] * M[l2] - MM[l1, l2]) *
                                  (hl * hm - hlm);//Hardy (2016) eqn 14
                        }
                    }

                    if (g1 == 0 && g2 == 0)
                        re = 0;
                    else
                    {
                        double g = g1 / g2 - 1; //Hardy (2016) eqn 14
                        alpha /= L; //alpha is the number of IBDR allele pairs within genotype
                        alpha /= (ploidy / 2) * (ploidy / 2 - 1) / 2;//convert to Hardy's double-reduction rate
                        if (ploidy < 4 || ploidy % 2 == 1) alpha = 0;//prevent underflow
                        if (g < 1e-10) g = 1e-10;//prevent underflow

                        double X = 1 + 2 * alpha * (ploidy - 2) + alpha * alpha * (ploidy - 2) * (ploidy - 2) + g * (9 - 16 * ploidy + 7 * ploidy * ploidy - 2 * alpha * (2 - 3 * ploidy + ploidy * ploidy));
                        double Y = g * (14 - 20 * ploidy + 7 * ploidy * ploidy - 2 * alpha * (8 - 10 * ploidy + 3 * ploidy * ploidy) + alpha * alpha * (ploidy - 2) * (ploidy - 2));
                        double Z = g * (4 - 12 * ploidy + 7 * ploidy * ploidy + (2 * alpha - alpha * alpha) * (ploidy - 2) * (ploidy - 2));

                        re = (X - Math.Sqrt(X * X - Y * Z)) / Y;//Hardy (2016) eqn 16
                        if (re < 1e-10) re = 1e-10;
                    }
                }
                return re;
            }

            public double Likelihood(int l)
            {
                double lnL = 0;

                if (subpops != null && subpops.Length > 0)
                    foreach (SUBPOP p in subpops)
                        lnL += p.Likelihood(l);
                else foreach (PHENOTYPE ph in phenotype[l].Values)
                    lnL += ph.count * (ph.prob > 0 ? Math.Log(ph.prob) : 0);

                return lnL;
            }

            private class COLLAPSE
            {
                //allele class to collapse
                public List<int> alleles;
                public double sumfre;

                public COLLAPSE(int allele, double f)
                {
                    alleles = new List<int>();
                    alleles.Add(allele);
                    sumfre = f;
                }

                public COLLAPSE(COLLAPSE a, COLLAPSE b)
                {
                    alleles = new List<int>();
                    alleles.AddRange(a.alleles);
                    alleles.AddRange(b.alleles);
                    sumfre = a.sumfre + b.sumfre;
                }

            }

            private bool CollapseGeno(int l, List<COLLAPSE> cls, Dictionary<int, int> amap, object obj)
            {
                if (cls == null)
                {
                    var alleles = (from i in inds from a in i.g[l].alleles select a).Distinct();
                    cls = new List<COLLAPSE>();
                    amap = new Dictionary<int, int>();
                    foreach (int a in alleles)
                    {
                        cls.Add(new COLLAPSE(a, loc[l].freq[a]));
                        amap[a] = a;
                    }
                    cls = cls.OrderBy(c => c.sumfre).ToList();
                }

                bool flag = true;
                if (cls.Count > 2)
                {
                    List<COLLAPSE> ncls = new List<COLLAPSE>();
                    Dictionary<int, int> namap = Clone(amap);
                    ncls.AddRange(cls);
                    ncls.RemoveRange(0, 2);
                    ncls.Add(new COLLAPSE(cls[0], cls[1]));
                    int nid = 0x100 + ncls.Count;
                    foreach (int a in cls[0].alleles) namap[a] = nid;
                    foreach (int a in cls[1].alleles) namap[a] = nid;
                    ncls = ncls.OrderBy(c => c.sumfre).ToList();
                    flag = CollapseGeno(l, ncls, namap, obj);
                }

                int[] Valid = (int[])((object[])obj)[2];
                double[] df = (double[])((object[])obj)[3];
                double[] g = (double[])((object[])obj)[4];
                double[] pval = (double[])((object[])obj)[5];

                if (flag)
                {
                    // collapse to k-1 success, try this
                    //g[l], df[l], pval[l] needs to calculate

                    double g2 = 0;
                    int[] als = new int[ploidy];
                    Dictionary<uint, double> obs = new Dictionary<uint, double>(), exp = new Dictionary<uint, double>();
                    Dictionary<int, double> tfreq = loc[l].GetMappingFreq(amap);

                    foreach (PHENOTYPE gh in phenotype[l].Values)
                    {
                        if (gh.hash == 0) continue;
                        for (int a = 0; a < ploidy; ++a)
                            als[a] = amap[gh.alleles[a]];

                        GENOBODY gb = new GENOBODY(als);
                        uint ha = gb.hash;
                        if (!obs.ContainsKey(ha))
                        {
                            obs[ha] = 0;
                            exp[ha] = CONSIDER_SELFING ? 
                                      gb.GFZ(tfreq, s2f(loc[l].s, ploidy, l)) : 
                                      gb.GFZ(tfreq, all.ALPHA[l, ploidy]);
                        }

                        obs[ha] += gh.count;
                    }
                    Mul(exp, exp, Valid[l]);

                    foreach (uint ha in obs.Keys)
                    {
                        if (ha == 0) continue;//bug fixed @ 20200731, don't count empty phenotypes

                        if (exp[ha] < 5)
                            return false;
                        if (obs[ha] > 0)
                            g2 += 2 * obs[ha] * Math.Log(obs[ha] / exp[ha]);
                    }

                    pval[l] = 1 - ChiSquareDistCDF(g[l] = g2, df[l] = BINOMIAL[ploidy + cls.Count - 1, ploidy] - cls.Count);

                    return true;
                }
                else
                {
                    // collapse to k-1 fail, don't try
                    g[l] = pval[l] = double.NaN;
                    return false;
                }
            }

            private bool CollapsePheno(int l, List<COLLAPSE> cls, Dictionary<int, int> amap, object obj)
            {
                if (cls == null)
                {
                    var alleles = (from i in inds from a in i.g[l].alleles select a).Distinct();
                    cls = new List<COLLAPSE>();
                    amap = new Dictionary<int, int>();
                    foreach (int a in alleles)
                    {
                        cls.Add(new COLLAPSE(a, loc[l].freq[a]));
                        amap[a] = a;
                    }
                }

                bool flag = true;
                if (cls.Count > 2)
                {
                    List<COLLAPSE> ncls = new List<COLLAPSE>();
                    Dictionary<int, int> namap = Clone(amap);
                    ncls.AddRange(cls);
                    ncls.RemoveRange(0, 2);
                    ncls.Add(new COLLAPSE(cls[0], cls[1]));
                    int nid = 0x100 + ncls.Count;
                    foreach (int a in cls[0].alleles) namap[a] = nid;
                    foreach (int a in cls[1].alleles) namap[a] = nid;
                    ncls = ncls.OrderBy(c => c.sumfre).ToList();
                    flag = CollapsePheno(l, ncls, namap, obj);
                }

                if (flag)
                {
                    // collapse to k-1 success, try this
                    //g[l], df[l], pval[l] needs to calculate

                    int[] Valid = (int[])((object[])obj)[2];
                    double[] df = (double[])((object[])obj)[3];
                    double[] g = (double[])((object[])obj)[4];
                    double[] pval = (double[])((object[])obj)[5];

                    double g2 = 0;
                    int[] als = new int[ploidy];
                    Dictionary<uint, double> obs = new Dictionary<uint, double>(), exp = new Dictionary<uint, double>();
                    Dictionary<int, double> tfreq = loc[l].GetMappingFreq(amap);

                    foreach (PHENOTYPE gh in phenotype[l].Values)
                    {
                        if (gh.hash == 0) continue;
                        PHENOBODY pb = new PHENOBODY(ploidy, gh.alleles.Select(a => amap[a]).Distinct().ToArray(), false);
                        uint ha = pb.hash;
                        if (!obs.ContainsKey(ha))
                        {
                            obs[ha] = 0;
                            PHENOTYPE pt = new PHENOTYPE(pb);
                            if (CONSIDER_SELFING)
                            {
                                pt.GetGenotypes();
                                exp[ha] = pt.PFZ(false, tfreq, s2f(loc[l].s, ploidy, l), 0);
                            }
                            else
                                exp[ha] = pt.PFZ(false, tfreq, all.ALPHA[l, ploidy], 0);
                        }

                        obs[ha] += gh.count;
                    }
                    Mul(exp, exp, Valid[l]);

                    foreach (uint ha in obs.Keys)
                    {
                        if (ha == 0) continue;//bug fixed @ 20200731, don't count empty phenotypes

                        if (exp[ha] < 5)
                            return false;
                        if (obs[ha] > 0)
                            g2 += 2 * obs[ha] * Math.Log(obs[ha] / exp[ha]);
                    }

                    pval[l] = 1 - ChiSquareDistCDF(g[l] = g2, df[l] = BINOMIAL[ploidy + cls.Count - 1, ploidy] - cls.Count);

                    return true;
                }
                else
                {
                    // collapse to k-1 fail, don't try
                    return false;
                }
            }


            private void EnumPhenotypes(int l, int lay, int id, int[] tals, List<int> als, double[] obs, double[] exp, ref int op)
            {
                if (lay == 0 && (CONSIDER_NULL || CONSIDER_NEGATIVE) || lay > 0)
                {
                    PHENOTYPE ph = new PHENOTYPE(new PHENOBODY(ploidy, als.ToArray(), false));
                    if (phenotype[l].ContainsKey(ph.hash))
                    {
                        ph = phenotype[l][ph.hash];
                        obs[op] = ph.count;
                        exp[op] = ph.prob;
                    }
                    else if (CONSIDER_SELFING)
                    {
                        ph.GetGenotypes();
                        exp[op] = ph.PFZ(false, loc[l].freq, s2f(loc[l].s, ploidy, l), 0);
                    }
                    else
                        exp[op] = ph.PFZ(false, loc[l].freq, all.ALPHA[l, ploidy], 0);
                    op++;
                }

                if (lay >= ploidy || lay >= loc[l].freq.Count - (CONSIDER_NULL ? 1 : 0))
                    return;

                als.Add(-1);
                for (int i = id; i < tals.Length; ++i)
                {
                    als[lay] = tals[i];
                    EnumPhenotypes(l, lay + 1, i + 1, tals, als, obs, exp, ref op);
                }
                als.RemoveAt(lay);
            }

            public void DistributionTestThread(object obj)
            {
                //for subpop
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                int[] Valid = (int[])((object[])obj)[2];
                double[] df = (double[])((object[])obj)[3];
                double[] g = (double[])((object[])obj)[4];
                double[] pval = (double[])((object[])obj)[5];
                double[] li = (double[])((object[])obj)[6];
                double[] npar = (double[])((object[])obj)[7];
                double[] aicc = (double[])((object[])obj)[8];
                double[] bic = (double[])((object[])obj)[9];

                for (int l = 0; l < L; ++l)
                {
                    if (l % nthreads != id) continue;

                    Valid[l] = loc[l].nphenotypes;
                    if (!f1.MODEL_TEST)
                    {
                        if (ISGENOTYPE)//OK
                            CollapseGeno(l, null, null, obj);
                        else
                            //CollapsePheno(l, null, null, obj);
                        //if (false)
                        {

                            int op = 0;
                            int npheno = (CONSIDER_NULL || CONSIDER_NEGATIVE ? 1 : 0) + (int)PHENO_COUNT[ploidy, loc[l].freq.Count - (CONSIDER_NULL || CONSIDER_NEGATIVE ? 1 : 0)];
                            double[] obs = new double[npheno], exp = new double[npheno];
                            EnumPhenotypes(l, 0, 0, loc[l].freq.Keys.Where(o => o != NULL_ALLELE).ToArray(), new List<int>(), obs, exp, ref op);

                            /*
                            foreach (PHENOTYPE ph in phenotype[l].Values)
                            {
                                if (CONSIDER_NULL || CONSIDER_NEGATIVE || ph.hash != 0)
                                {
                                    obs[op] = ph.count;
                                    exp[op] = ph.prob;
                                    op++;
                                }
                            }
                            Array.Resize(ref obs, op);
                            Array.Resize(ref exp, op);
                            */

                            Mul(exp, exp, Valid[l]);

                            CombineTable(ref obs, ref exp, ref df[l], ref g[l], ref pval[l]);//OK
                            df[l] = obs.Length - 1;
                        }
                    }

                    li[l] = Likelihood(l);//OK
                    npar[l] = loc[l].freq.Count(f => f.Value > MINALLELEFREQ && f.Key != NULL_ALLELE) - 1 +
                           (CONSIDER_SELFING ? 1 : 0) +
                           (CONSIDER_NEGATIVE ? 1 : 0) +
                           (CONSIDER_NULL ? 1 : 0) +
                           (DR_MODE == DoubleReductionModel.PESRS ? 1 : 0);
                    aicc[l] = 2 * npar[l] - 2 * li[l] + 2 * npar[l] * (npar[l] + 1) / (Valid[l] - npar[l] - 1);
                    bic[l] = -2 * li[l] + npar[l] * Math.Log(Valid[l]);
                    all.Increment();
                }
            }

            public double DistributionTest(StreamWriter wt, ref double nvalid)
            {
                //Single Pop, In Equilibrium test
                int[] Valid = new int[L];
                double[] df = new double[L];
                double[] pval = new double[L];
                double[] g = new double[L];
                double[] li = new double[L];
                double[] npar = new double[L]; //n pars
                double[] aicc = new double[L];
                double[] bic = new double[L];

                CallThread(DistributionTestThread, N_THREAD,
                           new object[] { Valid, df, g, pval, li, npar, aicc, bic },
                all.ProgressValue + L, ref all.ProgressValue);

                double[] qval2 = FDRCorrection(pval);

                for (int l = 0; l < L; ++l)
                {
                    wt.Write(name);
                    wt.Write("\t" + loc[l].name);
                    wt.Write("\t" + g[l].ToString(DECIMAL));
                    wt.Write("\t" + df[l].ToString("F0"));
                    wt.Write("\t" + pval[l].ToString(DECIMAL));
                    wt.Write("\t" + qval2[l].ToString(DECIMAL));
                    wt.Write("\t" + Valid[l]);
                    wt.Write("\t" + npar[l]);
                    wt.Write("\t" + li[l].ToString(DECIMAL));
                    wt.Write("\t" + aicc[l].ToString(DECIMAL));
                    wt.Write("\t" + bic[l].ToString(DECIMAL));
                    wt.Write("\r\n");
                }

                nvalid += Valid.Sum();
                return li.Sum();
            }

            public void SubpopNe(int nthreads, StreamWriter wt)
            {
                int N = inds.Length, L = inds[0].g.Length, v = ploidy;
                wt.Write("\r\n" + name +
                    "\t" + v.ToString(DECIMAL) +
                    "\t" + N +
                    "\t" + L);

                if (NE_PUDOVKIN2009)
                {
                    double[] Ho = new double[L], He = new double[L];
                    Parallel.For(0, L, new ParallelOptions() { MaxDegreeOfParallelism = nthreads }, l =>
                    //for (int l = 0; l < L; ++l)
                    {
                        Dictionary<int, double> freq = loc[l].freq, ho2 = CloneKey(freq);

                        foreach (PHENOTYPE ph in phenotype[l].Values)
                        {
                            if (ph.hash == 0) continue;

                            foreach (GENOTYPE gh in ph.genotypes)
                                gh.GetHoDiallelic(ph.count * gh.poster, ho2);
                        }

                        int npheno = loc[l].nphenotypes, nhaplo = loc[l].nhaplotypes;
                        int ndyad = npheno * v * (v - 1) / 2;

                        double ho = 0, he = 0;
                        foreach (var af in freq)
                        {
                            ho += ho2[af.Key] / ndyad;
                            he += 2 * af.Value * (1 - af.Value) * nhaplo / (nhaplo - 1); //Pudovkin 2009
                        }
                        Ho[l] = ho;
                        He[l] = he;

                        parent.Increment();
                    });

                    //Jackknife
                    double Sho = Ho.Sum(), She = He.Sum();
                    double exne = 0, ex2ne = 0;
                    double exivne = 0, ex2ivne = 0;
                    for (int l = 0; l < L; ++l)
                    {
                        double De = (Sho - Ho[l]) / (She - He[l]);
                        double net = CalcPudovkinNe(v, De);
                        exne += net;
                        ex2ne += net * net;

                        exivne += 1.0 / (v * net);
                        ex2ivne += 1.0 / (v * net);
                    }

                    exne /= L; ex2ne /= L;
                    exivne /= L; ex2ivne /= L;

                    double SEne = Math.Sqrt((ex2ne - exne * exne) * (L - 1));
                    double SEivne = Math.Sqrt((ex2ivne - exivne * exivne) * (L - 1));

                    double Dm = Sho / She - 1;
                    double NePudovkin = CalcPudovkinNe(v, Dm);
                    double NePudovkinlow = NePudovkin - 1.96 * SEne;
                    double NePudovkinhigh = NePudovkin + 1.96 * SEne;

                    wt.Write(
                        "\t" + Dm.ToString(DECIMAL) +
                        "\t" + NePudovkin.ToString(DECIMAL) +
                        "\t" + SEne.ToString(DECIMAL) +
                        "\t" + NePudovkinlow.ToString(DECIMAL) +
                        "~" + NePudovkinhigh.ToString(DECIMAL) +
                        "\t" + SEivne.ToString(DECIMAL));
                }

                if (NE_NOMURA2008)
                {
                    double Nt = inds.Sum(i => i.ploidy), SNs2 = inds.Sum(i => i.ploidy * i.ploidy), av = SNs2 / Nt;
                    double[,] sxy = new double[N, N];
                    double[] Pxlk2 = new double[L], Pslk2 = new double[L];

                    Parallel.For(0, L, new ParallelOptions() { MaxDegreeOfParallelism = nthreads }, l =>
                    //for (int l = 0; l < L; ++l)
                    {
                        Pxlk2[l] = phenotype[l].Values.Sum(p => p.hash == 0 ? 0 : (p.count * p.genotypes.Sum(g => g.poster * g.GetPxlk2()))) / loc[l].nphenotypes;
                        Pslk2[l] = SumSquare(loc[l].freq);
                        parent.Increment();
                    });

                    double Smsl = 0, SPxlk2 = 0, SPslk2 = 0;
                    int cl = 0;

                    //Msl = POP.M_Nomura2008(NRRATE, Pslk2, inds, nthreads, parent);//necessary

                    for (int l = 0; l < L; ++l)
                    {
                        if (Pslk2[l] == 1) continue;

                        cl++;
                        SPxlk2 += Pxlk2[l];
                        SPslk2 += Pslk2[l];
                        Smsl += Msl[l];

                        parent.Increment();
                    }

                    //Jackknife
                    double exne = 0, ex2ne = 0;
                    double exivne = 0, ex2ivne = 0;
                    for (int l = 0; l < L; ++l)
                    {
                        if (Pslk2[l] != 1)
                        {
                            double sPxlk2 = SPxlk2 - Pxlk2[l], sPslk2 = SPslk2 - Pslk2[l], msl = Smsl - Msl[l];
                            double tsl = (sPslk2 - msl) / (cl - 1 - msl);
                            double txl = (sPxlk2 - msl) / (cl - 1 - msl);
                            double txxl = (N * tsl - txl) / (N - 1);

                            double net = 1.0 / (v * txxl);
                            double fisl = (v * txl - 1) / (v - 1);

                            exne += net;
                            ex2ne += net * net;

                            exivne += 1.0 / (v * net);
                            ex2ivne += 1.0 / (v * net);
                        }
                    }

                    exne /= cl; ex2ne /= cl;
                    exivne /= cl; ex2ivne /= cl;

                    double SEne = Math.Sqrt((ex2ne - exne * exne) * (cl - 1));
                    double SEivne = Math.Sqrt((ex2ivne - exivne * exivne) * (cl - 1));

                    double tx = (SPxlk2 - Smsl) / (cl - Smsl);
                    double ts = (SPslk2 - Smsl) / (cl - Smsl);
                    double txx = (N * ts - tx) / (N - 1);
                    double fis = (v * tx - 1) / (v - 1);

                    double NeNomura = 1.0 / (v * txx);
                    double NeNomuralow = NeNomura - 1.96 * SEne;
                    double NeNomurahigh = NeNomura + 1.96 * SEne;

                    wt.Write(
                        "\t" + txx.ToString(DECIMAL) +
                        "\t" + NeNomura.ToString(DECIMAL) +
                        "\t" + SEne.ToString(DECIMAL) +
                        "\t" + NeNomuralow.ToString(DECIMAL) +
                        "~" + NeNomurahigh.ToString(DECIMAL) +
                        "\t" + SEivne.ToString(DECIMAL));
                }

                if (NE_WAPLES2010)
                {
                    double Dr2a = 0, Dr2b = 0;
                    double[] Dr2aArr = new double[L], Dr2bArr = new double[L];
                    double[,] obs = null;
                    Parallel.For(0, L, new ParallelOptions() { MaxDegreeOfParallelism = nthreads }, l1 =>
                    //for (int l1 = 0; l1 < L; ++l1)
                    {
                        double dr2a = 0, dr2b = 0, df = 0;
                        for (int l2 = l1 + 1; l2 < L; ++l2)
                        {
                            double dr2ax = 0, dr2bx = 0;
                            POP.BurrowDelta(false, ref obs, ref obs, ref dr2ax, ref dr2bx, ref df, inds, this, l1, l2);
                            Dr2aArr[l1] += dr2ax; Dr2aArr[l2] += dr2ax;
                            Dr2bArr[l1] += dr2bx; Dr2bArr[l2] += dr2bx;
                            dr2a += dr2ax; dr2b += dr2bx;
                            parent.Increment();
                        }

                        lock (this)
                        {
                            Dr2a += dr2a;
                            Dr2b += dr2b;
                        }
                    });

                    double r2d = Dr2a / Dr2b;

                    //Jackknife
                    double exne = 0, ex2ne = 0;
                    double exivne = 0, ex2ivne = 0;
                    for (int l = 0; l < L; ++l)
                    {
                        double r2dt = (Dr2a - Dr2aArr[l]) / (Dr2b - Dr2bArr[l]);
                        double net = CalcWaplesNe(v, r2dt, N, NE_WAPLES_F, NE_WAPLES_MS);
                        exne += net;
                        ex2ne += net * net;

                        exivne += 1.0 / (v * net);
                        ex2ivne += 1.0 / (v * net);
                    }

                    exne /= L; ex2ne /= L;
                    exivne /= L; ex2ivne /= L;

                    double SEne = Math.Sqrt((ex2ne - exne * exne) * (L - 1));
                    double SEivne = Math.Sqrt((ex2ivne - exivne * exivne) * (L - 1));
                    double NeWaples = CalcWaplesNe(v, r2d, N, NE_WAPLES_F, NE_WAPLES_MS);
                    double NeWapleslow = NeWaples - 1.96 * SEne;
                    double NeWapleshigh = NeWaples + 1.96 * SEne;

                    wt.Write(
                        "\t" + r2d.ToString(DECIMAL) +
                        "\t" + NeWaples.ToString(DECIMAL) +
                        "\t" + SEne.ToString(DECIMAL) +
                        "\t" + NeWapleslow.ToString(DECIMAL) +
                        "~" + NeWapleshigh.ToString(DECIMAL) +
                        "\t" + SEivne.ToString(DECIMAL));
                }
            }

            public double CalcPudovkinNe(double v, double D)
            {
                if (v == 2)
                    return 1.0 / (2 * D) + 1.0 / (2 * D + 2);
                else if (v % 2 == 0 && v > 2)
                    return (1 + D) / (D * v);
                else return double.NaN;
            }

            public double CalcWaplesNe(double v, double r2d, double n, double f, WaplesMatingSystem MS)
            {
                //Approx method, fix finite sample size on 2021/4/14 from 1/n to 1/(n-1)
                if (MS == WaplesMatingSystem.HS) 
                    return 1.0 / (3.0 * (r2d - 1.0 / (n - 1)) * (v - 1.0)) + 0;
                if (MS == WaplesMatingSystem.MS)
                    return 1.0 / (3.0 * (r2d - 1.0 / (n - 1))) + (2.0 * (v - 2.0) * (v - 1.0)) / (v * v);
                if (MS == WaplesMatingSystem.ME || MS == WaplesMatingSystem.DR)
                    return 1.0 / (3.0 * (r2d - 1.0 / (n - 1))) + (4.0 * (v - 1.0) * (v - 1.0)) / (v * v);
                if (MS == WaplesMatingSystem.DH)
                    return (3.0 + f) / (3.0 * (1.0 + f) * (r2d - 1.0 / (n - 1))) + (4.0 * (v - 1.0) * (v - 1.0)) / (v * v);
                return -999;
            }

            public void CalcFreq(Dictionary<int, double> allele, int l, ref int ns)
            {
                ns = 0;
                foreach (IND ind in inds)
                {
                    PHENOTYPE p = ind.g[l];
                    if (p.hash == 0) continue;
                    ns += p.ploidy;
                    foreach (int a in p.alleles)
                        allele[a]++;
                }
                Mul(allele, allele, 1.0 / ns);
            }

            public static double HaldaneMappingFunction(double d)
            {
                return 0.5 * (1 - Math.Exp(-0.02 * d));
            }

            public unsafe void HeritabilityRitland1996(int qid, IND[] vinds, out double h2, out double se)
            {
                h2 = se = double.NaN;

                int n = vinds.Length;
                double ep = vinds.Average(ind => ind.quantitative[qid]);
                double ep2 = vinds.Average(ind => ind.quantitative[qid] * ind.quantitative[qid]);
                double vp = ep2 - ep * ep;//variance of quantiative triat values

                double etheta = 0, epxpy = 0, ethetapxpy = 0, varthetaxy = 0;
                int ndyads = 0;

                double[] ethetaJ = new double[L];
                double[] epxpyJ = new double[L];
                double[] ethetapxpyJ = new double[L];
                double[] varthetaxyJ = new double[L];
                int[] ndyadsJ = new int[L];

                double[] RLoc = new double[L], WLoc = new double[L];

                fixed (double* R = &RLoc[0], W = &WLoc[0])
                    for (int i = 0; i < vinds.Length; ++i)
                    {
                        IND x = vinds[i];
                        for (int j = 0; j < i; ++j)
                        {
                            IND y = vinds[j];
                            double theta = POP.KinshipRitland1996(x, y, loc, R, W);
                            if (double.IsNaN(theta) || double.IsInfinity(theta)) continue;
                            double sw = WLoc.Sum(), sr = RLoc.Sum(), sw2 = sw * sw;
                            double sqw = WLoc.Sum(w => w * w), sqr = RLoc.Sum(r => r * r);
                            double vartheta = (theta * theta - sqr / sw2) / (1 - sqw / sw2);

                            if (double.IsNaN(vartheta) || double.IsInfinity(vartheta)) continue;
                            double pxpy = (x.quantitative[qid] - ep) * (y.quantitative[qid] - ep) / vp;

                            etheta += theta;
                            epxpy += pxpy;
                            ethetapxpy += theta * pxpy;
                            varthetaxy += vartheta;
                            ndyads++;

                            if (HERITABILITY_Jackknife) for (int l = 0; l < L; ++l)
                                {
                                    if (WLoc[l] == 0) continue;
                                    double swl = sw - WLoc[l], srl = sr - RLoc[l], sw2l = swl * swl;
                                    double sqwl = sqw - WLoc[l] * WLoc[l], sqrl = sqr - RLoc[l] * RLoc[l];
                                    double thetal = srl / swl;
                                    double varthetal = (thetal * thetal - sqrl / sw2l) / (1 - sqwl / sw2l);

                                    if (double.IsNaN(thetal) || double.IsInfinity(thetal) || double.IsNaN(varthetal) || double.IsInfinity(varthetal)) continue;
                                    ethetaJ[l] += thetal;
                                    epxpyJ[l] += pxpy;
                                    ethetapxpyJ[l] += thetal * pxpy;
                                    varthetaxyJ[l] += varthetal;
                                    ndyadsJ[l]++;
                                }
                        }
                    }

                etheta /= ndyads;
                epxpy /= ndyads;
                ethetapxpy /= ndyads;
                varthetaxy /= ndyads;
                varthetaxy -= etheta * etheta;

                h2 = (ethetapxpy - etheta * epxpy) / (ploidy * varthetaxy);

                double ex2h2 = 0, exh2 = 0;
                //Jackknife h2
                if (HERITABILITY_Jackknife)
                {
                    int cl = 0;
                    for (int l = 0; l < L; ++l)
                    {
                        if (WLoc[l] == 0) continue;
                        ethetaJ[l] /= ndyadsJ[l];
                        epxpyJ[l] /= ndyadsJ[l];
                        ethetapxpyJ[l] /= ndyadsJ[l];
                        varthetaxyJ[l] /= ndyadsJ[l];
                        varthetaxyJ[l] -= ethetaJ[l] * ethetaJ[l];

                        double h2l = (ethetapxpyJ[l] - ethetaJ[l] * epxpyJ[l]) / (ploidy * varthetaxyJ[l]);
                        cl++;
                        exh2 += h2l;
                        ex2h2 += h2l * h2l;
                    }
                    exh2 /= cl;
                    ex2h2 /= cl;
                    se = Math.Sqrt((ex2h2 - exh2 * exh2) * (cl - 1));
                }
            }

            public static bool DEBUG_DLL = false;

            private void Mousseau1998Likelihood(Point4 xp, object[] par)
            {
                double[] vx2 = (double[])par[0];
                double[] prfs = (double[])par[1];
                double f = (double)par[2];

                //i2r
                double h2 = xp.real[0] = xp.image[0] / (1 + xp.image[0]);
                int n = vx2.Length;
                int v = ploidy;

                if (DEBUG_DLL)
                {
                    xp.li = Mousseau1998LikelihoodIn(h2, vx2, prfs, f, n, v);
                    return;
                }

                double re1 = 0, re2 = 1.0;
                double tx = 1.0 / v + (v - 1.0) / v * f;

                double vnr = 2;
                double vfs = 2 + (1 + f / tx) * h2;

                double isqnr = 1.0 / Math.Sqrt(2 * Math.PI * vnr);
                double isqfs = 1.0 / Math.Sqrt(2 * Math.PI * vfs);

                double iv2nr = 1.0 / (2 * vnr);
                double iv2fs = 1.0 / (2 * vfs);

                for (int i = 0; i < n; ++i)
                {
                    double x2 = vx2[i], lfs = prfs[i], lnr = 1.0 - lfs;
                    lfs *= isqnr * Math.Exp(x2 * iv2nr);
                    lfs *= isqfs * Math.Exp(x2 * iv2fs);
                    re2 *= lnr + lfs;

                    if (re2 < 1e-200)
                    {
                        re1 += Math.Log(re2);
                        re2 = 1.0;
                    }
                }

                re1 += Math.Log(re2);
                re2 = 1.0;
                xp.li = re1;
            }

            private void Thomas2000Likelihood(Point4 xp, object[] par)
            {
                double[] vx2 = (double[])par[0];
                double[,] prfs = (double[,])par[1];
                double f = (double)par[2];

                double h2 = xp.real[0] = xp.image[0] / (1 + xp.image[0]);
                double vp = xp.real[1] = Math.Exp(xp.image[1]);
                int n = vx2.Length;
                int v = ploidy;

                if (DEBUG_DLL)
                {
                    xp.li = Thomas2000LikelihoodIn(h2, vp, vx2, prfs, f, n, v);
                    return;
                }

                //i2r
                double re1 = 0, re2 = 1.0;

                double tx = 1.0 / v + (v - 1.0) / v * f;

                double vnr = 2 * vp;
                double vfs = vp * (2 - h2 * (1 + f / tx));
                double vhs = vp * (2 - h2 * (0.5 + f / tx + f * f / (2 * tx * tx)));

                if (vfs <= 0 || vhs <= 0) { xp.li = double.NegativeInfinity; return; }

                double isqnr = 1.0 / Math.Sqrt(2 * Math.PI * vnr);
                double isqfs = 1.0 / Math.Sqrt(2 * Math.PI * vfs);
                double isqhs = 1.0 / Math.Sqrt(2 * Math.PI * vhs);

                double iv2nr = 1.0 / (2 * vnr);
                double iv2fs = 1.0 / (2 * vfs);
                double iv2hs = 1.0 / (2 * vhs);

                for (int i = 0; i < n; ++i)
                {
                    double nx2 = vx2[i], lfs = prfs[i, 0], lhs = prfs[i, 1], lnr = 1.0 - lfs - lhs;
                    lfs *= isqfs * Math.Exp(nx2 * iv2fs);
                    lhs *= isqhs * Math.Exp(nx2 * iv2hs);
                    lnr *= isqnr * Math.Exp(nx2 * iv2nr);

                    re2 *= lnr + lfs + lhs;

                    if (re2 < 1e-200)
                    {
                        re1 += Math.Log(re2);
                        re2 = 1.0;
                    }
                }

                re1 += Math.Log(re2);
                re2 = 1.0;
                xp.li = re1;
            }

            public unsafe void HeritabilityML(HeritabilityEstimator estimator, int qid, IND[] vinds, double[] Pxlk2, double[] Pslk2, double[] M, out double h2, out double se)
            {
                h2 = se = double.NaN;

                int v = ploidy;
                Dictionary<ulong, double>[] hsdict1 = new Dictionary<ulong, double>[L];
                Dictionary<ulong, Thomas2000SibRateEntry>[] hsdict2 = new Dictionary<ulong, Thomas2000SibRateEntry>[L];
                KeyValuePair<int, double>[][] fre2 = new KeyValuePair<int, double>[L][];
                for (int l = 0; l < L; ++l)
                {
                    hsdict1[l] = new Dictionary<ulong, double>();
                    hsdict2[l] = new Dictionary<ulong, Thomas2000SibRateEntry>();
                    fre2[l] = loc[l].freq.ToArray();
                }

                double sq2 = Math.Sqrt(2);
                int ndyad = vinds.Length * (vinds.Length - 1) / 2;
                double[] prfs = estimator == HeritabilityEstimator.Mousseau1998 ? new double[ndyad] : null;
                double[,] prxfs = estimator == HeritabilityEstimator.Thomas2000 || estimator == HeritabilityEstimator.HuangML
                                     ? new double[ndyad, 2] : null;

                double[] vxy2 = new double[ndyad];
                double[] h2J = HERITABILITY_Jackknife ? new double[L] : null;

                double ep = vinds.Average(i => i.quantitative[qid]);
                double ep2 = vinds.Average(i => i.quantitative[qid] * i.quantitative[qid]);
                double vp = ep2 - ep * ep, isp = 1.0 / Math.Sqrt(vp);
                double Fis = 0;

                if (estimator == HeritabilityEstimator.HuangML)
                {
                    double Fa = Pslk2.Where(j => !double.IsNaN(j)).Sum() - M.Where(m => !double.IsNaN(m)).Sum();
                    double Fb = M.Where(m => !double.IsNaN(m)).Sum(m => 1 - m);
                    Fis = Fa / Fb < 0 ? 0 : Fa / Fb;
                }


                for (int jk = -1; jk < (HERITABILITY_Jackknife ? L : 0); ++jk)
                {
                    for (int i = 0, c = 0; i < vinds.Length; i++)
                    {
                        IND x = inds[i];
                        double q1 = x.quantitative[qid], z1 = (q1 - ep) * isp;
                        for (int j = 0; j < i; j++, c++)
                        {
                            IND y = inds[j];
                            double q2 = y.quantitative[qid], z2 = (q2 - ep) * isp;
                            vxy2[c] = estimator == HeritabilityEstimator.Mousseau1998 ? -(z1 + z2) * (z1 + z2) : -(q1 - q2) * (q1 - q2);

                            double prfs1 = 0, prfs2 = 1, prxfs1 = 0, prxfs2 = 1, prxhs1 = 0, prxhs2 = 1;

                            for (int l = 0; l < L; ++l)
                            {
                                if (l == jk) continue;
                                if (estimator == HeritabilityEstimator.Mousseau1998)
                                {
                                    x.g[l].MousseauProb(hsdict1[l], y.g[l], 0, fre2[l], ref prfs2);

                                    if (prfs2 > 1e100 || prfs2 < 1e-100)
                                    {
                                        prfs1 += Math.Log(prfs2);
                                        prfs2 = 1.0;
                                    }
                                }
                                else
                                {
                                    x.g[l].ThomasProb(hsdict2[l], y.g[l], Fis, fre2[l], ref prxfs2, ref prxhs2);

                                    if (prxfs2 > 1e100 || prxfs2 < 1e-100)
                                    {
                                        prxfs1 += Math.Log(prxfs2);
                                        prxfs2 = 1.0;
                                    }
                                    if (prxhs2 > 1e100 || prxhs2 < 1e-100)
                                    {
                                        prxhs1 += Math.Log(prxhs2);
                                        prxhs2 = 1.0;
                                    }
                                }
                            }

                            if (estimator == HeritabilityEstimator.Mousseau1998)
                            {
                                prfs1 += Math.Log(prfs2);
                                prfs2 = 1.0;
                                if (prfs1 > 30) prfs[c] = 1;//100% fs
                                else if (prfs1 < -30) prfs[c] = 0;//100% nr
                                else
                                {
                                    prfs1 = Math.Exp(prfs1); //fs vs nr
                                    prfs[c] = prfs1 / (1 + prfs1);
                                }
                            }
                            else
                            {
                                prxfs1 += Math.Log(prxfs2);
                                prxfs2 = 1.0;

                                prxhs1 += Math.Log(prxhs2);
                                prxhs2 = 1.0;

                                if (prxfs1 > 30 || prxhs1 > 30)
                                {
                                    double mi = Math.Min(prxfs1, prxhs1);
                                    prxfs1 -= mi;
                                    prxhs1 -= mi;
                                    if (prxfs1 > 30) { prxfs[c, 0] = 1; prxfs[c, 1] = 0; }//100% fs
                                    else if (prxhs1 > 30) { prxfs[c, 0] = 0; prxfs[c, 1] = 1; }//100% hs
                                    else
                                    {
                                        prxfs1 = Math.Exp(prxfs1);
                                        prxhs1 = Math.Exp(prxhs1);
                                        prxfs[c, 0] = prxfs1 / (prxfs1 + prxhs1); //fs poster prob
                                        prxfs[c, 1] = prxhs1 / (prxfs1 + prxhs1); //hs poster prob
                                    }
                                }
                                else
                                {
                                    prxfs1 = Math.Exp(prxfs1);
                                    prxhs1 = Math.Exp(prxhs1);
                                    prxfs[c, 0] = prxfs1 / (1 + prxfs1 + prxhs1); //fs poster prob
                                    prxfs[c, 1] = prxhs1 / (1 + prxfs1 + prxhs1); //hs poster prob
                                }
                            }
                        }
                    }

                    if (estimator == HeritabilityEstimator.Mousseau1998)
                    {
                        Point4 x = Point4.DownHillSimplex(1, 1, Mousseau1998Likelihood, new object[] { vxy2, prfs, 0.0 }, p => p.image[0] = 1);
                        if (jk == -1) h2 = x.real[0];
                        else h2J[jk] = x.real[0];
                    }
                    else
                    {
                        Point4 x = Point4.DownHillSimplex(2, 1, Thomas2000Likelihood, new object[] { vxy2, prxfs, Fis }, p => { p.image[0] = 1; p.image[1] = Math.Log(vp); });
                        if (jk == -1) h2 = x.real[0];
                        else h2J[jk] = x.real[0];
                    }
                }

                if (HERITABILITY_Jackknife)
                {
                    double exh2 = h2J.Average();
                    double ex2h2 = h2J.Average(h => h * h);
                    se = Math.Sqrt((ex2h2 - exh2 * exh2) * (L - 1));
                }
            }

            public unsafe void HeritabilityHuangRegress(int qid, IND[] vinds, double[] Pxlk2, double[] Pslk2, double[] M, out double h2, out double se)
            {
                h2 = se = double.NaN;

                int n = vinds.Length;
                double ep = vinds.Average(ind => ind.quantitative[qid]);
                double ep2 = vinds.Average(ind => ind.quantitative[qid] * ind.quantitative[qid]);
                double vp = ep2 - ep * ep;//variance of quantiative triat values

                double etheta = 0, epxpy = 0, ethetapxpy = 0, varthetaxy = 0;
                int ndyads = 0;

                int[] ndyadsJ = new int[L];
                double[] ethetaJ = new double[L];
                double[] epxpyJ = new double[L];
                double[] ethetapxpyJ = new double[L];
                double[] varthetaxyJ = new double[L];
                double[] TxJ = new double[L];
                double[] FJ = new double[L];

                double[] RLoc = new double[L], WLoc = new double[L];
                double F = 0, Fa = 0, Fb = 0;
                double Tx = 0, Txa = 0, Txb = 0;


                Fa = Pslk2.Where(j => !double.IsNaN(j)).Sum() - M.Where(m => !double.IsNaN(m)).Sum();
                Fb = M.Where(m => !double.IsNaN(m)).Sum(m => 1 - m);
                F = Fa / Fb;  //average inbreeding coef

                Txa = Pxlk2.Sum() - M.Where(m => !double.IsNaN(m)).Sum();
                Txb = L - M.Where(m => !double.IsNaN(m)).Sum();
                Tx = Txa / Txb;   //average mean individual kinship

                for (int l = 0; l < L; ++l)
                {
                    if (double.IsNaN(Pslk2[l]))
                    {
                        FJ[l] = double.NaN;
                        continue;
                    }
                    FJ[l] = (Fa - (Pslk2[l] - M[l])) / (Fb - (1 - M[l]));//average inbreeding coef excluding locus l
                    TxJ[l] = (Txa - Pxlk2[l]) / (Txb - 1 + M[l]);//average mean individual kinship excluding locus l
                }

                fixed (double* R = &RLoc[0], W = &WLoc[0])
                    for (int i = 0; i < vinds.Length; ++i)
                    {
                        IND x = vinds[i];
                        for (int j = 0; j < i; ++j)
                        {
                            IND y = vinds[j];
                            double theta = POP.KinshipHuangUnpub(x, y, loc, M, R, W);
                            if (double.IsNaN(theta) || double.IsInfinity(theta)) continue;
                            double sw = WLoc.Sum(), sr = RLoc.Sum(), sw2 = sw * sw;
                            double sqw = WLoc.Sum(w => w * w), sqr = RLoc.Sum(r => r * r);
                            double vartheta = (theta * theta - sqr / sw2) / (1 - sqw / sw2);

                            if (double.IsNaN(vartheta) || double.IsInfinity(vartheta)) continue;
                            double pxpy = (x.quantitative[qid] - ep) * (y.quantitative[qid] - ep) / vp;

                            etheta += theta;
                            epxpy += pxpy;
                            ethetapxpy += theta * pxpy;
                            varthetaxy += vartheta;
                            ndyads++;

                            if (HERITABILITY_Jackknife) for (int l = 0; l < L; ++l)
                            {
                                if (WLoc[l] == 0) continue;
                                double swl = sw - WLoc[l], srl = sr - RLoc[l], sw2l = swl * swl;
                                double sqwl = sqw - WLoc[l] * WLoc[l], sqrl = sqr - RLoc[l] * RLoc[l];
                                double thetal = srl / swl;
                                double varthetal = (thetal * thetal - sqrl / sw2l) / (1 - sqwl / sw2l);

                                if (double.IsNaN(thetal) || double.IsInfinity(thetal) || double.IsNaN(varthetal) || double.IsInfinity(varthetal)) continue;
                                ethetaJ[l] += thetal;
                                epxpyJ[l] += pxpy;
                                ethetapxpyJ[l] += thetal * pxpy;
                                varthetaxyJ[l] += varthetal;
                                ndyadsJ[l]++;
                            }
                        }
                    }

                etheta /= ndyads;
                epxpy /= ndyads;
                ethetapxpy /= ndyads;
                varthetaxy /= ndyads;
                varthetaxy -= etheta * etheta;
                h2 = Tx * (ethetapxpy - etheta * epxpy) / varthetaxy;

                //Jackknife h2
                double ex2h2 = 0, exh2 = 0;
                if (HERITABILITY_Jackknife)
                {
                    int cl = 0;
                    for (int l = 0; l < L; ++l)
                    {
                        if (double.IsNaN(Pslk2[l]) || WLoc[l] == 0) continue;
                        ethetaJ[l] /= ndyadsJ[l];
                        epxpyJ[l] /= ndyadsJ[l];
                        ethetapxpyJ[l] /= ndyadsJ[l];
                        varthetaxyJ[l] /= ndyadsJ[l];
                        varthetaxyJ[l] -= ethetaJ[l] * ethetaJ[l];

                        double h2l = TxJ[l] * (ethetapxpyJ[l] - ethetaJ[l] * epxpyJ[l]) / varthetaxyJ[l];
                        cl++;
                        exh2 += h2l;
                        ex2h2 += h2l * h2l;
                    }
                    exh2 /= cl;
                    ex2h2 /= cl;
                    se = Math.Sqrt((ex2h2 - exh2 * exh2) * (cl - 1));
                }
            }
        }

        public class POP
        {
            public double[,][] ALPHA = new double[0, MAX_PLOIDY + 1][];//double-reduction rate in a gamete 
            public double[,] LAMBDA = new double[0, MAX_PLOIDY + 1];//double-reduction rate in a gamete 
            public double[,][] BETA = new double[0, MAX_PLOIDY + 1][];//double-reduction rate in a zygote
            public double[,][] BETAC = new double[0, MAX_PLOIDY + 1][]; //acculumutive double-reduction rate

            public Form1 form1;

            public List<Dictionary<string, List<string>>> regiontextdict = new List<Dictionary<string, List<string>>>();
            public List<Dictionary<string, SUBPOP>> regiondict = new List<Dictionary<string, SUBPOP>>();
            public ConcurrentDictionary<string, IND> indsdict = new ConcurrentDictionary<string, IND>();
            public ConcurrentDictionary<string, SUBPOP> subpopsdict = new ConcurrentDictionary<string, SUBPOP>();

            public string name;
            public int id;
            public int n;
            public int L;
            public int nphenotypes;
            public int nhaplotypes;

            public int ProgressValue;
            public int ProgressMax;
            public string Progress = "";

            public int generation_sim;
            public LOC[] loc_sim;
            public Random rnd_sim;
            public int ploidy_sim;

            public IND[] inds;
            public SUBPOP[] subpops;
            public SUBPOP[][] regions;
            public SUBPOP total_pop;

            public int region_count;//total number of regions
            public int region_dyad_count;//total number of region pairs
            public ConcurrentDictionary<uint, PHENOBODY>[,] phenobodydict;
            public ConcurrentDictionary<uint, GENOBODY>[,] gametebodydict;

            public string[] coordinate_name, quantitative_name;
            public int ncoordinate = 0, nquantitative = 0;

            public string modelteststr;//used in modeltest

            #region Simpop

            public void AddInds()
            {
                //founder simulation
                inds = new IND[n];
                nhaplotypes = n * ploidy_sim;

                for (int i = 0; i < n; ++i)
                {
                    IND tind = new IND(L);
                    tind.ploidy = ploidy_sim;
                    for (int l = 0; l < L; ++l)
                        tind.g[l] = loc_sim[l].CreatePhenotype(rnd_sim, ploidy_sim, l);
                    tind.id = inds.Length;
                    inds[i] = tind;
                }
            }

            public void WriteHeader(StringBuilder w)
            {
                //in simulation
                w.Append("ID\tPop\tPloidy");
                for (int i = 0; i < loc_sim.Length; ++i)
                    w.Append("\t" + loc_sim[i].name);
                w.Append("\r\n");
            }

            public void WriteGenotype(StringBuilder w, ref int cindcount)
            {
                //in simulation
                for (int i = 0; i < n * SIMPOP_SAMPLING_RATIO; ++i)
                {
                    w.Append("Ind" + (i + 1 + cindcount).ToString() + "\t");
                    w.Append(name + "\t");
                    w.Append(ploidy_sim);
                    inds[i].WriteGenotype(w, rnd_sim);
                }
                cindcount += (int)(n * SIMPOP_SAMPLING_RATIO);
            }

            public static void ReproduceThread()
            {
                runstate = GlobalRunState.simulating;
                for (int i = 0; i < nsim; ++i)
                    foreach (POP p in simpops)
                        p.Reproduce();
                runstate = GlobalRunState.simulated;
                SUBPOP[] tpops = simpops.Select(p => p.GetSubPopSim()).ToArray();
                fst = GetFst(tpops, FstEstimator.SimNei1973);
            }

            public SUBPOP GetSubPopSim()
            {
                //in simulation
                SUBPOP re = new SUBPOP(this);
                re.name = name;
                re.loc = loc_sim;
                re.inds = inds;
                re.ploidy = inds[0].ploidy;
                re.nhaplotypes = nhaplotypes;
                re.id = id;
                //re.k = k;
                re.n = n;
                re.L = L;
                return re;
            }

            public void Reproduce(int n2 = -1)
            {
                if (n2 == -1) n2 = n;
                int fcount = (int)Math.Round(SIMPOP_FEMALE_RATE * n);
                int mcount = n - fcount;
                int fid, mid;
                IND[] inds2 = new IND[n2];

                //For each offspring
                for (int i = 0; i < n2; ++i)
                {
                    Random crnd = rnd_sim;

                    //Randomly sample their parents
                    if (SIMPOP_DIOECIOUS)
                    {
                        //Draw father id
                        fid = crnd.Next(fcount);

                        //Draw mother id
                        mid = crnd.Next(mcount) + fcount;
                    }
                    else
                    {
                        //Draw mother id
                        mid = crnd.Next(n);

                        //Father is identical to mother at a prob of SIMPOP_SELFING_RATIO
                        if (crnd.NextDouble() < SIMPOP_SELFING_RATIO)
                            fid = mid;
                        else
                            fid = NextAvoid(crnd, n, mid);
                    }

                    //Generate offspring genotypes
                    inds2[i] = ReproduceSub(inds[fid], inds[mid], crnd);
                }

                inds = inds2;
                n = n2;
                generation_sim++;
            }

            public IND ReproduceSub(IND A, IND B, Random rnd)
            {
                //Population simulator and parentage simulations, generates genotypes of an individual
                IND tind = new IND(L);
                tind.ploidy = ploidy_sim;
                int[] als = new int[ploidy_sim];

                //For each locus
                for (int l = 0; l < L; ++l)
                {
                    //If father or mother has no data, return missing data
                    if (A.g[l].hash == 0 || B.g[l].hash == 0)
                    {
                        tind.g[l] = new PHENOTYPE(ploidy_sim, new int[0], false);
                        continue;
                    }

                    //Shuffle allele copies of father and mother genotypes
                    int[] f = new int[ploidy_sim], m = new int[ploidy_sim];
                    GetRandSeq(f, rnd);
                    GetRandSeq(m, rnd);

                    //Simulate double-reduction
                    double mode = 0;

                    //i pairs of IBDR alleles in the gamete
                    mode = rnd.NextDouble();
                    for (int i = 0; i <= ploidy_sim / 4; ++i)
                    {
                        //if double-reduction, allele copy is identical to previous allele copy
                        if (i > 0) f[i * 2 - 2] = f[i * 2 - 1];
                        mode -= ALPHA[l, ploidy_sim][i];
                        if (mode < 0) break;
                    }

                    //i pairs of IBDR alleles in the gamete
                    mode = rnd.NextDouble();
                    for (int i = 0; i <= ploidy_sim / 4; ++i)
                    {
                        //if double-reduction, allele copy is identical to previous allele copy
                        if (i > 0) m[i * 2 - 2] = m[i * 2 - 1];
                        mode -= ALPHA[l, ploidy_sim][i];
                        if (mode < 0) break;
                    }

                    //Copy alleles from sperm and egg
                    for (int i = 0; i < ploidy_sim / 2; ++i)
                    {
                        als[i                 ] = A.g[l].alleles[f[i]];
                        als[i + ploidy_sim / 2] = B.g[l].alleles[m[i]];
                    }

                    //Generate offspring genotype
                    Array.Sort(als);
                    tind.g[l] = new PHENOTYPE(ploidy_sim, als, true);
                }
                return tind;
            }

            public void UpdateAlleleFreqSim()
            {
                //in simulation
                for (int l = 0; l < L; ++l)
                {
                    foreach (int a in loc_sim[l].freq.Keys.ToArray())
                        loc_sim[l].freq[a] = 0;
                    foreach (IND t in inds)
                        foreach (int a in t.g[l].alleles)
                            loc_sim[l].freq[a]++;
                }
                UnifyPop(loc_sim);
            }
            #endregion

            #region DOUBLE_REDUCTION

            private static double[] GetAlphaPrime(int p)
            {
                double[] alphaprime = new double[25];
                int D = p / 4;
                for (int i = 0; i <= D; ++i)
                    alphaprime[i] = BINOMIAL[p / 2, i] * BINOMIAL[p / 2 - i, p / 2 - 2 * i] * Math.Pow(2, p / 2 - 2 * i) / BINOMIAL[p, p / 2];
                return alphaprime;
            }

            public bool GetAlphaSim(int L)
            {
                string[] dis = SIMPOP_DIST.Replace("\r\n", "\n").Split(new char[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
                if (dis.Length == 0)
                {
                    dis = new string[] { "25" };
                    if (REMIND_WARNING && !ShowMessage3Buttons("There are no distance of locus to centromere. Now using 25 cM as default."))
                        return false;
                    SIMPOP_NDIS = 1;
                }
                else if (dis.Length != L)
                {
                    if (REMIND_WARNING && !ShowMessage3Buttons("Number of loci do not match that in distance to centromere box. If there are less loci in the distance box, the distance of the rest loci will equal to the 1st locus."))
                        return false;
                    SIMPOP_NDIS = Math.Min(dis.Length, L);
                }

                for (int i = 0; i < dis.Length; ++i)
                    dis[i] = dis[i].Split("`~!@#$%^&*()_=[]{};':\",./<>?\\".ToCharArray(), StringSplitOptions.RemoveEmptyEntries)[0].ToUpper();

                ALPHA = new double[L, MAX_PLOIDY + 1][];//l, pl
                LAMBDA = new double[L, MAX_PLOIDY + 1];//l, pl
                BETA = new double[L, MAX_PLOIDY + 1][];//l, pl
                BETAC = new double[L, MAX_PLOIDY + 1][];//l, pl
                for (int l = 0; l < L; ++l)
                {
                    string d = l >= dis.Length ? dis[0] : dis[l];
                    for (int j = 1; j <= MAX_PLOIDY; ++j)
                    {
                        ALPHA[l, j] = new double[j / 4 + 1];
                        ALPHA[l, j][0] = 1;
                    }
                    double E = 0;
                    if (d == "PRCS")
                    {
                        ALPHA[l, 2] = new double[] { 1 };
                        ALPHA[l, 4] = new double[] { 6.0 / 7, 1.0 / 7 };
                        ALPHA[l, 6] = new double[] { 8.0 / 11, 3.0 / 11 };
                        ALPHA[l, 8] = new double[] { 40.0 / 65, 24.0 / 65, 1.0 / 65 };
                        ALPHA[l, 10] = new double[] { 168.0 / 323, 140.0 / 323, 15.0 / 323 };
                    }
                    else if (d == "HWE" || d == "RCS")
                    {
                        ALPHA[l, 4][0] = 1; ALPHA[l, 4][1] = 0;
                        ALPHA[l, 6][0] = 1; ALPHA[l, 6][1] = 0;
                        ALPHA[l, 8][0] = 1; ALPHA[l, 8][1] = 0; ALPHA[l, 8][2] = 0;
                        ALPHA[l, 10][0] = 1; ALPHA[l, 10][1] = 0; ALPHA[l, 10][2] = 0;
                    }
                    else if (d == "CES")
                    {
                        ALPHA[l, 4][0] = 5.0 / 6; ALPHA[l, 4][1] = 1.0 / 6;
                        ALPHA[l, 6][0] = 7.0 / 10; ALPHA[l, 6][1] = 3.0 / 10;
                        ALPHA[l, 8][0] = 83.0 / 140; ALPHA[l, 8][1] = 27.0 / 70; ALPHA[l, 8][2] = 3.0 / 140;
                        ALPHA[l, 10][0] = 127.0 / 252; ALPHA[l, 10][1] = 55.0 / 126; ALPHA[l, 10][2] = 5.0 / 84;
                    }
                    else if (double.TryParse(d, out E))
                    {
                        E = (1 - Math.Exp(double.Parse(d) / -50.0)) / 2;
                        E = Truncate(0, 1, E);

                        for (int p = 4; p <= MAX_PLOIDY; p += 2)
                        {
                            int D = p / 4;
                            double[] alphaprime = GetAlphaPrime(p);
                            for (int dd = 0; dd <= D; ++dd)
                            {
                                ALPHA[l, p][dd] = 0;
                                for (int j = dd; j <= D; ++j)
                                    for (int i = j; i <= D; ++i)
                                        ALPHA[l, p][dd] += alphaprime[i] * BINOMIAL[i, j] * Math.Pow(2, -i) * BINOMIAL[j, dd] * Math.Pow(E, dd) * Math.Pow(1 - E, j - dd);
                            }
                        }
                    }

                    for (int p = 1; p <= MAX_PLOIDY; ++p)
                    {
                        BETA[l, p] = new double[ALPHA[l, p].Length * 2 - 1];
                        for (int i = 0; i < ALPHA[l, p].Length; ++i)
                            for (int j = 0; j < ALPHA[l, p].Length; ++j)
                                BETA[l, p][i + j] += ALPHA[l, p][i] * ALPHA[l, p][j];
                        BETAC[l, p] = new double[ALPHA[l, p].Length * 2 - 1];
                        BETAC[l, p][0] = BETA[l, p][0];
                        for (int i = 1; i < BETA[l, p].Length; ++i)
                            BETAC[l, p][i] = BETA[l, p][i] + BETAC[l, p][i - 1];

                        LAMBDA[l, p] = 0;
                        for (int i = 0; i < ALPHA[l, p].Length; ++i)
                            LAMBDA[l, p] += ALPHA[l, p][i] * i;
                    }
                }
                return true;
            }

            public bool GetAlpha(LOC[] loc, int t = -1)
            {
                int L = loc.Length;

                if (ALPHA.GetLength(0) != L)
                {
                    ALPHA = new double[L, MAX_PLOIDY + 1][];//l, pl
                    LAMBDA = new double[L, MAX_PLOIDY + 1];//l, pl
                    BETA = new double[L, MAX_PLOIDY + 1][];//l, pl
                    BETAC = new double[L, MAX_PLOIDY + 1][];//l, pl

                    for (int l = (t == -1 ? 0 : t); l < (t == -1 ? L : t + 1); ++l)
                        for (int p = 1; p <= MAX_PLOIDY; ++p)
                        {
                            ALPHA[l, p] = new double[p / 4 + 1];
                            BETA[l, p] = new double[ALPHA[l, p].Length * 2 - 1];
                            BETAC[l, p] = new double[ALPHA[l, p].Length * 2 - 1];
                        }
                }

                for (int l = (t == -1 ? 0 : t); l < (t == -1 ? L : t + 1); ++l)
                {
                    //HWE, RCS
                    for (int p = 1; p <= MAX_PLOIDY; ++p)
                        ALPHA[l, p][0] = 1;
                    if (DR_MODE == DoubleReductionModel.PRCS)
                    {
                        //PRCS
                        ALPHA[l, 4][0] = 6.0 / 7; ALPHA[l, 4][1] = 1.0 / 7;
                        ALPHA[l, 6][0] = 8.0 / 11; ALPHA[l, 6][1] = 3.0 / 11;
                        ALPHA[l, 8][0] = 40.0 / 65; ALPHA[l, 8][1] = 24.0 / 65; ALPHA[l, 8][2] = 1.0 / 65;
                        ALPHA[l, 10][0] = 168.0 / 323; ALPHA[l, 10][1] = 140.0 / 323; ALPHA[l, 10][2] = 15.0 / 323;
                    }
                    else if (DR_MODE == DoubleReductionModel.CES)
                    {
                        //CES
                        ALPHA[l, 4][0] = 5.0 / 6; ALPHA[l, 4][1] = 1.0 / 6;
                        ALPHA[l, 6][0] = 7.0 / 10; ALPHA[l, 6][1] = 3.0 / 10;
                        ALPHA[l, 8][0] = 83.0 / 140; ALPHA[l, 8][1] = 27.0 / 70; ALPHA[l, 8][2] = 3.0 / 140;
                        ALPHA[l, 10][0] = 127.0 / 252; ALPHA[l, 10][1] = 55.0 / 126; ALPHA[l, 10][2] = 5.0 / 84;
                    }
                    else
                    {
                        double E = 0;
                        if (DR_MODE == DoubleReductionModel.PES25) //PES + rs = 0.25
                            E = loc[l].rs = 0.25;
                        else if (DR_MODE == DoubleReductionModel.PES50) //PES + rs = 0.5
                            E = loc[l].rs = 0.5;
                        else //PES + rs
                            E = loc[l].rs;
                        E = Truncate(0, 1, E);

                        for (int p = 4; p <= MAX_PLOIDY; p += 2)
                        {
                            int D = p / 4;
                            double[] alphaprime = GetAlphaPrime(p);
                            for (int dd = 0; dd <= D; ++dd)
                            {
                                ALPHA[l, p][dd] = 0;
                                for (int j = dd; j <= D; ++j)
                                    for (int i = j; i <= D; ++i)
                                        ALPHA[l, p][dd] += alphaprime[i] * BINOMIAL[i, j] * Math.Pow(2, -i) * BINOMIAL[j, dd] * Math.Pow(E, dd) * Math.Pow(1 - E, j - dd);
                            }
                        }
                    }

                    for (int p = 1; p <= MAX_PLOIDY; ++p)
                    {
                        for (int i = 0; i < BETA[l, p].Length; ++i)
                            BETA[l, p][i] = 0;
                        for (int i = 0; i < ALPHA[l, p].Length; ++i)
                            for (int j = 0; j < ALPHA[l, p].Length; ++j)
                                BETA[l, p][i + j] += ALPHA[l, p][i] * ALPHA[l, p][j];
                        BETAC[l, p][0] = BETA[l, p][0];
                        for (int i = 1; i < BETA[l, p].Length; ++i)
                            BETAC[l, p][i] = BETA[l, p][i] + BETAC[l, p][i - 1];

                        LAMBDA[l, p] = 0;
                        for (int i = 0; i < ALPHA[l, p].Length; ++i)
                            LAMBDA[l, p] += ALPHA[l, p][i] * i;
                    }
                }
                return true;
            }
            #endregion

            #region DummyGenotype

            private int ReplaceNullAllele(int allele, int nullid)
            {
                return allele == NULL_ALLELE ? nullid : allele;
            }

            public void ExportDummyGenotype(ExportMethod method, ExportFormat format, bool fillmissing, int rep, int nullid, string file, int seed, int maxn)
            {
                switch (format)
                {
                    case ExportFormat.PolyGene: ExportPolyGene(method, fillmissing, rep, nullid, file, seed, maxn); break;
                    case ExportFormat.Genepop: ExportGenepop(method, fillmissing, rep, nullid, file, seed, maxn); break;
                    case ExportFormat.Structure: ExportStructure(method, fillmissing, rep, nullid, file, seed, maxn); break;
                    case ExportFormat.PolyRelatedness: ExportPolyRelatedness(method, fillmissing, rep, nullid, file, seed, maxn); break;
                    case ExportFormat.Spagedi: ExportSpagedi(method, fillmissing, rep, nullid, file, seed, maxn); break;
                    case ExportFormat.Genodive: ExportGenodive(method, fillmissing, rep, nullid, file, seed, maxn); break;
                    case ExportFormat.Migrate: ExportMigrate(method, fillmissing, rep, nullid, file, seed, maxn); break;
                    case ExportFormat.BayesAss: ExportBayesAss(method, fillmissing, rep, nullid, file, seed, maxn); break;
                }
            }

            private void ExportPolyGene(ExportMethod method, bool fillmissing, int rep, int nullid, string file, int seed, int maxn)
            {
                StringBuilder re = new StringBuilder();

                Random rnd = new Random(seed);
                re.Append("Ind\tPop\tPloidy");
                for (int l = 0; l < L; ++l)
                {
                    re.Append("\t");
                    re.Append(total_pop.loc[l].name);
                }
                re.Append("\r\n");

                foreach (SUBPOP s in subpops)
                {
                    IND[][] indlist = null;
                    if (fillmissing)
                    {
                        indlist = new IND[L][];
                        for (int l = 0; l < L; ++l)
                            indlist[l] = s.inds.Where(i => i.g[l].genotypes.Length > 0).ToArray();
                    }
                    int[,] seq1 = new int[L, s.ploidy];
                    int sv = (method == ExportMethod.Split || method == ExportMethod.Truncate) ? 2 : s.ploidy;
                    int kp = s.ploidy / 2;

                    int nout1 = s.inds.Length * rep * (method == ExportMethod.Split ? kp : 1);
                    bool[] select = new bool[nout1];
                    int[] seq2 = new int[nout1];
                    GetRandSeq(seq2, rnd);
                    for (int i = 0; i < Math.Min(maxn, nout1); ++i)
                        select[seq2[i]] = true;

                    for (int i = 0, nout2 = 0; i < s.inds.Length; ++i)
                    {
                        for (int j = 0; j < rep; ++j)
                        {
                            if (method == ExportMethod.Truncate)
                            {
                                if (!select[nout2++]) continue;
                                GetRandSeq(seq1, rnd);
                                re.Append(s.inds[i].name);
                                if (rep > 1) re.Append("_" + (j + 1));
                                re.Append("\t");
                                re.Append(s.name);
                                re.Append("\t");
                                re.Append(sv.ToString());

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                        re.Append("\t");
                                    else
                                    {
                                        re.Append("\t");
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 0]], nullid));
                                        re.Append(",");
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 1]], nullid));
                                    }
                                }
                                re.Append("\r\n");
                            }
                            if (method == ExportMethod.Split) 
                            {
                                GetRandSeq(seq1, rnd);
                                for (int k = 0; k < kp; ++k)
                                {
                                    if (!select[nout2++]) continue;
                                    re.Append(s.inds[i].name);
                                    if (rep > 1) re.Append("_" + (j + 1));
                                    if (kp > 1) re.Append("_" + (k + 1));
                                    re.Append("\t");
                                    re.Append(s.name);
                                    re.Append("\t");
                                    re.Append(sv.ToString());

                                    for (int l = 0; l < L; ++l)
                                    {
                                        GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                        if (gt == null && fillmissing)
                                            gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                        if (gt == null)
                                            re.Append("\t");
                                        else
                                        {
                                            re.Append("\t");
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 0]], nullid));
                                            re.Append(",");
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 1]], nullid));
                                        }
                                    }
                                    re.Append("\r\n");
                                }
                            }
                            if (method == ExportMethod.Rand)
                            {
                                if (!select[nout2++]) continue;
                                re.Append(s.inds[i].name);
                                if (rep > 1) re.Append("_" + (j + 1));
                                re.Append("\t");
                                re.Append(s.name);
                                re.Append("\t");
                                re.Append(sv.ToString());

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                        re.Append("\t");
                                    else
                                    {
                                        re.Append("\t");
                                        for (int m = 0; m < sv - 1; ++m)
                                        {
                                            re.Append(ReplaceNullAllele(gt.alleles2[m], nullid));
                                            re.Append(",");
                                        }
                                        re.Append(ReplaceNullAllele(gt.alleles2[sv - 1], nullid));
                                    }
                                }
                                re.Append("\r\n");
                            }
                        }
                    }
                }

                File.WriteAllText(file, re.ToString());
            }

            private void ExportStructure(ExportMethod method, bool fillmissing, int rep, int nullid, string file, int seed, int maxn)
            {
                /*
                Ind	Pop	D6S493	D7S820
                */

                StringBuilder re = new StringBuilder();

                Random rnd = new Random(seed);

                for (int l = 0; l < L; ++l)
                {
                    if (l > 0) re.Append("\t");
                    re.Append(total_pop.loc[l].name);
                }
                re.Append("\r\n");

                GENOTYPE[] gts = new GENOTYPE[L];

                foreach (SUBPOP s in subpops)
                {
                    IND[][] indlist = null;
                    if (fillmissing)
                    {
                        indlist = new IND[L][];
                        for (int l = 0; l < L; ++l)
                            indlist[l] = s.inds.Where(i => i.g[l].genotypes.Length > 0).ToArray();
                    }
                    int[,] seq1 = new int[L, s.ploidy];
                    int sv = (method == ExportMethod.Split || method == ExportMethod.Truncate) ? 2 : s.ploidy;
                    int kp = s.ploidy / 2;

                    int nout1 = s.inds.Length * rep * (method == ExportMethod.Split ? kp : 1);
                    bool[] select = new bool[nout1];
                    int[] seq2 = new int[nout1];
                    GetRandSeq(seq2, rnd);
                    for (int i = 0; i < Math.Min(maxn, nout1); ++i)
                        select[seq2[i]] = true;

                    for (int i = 0, nout2 = 0; i < s.inds.Length; ++i)
                    {
                        for (int j = 0; j < rep; ++j)
                        {
                            if (method == ExportMethod.Truncate)
                            {
                                if (!select[nout2++]) continue;
                                GetRandSeq(seq1, rnd);
                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);
                                    gts[l] = gt;
                                }

                                for (int a = 0; a < sv; ++a)
                                {
                                    re.Append(s.inds[i].name);
                                    if (rep > 1) re.Append("_" + (j + 1));
                                    re.Append("\t");
                                    re.Append(s.name);

                                    for (int l = 0; l < L; ++l)
                                    {
                                        GENOTYPE gt = gts[l];
                                        if (gt == null)
                                            re.Append("\t-9");
                                        else
                                        {
                                            re.Append("\t");
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, a]], nullid).ToString());
                                        }
                                    }
                                    re.Append("\r\n");
                                }
                            }
                            if (method == ExportMethod.Split)
                            {
                                GetRandSeq(seq1, rnd);
                                for (int k = 0; k < kp; ++k)
                                {
                                    if (!select[nout2++]) continue;
                                    for (int l = 0; l < L; ++l)
                                    {
                                        GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                        if (gt == null && fillmissing)
                                            gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);
                                        gts[l] = gt;
                                    }

                                    for (int a = 0; a < sv; ++a)
                                    {
                                        re.Append(s.inds[i].name);
                                        if (rep > 1) re.Append("_" + (j + 1));
                                        if (kp > 1) re.Append("_" + (k + 1));
                                        re.Append("\t");
                                        re.Append(s.name);

                                        for (int l = 0; l < L; ++l)
                                        {
                                            GENOTYPE gt = gts[l];
                                            if (gt == null)
                                                re.Append("\t-9");
                                            else
                                            {
                                                re.Append("\t");
                                                re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + a]], nullid).ToString());
                                            }
                                        }
                                        re.Append("\r\n");
                                    }
                                }
                            }
                            if (method == ExportMethod.Rand)
                            {
                                if (!select[nout2++]) continue;
                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);
                                    gts[l] = gt;
                                }

                                for (int a = 0; a < sv; ++a)
                                {
                                    re.Append(s.inds[i].name);
                                    if (rep > 1) re.Append("_" + (j + 1));
                                    re.Append("\t");
                                    re.Append(s.name);

                                    for (int l = 0; l < L; ++l)
                                    {
                                        GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                        if (gt == null && fillmissing)
                                            gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                        if (gt == null)
                                            re.Append("\t-9");
                                        else
                                        {
                                            re.Append("\t");
                                            re.Append(ReplaceNullAllele(gt.alleles2[a], nullid).ToString());
                                        }
                                    }
                                    re.Append("\r\n");
                                }
                            }
                        }
                    }
                }

                File.WriteAllText(file, re.ToString());
            }

            private void ExportPolyRelatedness(ExportMethod method, bool fillmissing, int rep, int nullid, string file, int seed, int maxn)
            {
                /*
                //configuration
                //#alleledigits(1~4)	#outputdigits(0~10)	#missingallele	#ambiguousallele	#nthreads(1~64)
                3	8	0	999	4
                //genotype
                Ind	Pop	D6S493	D7S820
                //end of file
                */

                StringBuilder re = new StringBuilder();

                Random rnd = new Random(seed);
                re.Append(@"//configuration
//#alleledigits(1~4)	#outputdigits(0~10)	#missingallele	#ambiguousallele	#nthreads(1~64)
3	8	0	999	4
//genotype
Ind	Pop");

                for (int l = 0; l < L; ++l)
                {
                    re.Append("\t");
                    re.Append(total_pop.loc[l].name);
                }
                re.Append("\r\n");

                foreach (SUBPOP s in subpops)
                {
                    IND[][] indlist = null;
                    if (fillmissing)
                    {
                        indlist = new IND[L][];
                        for (int l = 0; l < L; ++l)
                            indlist[l] = s.inds.Where(i => i.g[l].genotypes.Length > 0).ToArray();
                    }
                    int[,] seq1 = new int[L, s.ploidy];
                    int sv = (method == ExportMethod.Split || method == ExportMethod.Truncate) ? 2 : s.ploidy;
                    int kp = s.ploidy / 2;

                    int nout1 = s.inds.Length * rep * (method == ExportMethod.Split ? kp : 1);
                    bool[] select = new bool[nout1];
                    int[] seq2 = new int[nout1];
                    GetRandSeq(seq2, rnd);
                    for (int i = 0; i < Math.Min(maxn, nout1); ++i)
                        select[seq2[i]] = true;

                    for (int i = 0, nout2 = 0; i < s.inds.Length; ++i)
                    {
                        for (int j = 0; j < rep; ++j)
                        {
                            if (method == ExportMethod.Truncate) 
                            {
                                if (!select[nout2++]) continue;
                                GetRandSeq(seq1, rnd);
                                re.Append(s.inds[i].name);
                                if (rep > 1) re.Append("_" + (j + 1));
                                re.Append("\t");
                                re.Append(s.name);

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                        re.Append("\t000000");
                                    else
                                    {
                                        re.Append("\t");
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 0]], nullid).ToString("D3"));
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 1]], nullid).ToString("D3"));
                                    }
                                }
                                re.Append("\r\n");
                            }
                            if (method == ExportMethod.Split)
                            {
                                GetRandSeq(seq1, rnd);
                                for (int k = 0; k < kp; ++k)
                                {
                                    if (!select[nout2++]) continue;
                                    re.Append(s.inds[i].name);
                                    if (rep > 1) re.Append("_" + (j + 1));
                                    if (kp > 1) re.Append("_" + (k + 1));
                                    re.Append("\t");
                                    re.Append(s.name);

                                    for (int l = 0; l < L; ++l)
                                    {
                                        GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                        if (gt == null && fillmissing)
                                            gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                        if (gt == null)
                                            re.Append("\t000000");
                                        else
                                        {
                                            re.Append("\t");
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 0]], nullid).ToString("D3"));
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 1]], nullid).ToString("D3"));
                                        }
                                    }
                                    re.Append("\r\n");
                                }
                            }
                            if (method == ExportMethod.Rand)
                            {
                                if (!select[nout2++]) continue;
                                re.Append(s.inds[i].name);
                                if (rep > 1) re.Append("_" + (j + 1));
                                re.Append("\t");
                                re.Append(s.name);

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                    {
                                        re.Append("\t");
                                        for (int m = 0; m < sv; ++m)
                                            re.Append("000");
                                    }
                                    else
                                    {
                                        re.Append("\t");
                                        for (int m = 0; m < sv; ++m)
                                            re.Append(ReplaceNullAllele(gt.alleles2[m], nullid).ToString("D3"));
                                    }
                                }
                                re.Append("\r\n");
                            }
                        }
                    }
                }
                re.Append("//end of file");

                File.WriteAllText(file, re.ToString());
            }

            private void ExportGenepop(ExportMethod method, bool fillmissing, int rep, int nullid, string file, int seed, int maxn)
            {
                /*
                >nul
                loc1
                loc2
                pop
                id, 001001 000 000
                id, 001001 000 000
                */

                StringBuilder re = new StringBuilder();

                Random rnd = new Random(seed);

                for (int l = 0; l < L; ++l)
                {
                    re.Append("\r\n");
                    re.Append(total_pop.loc[l].name);
                }
                re.Append("\r\n");

                foreach (SUBPOP s in subpops)
                {
                    re.Append("pop\r\n");
                    IND[][] indlist = null;
                    if (fillmissing)
                    {
                        indlist = new IND[L][];
                        for (int l = 0; l < L; ++l)
                            indlist[l] = s.inds.Where(i => i.g[l].genotypes.Length > 0).ToArray();
                    }
                    int[,] seq1 = new int[L, s.ploidy];
                    int sv = (method == ExportMethod.Split || method == ExportMethod.Truncate) ? 2 : s.ploidy;
                    int kp = s.ploidy / 2;

                    int nout1 = s.inds.Length * rep * (method == ExportMethod.Split ? kp : 1);
                    bool[] select = new bool[nout1];
                    int[] seq2 = new int[nout1];
                    GetRandSeq(seq2, rnd);
                    for (int i = 0; i < Math.Min(maxn, nout1); ++i)
                        select[seq2[i]] = true;

                    for (int i = 0, nout2 = 0; i < s.inds.Length; ++i)
                    {
                        for (int j = 0; j < rep; ++j)
                        {
                            if (method == ExportMethod.Truncate)
                            {
                                if (!select[nout2++]) continue;
                                GetRandSeq(seq1, rnd);
                                re.Append(s.inds[i].name);
                                if (rep > 1) re.Append("_" + (j + 1));
                                re.Append(",");

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                        re.Append(" 000000");
                                    else
                                    {
                                        re.Append(" ");
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 0]], nullid).ToString("D3"));
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 1]], nullid).ToString("D3"));
                                    }
                                }
                                re.Append("\r\n");
                            }
                            if (method == ExportMethod.Split)
                            {
                                GetRandSeq(seq1, rnd);
                                for (int k = 0; k < kp; ++k)
                                {
                                    if (!select[nout2++]) continue;
                                    re.Append(s.inds[i].name);
                                    if (rep > 1) re.Append("_" + (j + 1));
                                    if (kp > 1) re.Append("_" + (k + 1));
                                    re.Append(",");

                                    for (int l = 0; l < L; ++l)
                                    {
                                        GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                        if (gt == null && fillmissing)
                                            gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                        if (gt == null)
                                            re.Append(" 000000");
                                        else
                                        {
                                            re.Append(" ");
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 0]], nullid).ToString("D3"));
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 1]], nullid).ToString("D3"));
                                        }
                                    }
                                    re.Append("\r\n");
                                }
                            }
                            if (method == ExportMethod.Rand)
                            {
                                if (!select[nout2++]) continue;
                                re.Append(s.inds[i].name);
                                if (rep > 1) re.Append("_" + (j + 1));
                                re.Append(",");

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                    {
                                        re.Append(" ");
                                        for (int m = 0; m < sv; ++m)
                                            re.Append("000");
                                    }
                                    else
                                    {
                                        re.Append(" ");
                                        for (int m = 0; m < sv; ++m)
                                            re.Append(ReplaceNullAllele(gt.alleles2[m], nullid).ToString("D3"));
                                    }
                                }
                                re.Append("\r\n");
                            }
                        }
                    }
                }

                File.WriteAllText(file, re.ToString());
            }

            private void ExportSpagedi(ExportMethod method, bool fillmissing, int rep, int nullid, string file, int seed, int maxn)
            {
                /*
//#individuals	#categories	#coordinates	#loci	#digits/allele	#max ploidy
200	4	0	20	1	4
-3
ID	Pop	Loc1	Loc2	Loc3	Loc4	Loc5	Loc6	Loc7	Loc8	Loc9	Loc10	Loc11	Loc12	Loc13	Loc14	Loc15	Loc16	
END
*/
                StringBuilder re = new StringBuilder(), header = new StringBuilder();
                Random rnd = new Random(seed);

                re.Append("ID\tPop");
                for (int l = 0; l < L; ++l)
                {
                    re.Append("\t");
                    re.Append(total_pop.loc[l].name);
                }
                re.Append("\r\n");

                int ntot = 0;
                foreach (SUBPOP s in subpops)
                {
                    IND[][] indlist = null;
                    if (fillmissing)
                    {
                        indlist = new IND[L][];
                        for (int l = 0; l < L; ++l)
                            indlist[l] = s.inds.Where(i => i.g[l].genotypes.Length > 0).ToArray();
                    }
                    int[,] seq1 = new int[L, s.ploidy];
                    int sv = (method == ExportMethod.Split || method == ExportMethod.Truncate) ? 2 : s.ploidy;
                    int kp = s.ploidy / 2;

                    int nout1 = s.inds.Length * rep * (method == ExportMethod.Split ? kp : 1);
                    bool[] select = new bool[nout1];
                    int[] seq2 = new int[nout1];
                    GetRandSeq(seq2, rnd);
                    for (int i = 0; i < Math.Min(maxn, nout1); ++i)
                        select[seq2[i]] = true;

                    for (int i = 0, nout2 = 0; i < s.inds.Length; ++i)
                    {
                        for (int j = 0; j < rep; ++j)
                        {
                            if (method == ExportMethod.Truncate)
                            {
                                if (!select[nout2++]) continue;
                                GetRandSeq(seq1, rnd);
                                re.Append(s.inds[i].name);
                                if (rep > 1) re.Append("_" + (j + 1));
                                re.Append("\t");
                                re.Append(s.name);

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                        re.Append("\t000000");
                                    else
                                    {
                                        re.Append("\t");
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 0]], nullid).ToString("D3"));
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 1]], nullid).ToString("D3"));
                                    }
                                }
                                re.Append("\r\n");
                                ntot++;
                            }
                            if (method == ExportMethod.Split)
                            {
                                GetRandSeq(seq1, rnd);
                                for (int k = 0; k < kp; ++k)
                                {
                                    if (!select[nout2++]) continue;
                                    re.Append(s.inds[i].name);
                                    if (rep > 1) re.Append("_" + (j + 1));
                                    if (kp > 1) re.Append("_" + (k + 1));
                                    re.Append("\t");
                                    re.Append(s.name);

                                    for (int l = 0; l < L; ++l)
                                    {
                                        GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                        if (gt == null && fillmissing)
                                            gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                        if (gt == null)
                                            re.Append("\t000000");
                                        else
                                        {
                                            re.Append("\t");
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 0]], nullid).ToString("D3"));
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 1]], nullid).ToString("D3"));
                                        }
                                    }
                                    re.Append("\r\n");
                                    ntot++;
                                }
                            }
                            if (method == ExportMethod.Rand)
                            {
                                if (!select[nout2++]) continue;
                                re.Append(s.inds[i].name);
                                if (rep > 1) re.Append("_" + (j + 1));
                                re.Append("\t");
                                re.Append(s.name);

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                    {
                                        re.Append("\t");
                                        for (int m = 0; m < sv; ++m)
                                            re.Append("000");
                                    }
                                    else
                                    {
                                        re.Append("\t");
                                        for (int m = 0; m < sv; ++m)
                                            re.Append(ReplaceNullAllele(gt.alleles2[m], nullid).ToString("D3"));
                                    }
                                }
                                re.Append("\r\n");
                                ntot++;
                            }
                        }
                    }
                }

                header.Append("//#individuals	#categories	#coordinates	#loci	#digits/allele	#max ploidy\r\n");
                header.Append(ntot + "\t" + subpops.Length + "\t" + 0 + "\t" + L + "\t" + 3 + "\t" + subpops.Max(i => i.ploidy) + "\r\n");
                header.Append("-3\r\n");
                header.Append(re);
                header.Append("END");

                File.WriteAllText(file, header.ToString());
            }

            private void ExportGenodive(ExportMethod method, bool fillmissing, int rep, int nullid, string file, int seed, int maxn)
            {
                /*
Data from 
463	16	7	4	2	region
Pop001	cluster1
Pop002	cluster1
Population	Individual	
*/
                StringBuilder re = new StringBuilder(), header = new StringBuilder();
                Random rnd = new Random(seed);

                re.Append("Population\tIndividual");
                for (int l = 0; l < L; ++l)
                {
                    re.Append("\t");
                    re.Append(total_pop.loc[l].name);
                }

                int ntot = 0;
                for (int si = 0; si < subpops.Length; ++si)
                {
                    SUBPOP s = subpops[si];
                    IND[][] indlist = null;
                    if (fillmissing)
                    {
                        indlist = new IND[L][];
                        for (int l = 0; l < L; ++l)
                            indlist[l] = s.inds.Where(i => i.g[l].genotypes.Length > 0).ToArray();
                    }
                    int[,] seq1 = new int[L, s.ploidy];
                    int sv = (method == ExportMethod.Split || method == ExportMethod.Truncate) ? 2 : s.ploidy;
                    int kp = s.ploidy / 2;

                    int nout1 = s.inds.Length * rep * (method == ExportMethod.Split ? kp : 1);
                    bool[] select = new bool[nout1];
                    int[] seq2 = new int[nout1];
                    GetRandSeq(seq2, rnd);
                    for (int i = 0; i < Math.Min(maxn, nout1); ++i)
                        select[seq2[i]] = true;

                    for (int i = 0, nout2 = 0; i < s.inds.Length; ++i)
                    {
                        for (int j = 0; j < rep; ++j)
                        {
                            if (method == ExportMethod.Truncate)
                            {
                                if (!select[nout2++]) continue;
                                re.Append("\r\n");
                                GetRandSeq(seq1, rnd);
                                re.Append((si + 1).ToString());
                                re.Append("\t");
                                re.Append(s.inds[i].name);
                                if (rep > 1) re.Append("_" + (j + 1));

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                        re.Append("\t000000");
                                    else
                                    {
                                        re.Append("\t");
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 0]], nullid).ToString("D3"));
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 1]], nullid).ToString("D3"));
                                    }
                                }
                                ntot++;
                            }
                            if (method == ExportMethod.Split)
                            {
                                GetRandSeq(seq1, rnd);
                                for (int k = 0; k < kp; ++k)
                                {
                                    if (!select[nout2++]) continue;
                                    re.Append("\r\n");
                                    re.Append((si + 1).ToString());
                                    re.Append("\t");
                                    re.Append(s.inds[i].name);
                                    if (rep > 1) re.Append("_" + (j + 1));
                                    if (kp > 1) re.Append("_" + (k + 1));

                                    for (int l = 0; l < L; ++l)
                                    {
                                        GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                        if (gt == null && fillmissing)
                                            gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                        if (gt == null)
                                            re.Append("\t000000");
                                        else
                                        {
                                            re.Append("\t");
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 0]], nullid).ToString("D3"));
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 1]], nullid).ToString("D3"));
                                        }
                                    }
                                    ntot++;
                                }
                            }
                            if (method == ExportMethod.Rand)
                            {
                                if (!select[nout2++]) continue;
                                re.Append("\r\n");
                                re.Append((si + 1).ToString());
                                re.Append("\t");
                                re.Append(s.inds[i].name);
                                if (rep > 1) re.Append("_" + (j + 1));

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                    {
                                        re.Append("\t");
                                        for (int m = 0; m < sv; ++m)
                                            re.Append("000");
                                    }
                                    else
                                    {
                                        re.Append("\t");
                                        for (int m = 0; m < sv; ++m)
                                            re.Append(ReplaceNullAllele(gt.alleles2[m], nullid).ToString("D3"));
                                    }
                                }
                                ntot++;
                            }
                        }
                    }
                }

                header.Append("\r\n");
                header.Append(ntot + "\t" + subpops.Length + "\t" + L + "\t" + subpops.Max(s => s.ploidy) + "\t3\r\n");
                for (int si = 0; si < subpops.Length; ++si)
                {
                    SUBPOP s = subpops[si];
                    header.Append(s.name + "\r\n");
                }
                header.Append(re);
                File.WriteAllText(file, header.ToString());
            }

            private void ExportMigrate(ExportMethod method, bool fillmissing, int rep, int nullid, string file, int seed, int maxn)
            {
                /*
                2 3 . //2 pops, 3 loci, deliminator
                2 Riedtli//ninds  popname
                0 6.5 37.31 18.18
                0 6.6 37.33 18.16
                2 Tal//ninds  popname
                1 4.5 35.? 18.18
                1 4.4 35.31 20.18
                */
                StringBuilder re = new StringBuilder();
                Random rnd = new Random(seed);

                re.Append(subpops.Length + " " + L + " . ");
                for (int l = 0; l < L; ++l)
                {
                    re.Append(" ");
                    re.Append(total_pop.loc[l].name);
                }
                re.Append("\r\n");

                int ntot = 0;
                foreach (SUBPOP s in subpops)
                {
                    IND[][] indlist = null;
                    if (fillmissing)
                    {
                        indlist = new IND[L][];
                        for (int l = 0; l < L; ++l)
                            indlist[l] = s.inds.Where(i => i.g[l].genotypes.Length > 0).ToArray();
                    }
                    int[,] seq1 = new int[L, s.ploidy];
                    int sv = (method == ExportMethod.Split || method == ExportMethod.Truncate) ? 2 : s.ploidy;
                    int kp = s.ploidy / 2;

                    int nout1 = s.inds.Length * rep * (method == ExportMethod.Split ? kp : 1);
                    bool[] select = new bool[nout1];
                    int[] seq2 = new int[nout1];
                    GetRandSeq(seq2, rnd);
                    for (int i = 0; i < Math.Min(maxn, nout1); ++i)
                        select[seq2[i]] = true;

                    re.Append(Math.Min(maxn, nout1) + " " + s.name + "\r\n");
                    for (int i = 0, nout2 = 0; i < s.inds.Length; ++i)
                    {
                        for (int j = 0; j < rep; ++j)
                        {
                            if (method == ExportMethod.Truncate)
                            {
                                if (!select[nout2++]) continue;
                                GetRandSeq(seq1, rnd);
                                re.Append(s.inds[i].name);
                                if (rep > 1) re.Append("_" + (j + 1));

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                        re.Append(" ?.?");
                                    else
                                    {
                                        re.Append(" ");
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 0]], nullid).ToString("D3"));
                                        re.Append(".");
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 1]], nullid).ToString("D3"));
                                    }
                                }
                                re.Append("\r\n");
                                ntot++;
                            }
                            if (method == ExportMethod.Split)
                            {
                                GetRandSeq(seq1, rnd);
                                for (int k = 0; k < kp; ++k)
                                {
                                    if (!select[nout2++]) continue;
                                    re.Append(s.inds[i].name);
                                    if (rep > 1) re.Append("_" + (j + 1));
                                    if (kp > 1) re.Append("_" + (k + 1));

                                    for (int l = 0; l < L; ++l)
                                    {
                                        GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                        if (gt == null && fillmissing)
                                            gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                        if (gt == null)
                                            re.Append(" ?.?");
                                        else
                                        {
                                            re.Append(" ");
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 0]], nullid).ToString("D3"));
                                            re.Append(".");
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 1]], nullid).ToString("D3"));
                                        }
                                    }
                                    re.Append("\r\n");
                                    ntot++;
                                }
                            }
                            if (method == ExportMethod.Rand)
                            {
                                if (!select[nout2++]) continue;
                                re.Append(s.inds[i].name);
                                if (rep > 1) re.Append("_" + (j + 1));

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                    {
                                        re.Append(" ");
                                        for (int m = 0; m < sv - 1; ++m)
                                            re.Append("?.");
                                        re.Append("?");
                                    }
                                    else
                                    {
                                        re.Append(" ");
                                        for (int m = 0; m < sv - 1; ++m)
                                        {
                                            re.Append(ReplaceNullAllele(gt.alleles2[m], nullid).ToString("D3"));
                                            re.Append(".");
                                        }
                                        re.Append(ReplaceNullAllele(gt.alleles2[sv - 1], nullid).ToString("D3"));
                                    }
                                }
                                re.Append("\r\n");
                                ntot++;
                            }
                        }
                    }
                }

                File.WriteAllText(file, re.ToString());
            }

            private void ExportBayesAss(ExportMethod method, bool fillmissing, int rep, int nullid, string file, int seed, int maxn)
            {
                StringBuilder re = new StringBuilder();

                Random rnd = new Random(seed);

                foreach (SUBPOP s in subpops)
                {
                    IND[][] indlist = null;
                    if (fillmissing)
                    {
                        indlist = new IND[L][];
                        for (int l = 0; l < L; ++l)
                            indlist[l] = s.inds.Where(i => i.g[l].genotypes.Length > 0).ToArray();
                    }
                    int[,] seq1 = new int[L, s.ploidy];
                    int sv = (method == ExportMethod.Split || method == ExportMethod.Truncate) ? 2 : s.ploidy;
                    int kp = s.ploidy / 2;

                    int nout1 = s.inds.Length * rep * (method == ExportMethod.Split ? kp : 1);
                    bool[] select = new bool[nout1];
                    int[] seq2 = new int[nout1];
                    GetRandSeq(seq2, rnd);
                    for (int i = 0; i < Math.Min(maxn, nout1); ++i)
                        select[seq2[i]] = true;

                    for (int i = 0, nout2 = 0; i < s.inds.Length; ++i)
                    {
                        for (int j = 0; j < rep; ++j)
                        {
                            if (method == ExportMethod.Truncate)
                            {
                                if (!select[nout2++]) continue;
                                GetRandSeq(seq1, rnd);

                                for (int l = 0; l < L; ++l)
                                {
                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    re.Append(s.inds[i].name);
                                    if (rep > 1) re.Append("_" + (j + 1));
                                    re.Append(" ");
                                    re.Append(s.name);
                                    re.Append(" ");
                                    re.Append(total_pop.loc[l].name);

                                    if (gt == null)
                                        re.Append(" 0 0\r\n");
                                    else
                                    {
                                        re.Append(" ");
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 0]], nullid));
                                        re.Append(" ");
                                        re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, 1]], nullid));
                                        re.Append("\r\n");
                                    }
                                }
                            }
                            if (method == ExportMethod.Split)
                            {
                                GetRandSeq(seq1, rnd);
                                for (int k = 0; k < kp; ++k)
                                {
                                    if (!select[nout2++]) continue;

                                    for (int l = 0; l < L; ++l)
                                    {
                                        re.Append(s.inds[i].name);
                                        if (rep > 1) re.Append("_" + (j + 1));
                                        if (kp > 1) re.Append("_" + (k + 1));
                                        re.Append(" ");
                                        re.Append(s.name);
                                        re.Append(" ");
                                        re.Append(total_pop.loc[l].name);

                                        GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                        if (gt == null && fillmissing)
                                            gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                        if (gt == null)
                                            re.Append(" 0 0\r\n");
                                        else
                                        {
                                            re.Append(" ");
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 0]], nullid));
                                            re.Append(" ");
                                            re.Append(ReplaceNullAllele(gt.alleles2[seq1[l, k * 2 + 1]], nullid));
                                            re.Append("\r\n");
                                        }
                                    }
                                }
                            }
                            if (method == ExportMethod.Rand)
                            {
                                if (!select[nout2++]) continue;

                                for (int l = 0; l < L; ++l)
                                {
                                    re.Append(s.inds[i].name);
                                    if (rep > 1) re.Append("_" + (j + 1));
                                    re.Append(" ");
                                    re.Append(s.name);
                                    re.Append(" ");
                                    re.Append(total_pop.loc[l].name);

                                    GENOTYPE gt = s.inds[i].g[l].GetRandomGenotype(rnd);
                                    if (gt == null && fillmissing)
                                        gt = indlist[l][rnd.Next(indlist[l].Length)].g[l].GetRandomGenotype(rnd);

                                    if (gt == null)
                                        re.Append(" 0 0\r\n");
                                    else
                                    {
                                        for (int m = 0; m < sv - 1; ++m)
                                        {
                                            re.Append(" ");
                                            re.Append(ReplaceNullAllele(gt.alleles2[m], nullid));
                                        }
                                        re.Append("\r\n");
                                    }
                                }
                            }
                        }
                    }
                }

                File.WriteAllText(file, re.ToString());
            }
            #endregion 

            #region MISC

            public void Increment()
            {
                Interlocked.Increment(ref ProgressValue);
            }

            public void Increment(int val)
            {
                Interlocked.Add(ref ProgressValue, val);
            }


            public IND CreateInd(Random rnd, int ploidy)
            {
                //parentage analysis simulations
                IND tind = new IND(L);
                tind.ploidy = ploidy;
                for (int l = 0; l < L; ++l)
                    tind.g[l] = total_pop.loc[l].CreatePhenotype(rnd, ploidy, l);
                return tind;
            }

            public void GetObsPheno(Random rnd, IND A, bool mistype)
            {
                //parentage analysis simulation
                for (int l = 0; l < L; ++l)
                {
                    //mistype
                    PHENOTYPE ph = A.g[l];

                    if (mistype && rnd.NextDouble() < PARENTAGE_MISTYPE_RATE)
                        ph = total_pop.loc[l].CreatePhenotype(rnd, A.ploidy, l);

                    //py
                    if (!ISGENOTYPE)
                        ph.body.alleles = ph.body.alleles.Where(a => a != NULL_ALLELE).ToArray();

                    //missing
                    if (rnd.NextDouble() < total_pop.loc[l].beta)
                        ph.body.alleles = new int[0];

                    //hash
                    ph.body.GetHash();

                    if (!total_pop.phenotype[l].ContainsKey(ph.hash))
                    {
                        ph = new PHENOTYPE(ph.ploidy, ph.alleles, true);
                        ph.GetGenotypes();
                        total_pop.phenotype[l][ph.hash] = ph;
                    }
                    else
                        ph = total_pop.phenotype[l][ph.hash];

                    A.g[l] = ph;
                }

                if (A != null)
                    for (int l = 0; l < L; ++l)
                        total_pop.GetGenoPoster(A.g[l], l);

                A.GetGametes(gametebodydict);
            }

            public void UnifyPop(LOC[] locs)
            {
                L = locs.Length;
                for (int l = 0; l < L; ++l)
                    Unify(locs[l].freq);
            }

            public string FindPopInRegion(string popname)
            {
                foreach (var r in regiontextdict[0])
                    if (r.Value.Contains(popname))
                        return r.Key;
                return regiontextdict.Count == 1 ? "Total" : "DefRegLevel1";
            }

            public string FindRegionInRegion(string regname, int rl)
            {
                if (rl == regiontextdict.Count) return "Total";
                foreach (var r in regiontextdict[rl])
                    if (r.Value.Contains(regname))
                        return r.Key;
                return regiontextdict.Count == rl ? "Total" : "DefRegLevel" + (rl + 1);
            }

            public bool Prepare(string[,] b, int nthreads)
            {
                if (b == null) return false;

                ISGENOTYPE = (FORMAT != InputFormat.Phenotype) && !REMOVE_DUP_ALLELE;

                if (all == this && ISGENOTYPE)//OK
                {
                    if (REMIND_WARNING && !ShowMessage3Buttons("Because inputting data are genotypes, the subsequent analyses would be performed based on genotypes. The null allele and the negative ampliciation are incompatiable and are disabled. Use 'remove duplicated alleles' option to convert genotypic data into phenotypic data. "))
                        return false;
                    CONSIDER_NULL = false;
                    CONSIDER_NEGATIVE = false;
                }

                //Init parameters
                int m = b.GetLength(0), n = b.GetLength(1), genotype_colid = -1;
                if (m <= 1) return ShowErrorMessage("Input phenotypes/genotypes is empty.", "Error", false);

                //Scan coordinate and quantitative names
                {
                    List<string> coordinate_name2 = new List<string>();
                    List<string> quantitative_name2 = new List<string>();
                    for (int col = 3; col < n; ++col)
                    {
                        if (b[0, col].Length >= 3 && b[0, col].Substring(0, 3) == "[C]")
                        {
                            if (coordinate_name2.Contains(b[0, col].Substring(3)))
                                return ShowErrorMessage("Duplicated coordinate identifier: " + b[0, col] + ".", "Error", false);
                            coordinate_name2.Add(b[0, col].Substring(3));
                        }
                        else if (b[0, col].Length >= 3 && b[0, col].Substring(0, 3) == "[Q]")
                        {
                            if (quantitative_name2.Contains(b[0, col].Substring(3)))
                                return ShowErrorMessage("Duplicated quantitative trait identifier: " + b[0, col] + ".", "Error", false);
                            quantitative_name2.Add(b[0, col].Substring(3));
                        }
                        else if (genotype_colid == -1)
                            genotype_colid = col;
                    }
                    coordinate_name = coordinate_name2.ToArray();
                    quantitative_name = quantitative_name2.ToArray();
                    ncoordinate = coordinate_name.Length;
                    nquantitative = quantitative_name.Length;
                }

                //Calculate number of loci
                {
                    L = FORMAT == InputFormat.Genotype1DNoTab ?
                        b[0, genotype_colid].Count(c => c == ',') + 1 :
                        n - 3 - coordinate_name.Length - quantitative_name.Length;

                    if (L < 1 || L > MAX_LOCI)
                        return ShowErrorMessage("Number of loci out of range [1," + MAX_LOCI + "].", "Error", false);

                    if (m - 1 > MAX_INDS)
                        return ShowErrorMessage("Number of individuals out of range [1," + MAX_INDS + "]", "Error", false);
                }

                //Parse region definition
                {
                    string[] tregiontext = REGIONTEXT.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
                    regiontextdict.Add(new Dictionary<string, List<string>>());
                    for (int tsc = 0, trl = 0; tsc < tregiontext.Length; ++tsc)
                    {
                        //add region text
                        string ts = tregiontext[tsc];
                        if (ts.ToLower() == "nextlevel")
                        {
                            trl++;
                            regiontextdict.Add(new Dictionary<string, List<string>>());
                            continue;
                        }
                        var tlist = ts.Split(new string[] { " , ", ", ", " ,", ",", " : ", ": ", " :", ":" }, StringSplitOptions.RemoveEmptyEntries).ToList();
                        var tname = tlist[0];
                        tlist.RemoveAt(0);
                        regiontextdict[trl][tname] = tlist;
                    }

                    for (int rl = 0; rl < regiontextdict.Count; ++rl)
                        foreach (var j in regiontextdict[rl])
                            for (int k = 0; k < j.Value.Count; ++k)
                            {
                                string popname = j.Value[k];
                                for (int i = k + 1; i < j.Value.Count; ++i)
                                    if (popname == j.Value[i])
                                        return ShowErrorMessage("Replicate population/region identifiers '" + popname + "' are found at region " + j.Key + " in the region definition text (in AMOVA configurations).", "Error", false);

                                for (int rl2 = 0; rl2 < regiontextdict.Count; ++rl2)
                                    foreach (var i in regiontextdict[rl2])
                                        if ((rl != rl2 || i.Key != j.Key) && i.Value.Contains(popname))
                                            return ShowErrorMessage("Replicate population identifiers '" + popname + "' are found at regions " + i.Key + " and " + j.Key + " in the region definition text (in AMOVA configurations).", "Error", false);
                            }
                }

                //Check input data
                {
                    Dictionary<string, int> tpopnames = new Dictionary<string, int>();
                    Dictionary<string, int> tpopdefreg = new Dictionary<string, int>();
                    Dictionary<string, int> tindnames = new Dictionary<string, int>();

                    bool flag = true;
                    StringBuilder sb1 = new StringBuilder();
                    StringBuilder sb2 = new StringBuilder();
                    StringBuilder sb3 = new StringBuilder();
                    StringBuilder sb4 = new StringBuilder();

                    Parallel.For(1, m, new ParallelOptions() { MaxDegreeOfParallelism = nthreads }, i =>
                    //for (int i = 1; i < m; ++i)
                    {
                        if (b[i, 0] == "")
                        {
                            sb1.Append((i + 1).ToString() + ",");
                            flag = false;
                        }
                        if (b[i, 1] == "")
                        {
                            sb2.Append((i + 1).ToString() + ",");
                            flag = false;
                        }
                        if (b[i, 2] == "")
                        {
                            sb3.Append((i + 1).ToString() + ",");
                            flag = false;
                        }
                        lock (tindnames)
                        {
                            if (tindnames.ContainsKey(b[i, 0]))
                            {
                                sb4.Append((i + 1).ToString() + ":" + b[i, 0] + ",");
                                flag = false;
                            }
                            tindnames[b[i, 0]] = 0;
                            tpopnames[b[i, 1]] = 0;
                            if (FindPopInRegion(b[i, 1]) == "DefRegL1")
                                tpopdefreg[b[i, 1]] = 0;
                        }
                    });

                    if (!flag && sb1.Length > 0) ShowErrorMessage("The individual identifier at lines " + sb1.ToString().TrimEnd(new char[] { ',' }) + " is empty.", "Error", 0);
                    if (!flag && sb2.Length > 0) ShowErrorMessage("The population identifier at lines " + sb2.ToString().TrimEnd(new char[] { ',' }) + " is empty.", "Error", 0);
                    if (!flag && sb3.Length > 0) ShowErrorMessage("The ploidy at lines " + sb3.ToString().TrimEnd(new char[] { ',' }) + " is empty.", "Error", 0);
                    if (!flag && sb4.Length > 0) ShowErrorMessage("Replicate individual identifier at lines " + sb4.ToString().TrimEnd(new char[] { ',' }) + " found.", "Error", 0);
                    if (!flag) return false;

                    if (all == this && REMIND_WARNING && tpopdefreg.Count > 0)
                    {
                        StringBuilder s = new StringBuilder();
                        foreach (string st in tpopdefreg.Keys)
                            s.Append(st + " ");
                        if (!ShowMessage3Buttons("These populations are not present in the region definition text (in AMOVA configurations): " + s.ToString() + ". \r\nThey will be assigned to a default region."))
                            return false;
                    }
                }

                //Add locus name and id
                LOC[] loclist = new LOC[L];
                {
                    if (FORMAT == InputFormat.Genotype1DNoTab)
                    {
                        string[] nlname = b[0, genotype_colid].Split(new char[] { ',' }, StringSplitOptions.None);
                        for (int l = 0; l < L; ++l)
                            loclist[l] = new LOC(nlname[l], l);
                    }
                    else
                    {
                        for (int col = 3, l = 0; col < n; ++col)
                        {
                            if (b[0, col].Length >= 3 && (b[0, col].Substring(0, 3) == "[C]" || b[0, col].Substring(0, 3) == "[Q]")) continue;
                            loclist[l] = new LOC(b[0, col], l);
                            l++;
                        }
                    }
                }

                //Add pops
                {
                    Dictionary<string, int> tpops = new Dictionary<string, int>();
                    for (int i = 1; i < m; ++i)
                        tpops[b[i, 1]] = 1;
                    subpops = new SUBPOP[tpops.Count];
                }

                //Add individuals
                {
                    Progress = "Loading Individuals";
                    ProgressValue = 0;
                    ProgressMax = m;
                    if (all == this) SetProgress(ProgressValue, ProgressMax);

                    regiondict.Add(new Dictionary<string, SUBPOP>());
                    phenobodydict = new ConcurrentDictionary<uint, PHENOBODY>[MAX_PLOIDY + 1, L];

                    for (int l = 0; l < L; ++l)
                        for (int v = 1; v <= MAX_PLOIDY; ++v)
                            phenobodydict[v, l] = new ConcurrentDictionary<uint, PHENOBODY>();

                    bool flag = true;
                    int crow = 1;
                    inds = new IND[m - 1];
                    Parallel.For(1, m, new ParallelOptions() { MaxDegreeOfParallelism = nthreads }, i =>
                    //for (int i = 1; i < m; ++i)
                    {
                        if (flag)
                        {
                            int row = 0;
                            lock (this)
                            {
                                row = crow++;
                            }
                            if (!AddInds(b, row, n, genotype_colid, loclist))
                                flag = false;
                            Increment();
                        }
                    });
                    if (!flag) return false;
                }

                //Sort inds and pops
                {
                    n = inds.Length;
                    Array.Sort(inds, (x, y) => x.id.CompareTo(y.id));
                    foreach (SUBPOP tp in inds.Select(i => i.subpop).Distinct())
                    {
                        tp.inds = (from i in inds where i.subpop == tp orderby i.id select i).ToArray();
                        tp.n = tp.inds.Length;
                        tp.id = tp.inds.Min(i => i.id);
                    }

                    Array.Sort(subpops, (x, y) => x.id.CompareTo(y.id));
                    for (int i = 0; i < subpops.Length; ++i)
                        subpops[i].id = i;
                }

                //Calculate centroid of coordinates
                foreach (SUBPOP s in subpops)
                {
                    s.coordinate = new double[ncoordinate];
                    if (ncoordinate == 0) continue;
                    var t = s.inds.Where(i => !double.IsNaN(i.coordinate[0]));
                    if (ncoordinate == 2 && SPATIAL_HAVERSINE && Array.TrueForAll(s.inds, i => Math.Abs(i.coordinate[1]) > 150))
                    {
                        s.coordinate[0] = t.Average(i => i.coordinate[0]);
                        s.coordinate[1] = t.Average(i => i.coordinate[0] % 360);
                        s.coordinate[1] = s.coordinate[1] > 180 ? s.coordinate[1] - 360 : s.coordinate[1];
                    }
                    else for (int c = 0; c < ncoordinate; ++c)
                            s.coordinate[c] = t.Average(i => i.coordinate[c]);
                }

                b = null; //release memory
                GC.Collect();

                //Establish region structure
                if (regiondict[regiondict.Count - 1].Count > 1)
                {
                    regiondict.Add(new Dictionary<string, SUBPOP>());
                    SUBPOP tot = regiondict[regiondict.Count - 1]["Total"] = new SUBPOP(this);
                    tot.parent = this;
                    tot.name = "Total";
                    tot.L = L;
                    tot.id = 0;
                    tot.subpops = regiondict[regiondict.Count - 2].Values.ToArray();
                    Array.ForEach(tot.subpops, s => s.region = tot);
                }
                else
                {
                    SUBPOP tot = regiondict[regiondict.Count - 1].Values.ToList()[0];
                    if (regiondict.Count == 1 && regiondict[0].Count == 1 && tot.subpops.Length == 1)
                    {
                        //tot = pop
                        SUBPOP pop = subpops[0];
                        pop.subpops = new SUBPOP[0];
                        regiondict[0].Clear();
                        regiondict[0][pop.name] = pop;
                    }
                    else
                        tot.name = "Total";
                }

                //Check popname
                {
                    int rl = 0;
                    foreach (var r in regiontextdict[rl])
                    {
                        if (r.Value.Count == 0) continue;
                        foreach (string rname in r.Value)
                            if (subpops.Count(o => rname == o.name) == 0)
                                return ShowErrorMessage("Population " + rname + " in the region definition box (in AMOVA settings) is not present in the phenotype data. Please delete it first. ", "Error", false);
                    }
                }

                //Check regname
                {
                    for (int rl = 1; rl < regiontextdict.Count; ++rl)
                        foreach (var r in regiontextdict[rl])
                            foreach (string rname in r.Value)
                                if (!regiondict[rl - 1].ContainsKey(rname))
                                    return ShowErrorMessage("Region " + rname + " in the region definition box (in AMOVA settings) is not present in the phenotype data. Please delete it first. ", "Error", false);
                }

                regions = new SUBPOP[regiondict.Count][];
                for (int rl = 0; rl < regiondict.Count; ++rl)
                    regions[rl] = regiondict[rl].Values.ToArray();
                region_count = regions.Sum(r => r.Length > 1 ? r.Length : 0);
                region_dyad_count = regions.Sum(r => r.Length > 1 ? r.Length * (r.Length - 1) / 2 : 0);
                total_pop = regions[regions.Length - 1][0];
                total_pop.region = null;

                if (subpops.Length == 1)
                {
                    total_pop = subpops[0];
                    total_pop.region = null;
                    total_pop.subpops = new SUBPOP[0];
                    region_count = region_dyad_count = 0;
                    regions = new SUBPOP[0][];
                }

                if (all == this && CALC_PARENTAGE && subpops.Length > 1 && REMIND_WARNING &&
                    !ShowMessage3Buttons("Multiple populations found in data, the allele frequency in the total population will be used in the parentage analysis."))
                    return false;

                //Check parameter configurations
                if (all == this && CALC_PARENTAGE)
                {
                    if (subpops.Length > 1)
                        return ShowErrorMessage("Parentage analysis supports only one population. ", "Error", false);

                    if (subpops[0].ploidy % 2 == 1)
                        return ShowErrorMessage("Parentage analysis supports only even ploidy levels.", "Error", false);

                    int c1 = 0;
                    if (PARENTAGE_PATERNITY)
                    {
                        foreach (var a1 in PATERNITY_OFFSPRING)
                        {
                            int c2 = 0;
                            var a2s = a1.Split(new char[] { '\t', ',' }, StringSplitOptions.None);
                            for (int j = 0; j < a2s.Length; ++j)
                            {
                                if (!indsdict.ContainsKey(a2s[j]) && (j == 0 && a2s[j] == "" || j == 2 && a2s[j] == ""))
                                    return ShowErrorMessage("Individual '" + a2s[j] + "' in paternity analysis's offspring input at row " + (c1 + 1) + " column " + (c2 + 1) + " does not exist in the phenotype data.", "Error", false);
                                c2++;
                            }
                            c1++;
                        }
                    }

                    if (PARENTAGE_PARENTPAIR)
                    {
                        c1 = 0;
                        foreach (var a1 in PARENTPAIR_OFFSPRING)
                        {
                            if (!indsdict.ContainsKey(a1))
                                return ShowErrorMessage("Individual '" + a1 + "' in parent pair analysis's offspring file at row " + (c1 + 1) + " does not exist in the phenotype data.", "Error", false);
                            c1++;
                        }

                        c1 = 0;
                        foreach (var a1 in PARENTPAIR_FATHER)
                        {
                            if (!indsdict.ContainsKey(a1))
                                return ShowErrorMessage("Individual '" + a1 + "' in parent pair analysis's father input at row " + (c1 + 1) + " does not exist in the phenotype data.", "Error", false);
                            c1++;
                        }

                        c1 = 0;
                        foreach (var a1 in PARENTPAIR_MOTHER)
                        {
                            if (!indsdict.ContainsKey(a1))
                                return ShowErrorMessage("Individual '" + a1 + "' in paternity analysis mother file at row " + (c1 + 1) + " does not exist in the phenotype data.", "Error", false);
                            c1++;
                        }
                    }

                    if (PARENTAGE_UNKNOWN)
                    {
                        c1 = 0;
                        foreach (var a1 in UNKNOWN_OFFSPRING)
                        {
                            if (!indsdict.ContainsKey(a1))
                                return ShowErrorMessage("Individual '" + a1 + "' in paternity analysis (unknown sexes) offspring file at row " + (c1 + 1) + " does not exist in the phenotype data.", "Error", false);
                            c1++;
                        }

                        c1 = 0;
                        foreach (var a1 in UNKNOWN_PARENT)
                        {
                            if (!indsdict.ContainsKey(a1))
                                return ShowErrorMessage("Individual '" + a1 + "' in paternity analysis (unknown sexes) parent file at row " + (c1 + 1) + " does not exist in the phenotype data.", "Error", false);
                            c1++;
                        }
                    }
                }

                foreach (LOC l in loclist)
                    if (l.freq.Count > MAX_ALLELES)
                        return ShowErrorMessage("Number of alleles exceed " + MAX_ALLELES + ". At " + l.name + ".", "Error", false);

                //get init allele frequency
                if (!GetAlpha(loclist))
                    return false;

                UnifyPop(loclist);
                if (CONSIDER_NULL)
                {
                    for (int l = 0; l < L; ++l)
                        loclist[l].freq[NULL_ALLELE] = NULL_FREQUENCY / (1 - NULL_FREQUENCY);
                    UnifyPop(loclist);
                }

                Array.Sort(total_pop.subpops, (x, y) => x.id.CompareTo(y.id));
                nhaplotypes = subpops.Sum(tp => tp.nhaplotypes);

                //init pop allele freq and haplotype count
                foreach (SUBPOP tp in subpops)
                {
                    tp.n = tp.inds.Length;
                    tp.loc = new LOC[L];
                    for (int l = 0; l < L; ++l)
                    {
                        tp.loc[l] = new LOC(loclist[l], false);
                        tp.loc[l].beta = CONSIDER_NEGATIVE ? 0.05 : 0;
                        tp.loc[l].s = CONSIDER_SELFING ? 0.05 : 0;
                        tp.loc[l].nhaplotypes = tp.inds.Sum(i => i.g[l].hash != 0 ? i.ploidy : 0);
                        tp.loc[l].nphenotypes = tp.inds.Sum(i => i.g[l].hash != 0 ? 1 : 0);
                    }
                    tp.nhaplotypes = tp.inds.Length * tp.ploidy;
                }

                //init region allele freq and haplotype count
                for (int rl = 0; rl < regions.Length; ++rl)
                    foreach (SUBPOP tr in regions[rl])
                    {
                        Array.Sort(tr.subpops, (x, y) => x.id.CompareTo(y.id));

                        tr.loc = new LOC[L];
                        for (int l = 0; l < L; ++l)
                            tr.loc[l] = new LOC(loclist[l], false);

                        tr.inds = (from SUBPOP p in tr.subpops from IND i in p.inds orderby i.id select i).ToArray();
                        tr.ploidy = tr.subpops.Length > 0 && tr.subpops.Min(s => s.ploidy) == tr.subpops.Max(s => s.ploidy) ? tr.subpops[0].ploidy : 0;
                        tr.n = tr.inds.Length;
                        tr.nhaplotypes = tr.subpops.Sum(s => s.nhaplotypes);
                        for (int l = 0; l < L; ++l)
                        {
                            tr.loc[l].nphenotypes = tr.subpops.Sum(s => s.loc[l].nphenotypes);
                            tr.loc[l].nhaplotypes = tr.subpops.Sum(s => s.loc[l].nhaplotypes);
                        }
                    }

                Progress = "Process phenotypes";
                if (all == this)
                {
                    ProgressValue = 0;
                    ProgressMax = L;
                    SetProgress(ProgressValue, ProgressMax);
                }
                else
                {
                    ProgressValue = 0;
                    ProgressMax = L;
                }

                //genotype inds and add to cgem of subpop
                Parallel.For(0, L, new ParallelOptions() { MaxDegreeOfParallelism = nthreads }, l =>
                //for (int l = 0; l < L; ++l)
                {
                    for (int pl = 1; pl <= MAX_PLOIDY; ++pl)
                        foreach (PHENOBODY ph in phenobodydict[pl, l].Values)
                            ph.GetGenotypes();

                    foreach (SUBPOP tp in subpops)
                        foreach (PHENOTYPE ph in tp.phenotype[l].Values)
                            ph.GetGenotypes();

                    Increment();
                });


                //Check parameter conflicts
                {
                    if (all == this && CALC_STRUCTURE && STRUCTURE_FMODEL && STRUCTURE_DIFFLAMBDA && REMIND_WARNING &&
                        !ShowMessage3Buttons("In structure analysis, F model does not support different lambda in different clusters, and the Diff lambda is disabled."))
                        return false;

                    if (all == this && CALC_BAYESASS)
                    {
                        switch (BAYESASS_TYPE)
                        {
                            case BayesAssType.FixedDummy:
                            case BayesAssType.VariableDummy:
                                if (subpops.Count(s => s.ploidy <= 1) > 0)
                                    return ShowErrorMessage("In BayesAss analysis, dummy diploid genotypes can not be extracted from haploids. ", "Error", false);
                                break;
                            case BayesAssType.FixedGenotype:
                            case BayesAssType.VariableGenotype:
                            case BayesAssType.Phenotype:
                                if (subpops.Count(s => s.ploidy % 2 == 1) > 0)
                                    return ShowErrorMessage("In BayesAss analysis, genotype and phenotype method does not support odd ploidy levels. Please use dummy genotype methods.", "Error", false);
                                break;
                        }
                    }
                }

                return true;
            }

            public bool AddInds(string[,] b, int row, int ncols, int genotype_colid, LOC[] loclist)
            {
                //add individual from input data
                IND tind = new IND(L);
                tind.id = row - 1;
                tind.name = b[row, 0];
                tind.quantitative = nquantitative > 0 ? new double[nquantitative] : null;
                tind.coordinate = ncoordinate > 0 ? new double[ncoordinate] : null;

                if (!int.TryParse(b[row, 2], out tind.ploidy))
                    return ShowErrorMessage("Ploidy level out of range [1," + MAX_PLOIDY + "].\r\nAt individual '" + b[row, 0] + "'.", "Error", false);

                if (tind.ploidy < 1 || tind.ploidy > MAX_PLOIDY)
                    return ShowErrorMessage("Ploidy level out of range [1," + MAX_PLOIDY + "].\r\nAt individual '" + b[row, 0] + "'.", "Error", false);

                lock (subpopsdict)
                {
                    if (!subpopsdict.ContainsKey(b[row, 1]))//thread-safe
                    {
                        //add new pop
                        SUBPOP tp = new SUBPOP(this);
                        subpopsdict[b[row, 1]] = subpops[subpopsdict.Count] = tp;
                        string rname = FindPopInRegion(b[row, 1]);

                        //add new reg
                        bool update = false;
                        if (!regiondict[0].ContainsKey(rname))
                        {
                            SUBPOP tr = regiondict[0][rname] = new SUBPOP(this);
                            tr.name = rname;
                            tr.id = regiondict[0].Count - 1;
                            tr.L = L;
                            tr.subpops = new SUBPOP[] { tp };
                            update = true;
                        }
                        tp.name = b[row, 1];
                        tp.ploidy = int.Parse(b[row, 2]);
                        tp.id = subpops.Length - 1;
                        tp.L = L;
                        tp.phenotype = new Dictionary<uint, PHENOTYPE>[L];
                        for (int l = 0; l < L; ++l)
                            tp.phenotype[l] = new Dictionary<uint, PHENOTYPE>();
                        tp.region = regiondict[0][rname];

                        if (!tp.region.subpops.Contains(tp))
                        {
                            Array.Resize(ref tp.region.subpops, tp.region.subpops.Length + 1);
                            tp.region.subpops[tp.region.subpops.Length - 1] = tp;
                        }

                        for (int rl = 1; update && rl < regiontextdict.Count; ++rl)
                        {
                            tp = tp.region;
                            rname = FindRegionInRegion(tp.name, rl);

                            //add new higher level reg list
                            if (regiondict.Count <= rl)
                                regiondict.Add(new Dictionary<string, SUBPOP>());

                            //add new higher level reg
                            if (!regiondict[rl].ContainsKey(rname))
                            {
                                SUBPOP tr = regiondict[rl][rname] = new SUBPOP(this);
                                tr.name = rname;
                                tr.L = L;
                                tr.id = regiondict[rl].Count - 1;
                                tr.subpops = new SUBPOP[] { tp };
                            }

                            tp.region = regiondict[rl][rname];
                            tp.L = L;
                            if (!tp.region.subpops.Contains(tp))
                            {
                                Array.Resize(ref tp.region.subpops, tp.region.subpops.Length + 1);
                                tp.region.subpops[tp.region.subpops.Length - 1] = tp;
                            }
                        }
                    }
                }

                SUBPOP pop = subpopsdict[b[row, 1]];
                if (int.Parse(b[row, 2]) != pop.ploidy)
                    return ShowErrorMessage("The ploidy of '" + tind.name + "' does not meet with the other individiuals within the same population.", "Error", false);

                if (FORMAT == InputFormat.Genotype1DNoTab && L != b[row, genotype_colid].Length)
                    return ShowErrorMessage("Error one-digit genotype format observed in individual " + tind.name + ".\r\nData: " + b[row, genotype_colid], "Error", false);

                tind.name = b[row, 0];
                for (int lid = -1, qid = 0, cid = 0, col = 3; col < ncols; ++col)
                {
                    if (ncoordinate > 0 && b[0, col].Length >= 3 && b[0, col].Substring(0, 3) == "[C]")
                    {
                        if (b[row, col] == "") tind.coordinate[cid] = double.NaN;
                        else if (!double.TryParse(b[row, col], out tind.coordinate[cid]))
                            return ShowErrorMessage("Cannot recognize coordinate '" + b[row, col] + "', it should be a real number. \r\nAt individual '" + tind.name + "'.\r\nData: " + b[row, col], "Error", false);
                        cid++;
                        continue;
                    }

                    if (nquantitative > 0 && b[0, col].Length >= 3 && b[0, col].Substring(0, 3) == "[Q]")
                    {
                        if (b[row, col] == "") tind.quantitative[qid] = double.NaN;
                        else if (!double.TryParse(b[row, col], out tind.quantitative[qid]))
                            return ShowErrorMessage("Cannot recognize quantitative trait value '" + b[row, col] + "', it should be a real number. \r\nAt individual '" + tind.name + "'.\r\nData: " + b[row, col], "Error", false);
                        qid++;
                        continue;
                    }

                    if (++lid == L) break;
                    List<int> als = new List<int>();
                    string[] allele_array = null;

                    switch (FORMAT)
                    {
                        default:
                        case InputFormat.Genotype:
                        case InputFormat.Phenotype:
                            allele_array = b[row, col].Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                            break;
                        case InputFormat.Genotype1D:
                            allele_array = new string[] { b[row, col] };
                            break;
                        case InputFormat.Genotype1DNoTab:
                            allele_array = new string[] { b[row, genotype_colid][lid].ToString() };
                            break;
                    }

                    if (FORMAT == InputFormat.Genotype1D)
                    {
                        if (allele_array[0] == "" || allele_array[0] == " ")
                            allele_array = new string[0];
                        else
                        {
                            if (allele_array[0].Length > 1)
                                return ShowErrorMessage("Error one-digit genotype format observed at locus " + loclist[lid].name + " of individual " + tind.name + ".\r\nData: " + b[row, col], "Error", false);

                            int al = -1;
                            int.TryParse(allele_array[0], out al);
                            al = allele_array[0] == "A" || allele_array[0] == "a" ? 10 : al;
                            if (al < 0 || al > tind.ploidy)
                                return ShowErrorMessage("Cannot recognize alleles '" + allele_array[0] + "', it should be an integer. \r\nAt individual '" + tind.name + "'.\r\nData: " + b[row, col], "Error", false);

                            allele_array = new string[tind.ploidy];
                            for (int i = 0; i < tind.ploidy; ++i)
                                allele_array[i] = i < al ? "1" : "2";
                        }
                    }
                    else if (FORMAT == InputFormat.Genotype1DNoTab)
                    {
                        if (allele_array[0] == " ")
                            allele_array = new string[0];
                        else
                        {
                            int al = -1;
                            int.TryParse(allele_array[0], out al);
                            al = allele_array[0] == "A" || allele_array[0] == "a" ? 10 : al;
                            if (al < 0 || al > tind.ploidy)
                                return ShowErrorMessage("Cannot recognize alleles '" + allele_array[0] + "', it should be an integer. \r\nAt individual '" + tind.name + "'.\r\nData: " + b[row, col], "Error", false);

                            allele_array = new string[tind.ploidy];
                            for (int i = 0; i < tind.ploidy; ++i)
                                allele_array[i] = i < al ? "1" : "2";
                        }
                    }

                    if (FORMAT >= InputFormat.Genotype && allele_array.Length != 0 && allele_array.Length != tind.ploidy)
                        return ShowErrorMessage("Error genotype format at locus " + loclist[lid].name + " of individual " + tind.name + ".\r\nData: " + b[row, col], "Error", false);

                    if (allele_array.Length > tind.ploidy)
                        return ShowErrorMessage("Allele dosage exceeds the ploidy level at locus " + loclist[lid].name + " of individual " + tind.name + ".\r\nData: " + b[row, col], "Error", false);

                    //remove replicate alleles
                    if (FORMAT == InputFormat.Phenotype || REMOVE_DUP_ALLELE)
                    {
                        int n1 = allele_array.Length;
                        allele_array = allele_array.Distinct().ToArray();
                        if (n1 != allele_array.Length && FORMAT == InputFormat.Phenotype && REMIND_WARNING && !ShowMessage3Buttons("Duplicated alleles at locus " + loclist[lid].name + " of individual " + tind.name + ".\r\nData: " + b[row, col]))
                            return false;
                    }

                    for (int j = 0; j < allele_array.Length; ++j)
                    {
                        int al = 0;

                        if (!int.TryParse(allele_array[j], out al))
                            return ShowErrorMessage("Cannot parse allele '" + allele_array[j] + "', it should be an integer. \r\nAt individual '" + tind.name + "'.\r\nData: " + b[row, col], "Error", false);

                        if (al > MAX_ALLELESID || al < 0)
                            return ShowErrorMessage("Allele idendifier out of range, it should between 0 and " + MAX_ALLELESID + ". \r\nAt individual '" + tind.name + "'.\r\nData: " + b[row, col], "Error", false);

                        if (al == NULL_ALLELE)
                            return ShowErrorMessage("Null alleles observed in the genotype/phenotype. \r\nAt individual '" + tind.name + "'.\r\nData: " + b[row, col], "Error", false);

                        als.Add(al);

                        lock (loclist[lid].freq)
                        {
                            if (!loclist[lid].freq.ContainsKey(al))
                                loclist[lid].freq[al] = 1.0 / allele_array.Length;
                            else
                                loclist[lid].freq[al] += 1.0 / allele_array.Length;
                        }
                    }

                    als.Sort();

                    uint hash = HashPhenotype(tind.ploidy, als);

                    PHENOTYPE ph = null;
                    lock (phenobodydict[tind.ploidy, lid])
                    {
                        if (!pop.phenotype[lid].ContainsKey(hash))
                        {
                            PHENOBODY gbd = null;
                            if (!phenobodydict[tind.ploidy, lid].ContainsKey(hash))
                                phenobodydict[tind.ploidy, lid][hash] = gbd = new PHENOBODY(tind.ploidy, als.ToArray(), false);
                            else
                                gbd = phenobodydict[tind.ploidy, lid][hash];

                            pop.phenotype[lid][hash] = ph = new PHENOTYPE(gbd);
                        }
                        else
                            ph = pop.phenotype[lid][hash];
                    }

                    Interlocked.Increment(ref ph.count);
                    if (ph.hash != 0) Interlocked.Increment(ref nphenotypes);

                    tind.g[lid] = ph;

                    if (FORMAT == InputFormat.Genotype1DNoTab) col--;
                }

                tind.subpop = pop;
                if (tind.coordinate != null && tind.coordinate.Contains(double.NaN))
                    Array.ForEach(tind.coordinate, c => c = double.NaN);

                inds[tind.id] = tind;
                indsdict[tind.name] = tind;

                return true;
            }

            public void SetResText(TextBox tb, string analysis, string file)
            {
                long filelen = GetFileSize(file);
                if (filelen == -1) return;
                SetText(tb, filelen < MAX_OUTPUT ? 
                    File.ReadAllText(file) : 
                    "Can not display results for " + analysis + " because file size > 10Mib, the results have been saved in '.\\Results\\" + file + "'.");
            }

            public void Calc()
            {
                if (File.Exists("o_frequency.txt")) File.Delete("o_frequency.txt");
                if (File.Exists("o_diversity.txt")) File.Delete("o_diversity.txt");
                if (File.Exists("o_distribution.txt")) File.Delete("o_distribution.txt");
                if (File.Exists("o_linkage.txt")) File.Delete("o_linkage.txt");
                if (File.Exists("o_ne.txt")) File.Delete("o_ne.txt");
                if (File.Exists("o_differentation.txt")) File.Delete("o_differentation.txt");
                if (File.Exists("o_distance.txt")) File.Delete("o_distance.txt");
                if (File.Exists("o_ordination.txt")) File.Delete("o_ordination.txt");
                if (File.Exists("o_clustering.txt")) File.Delete("o_clustering.txt");
                if (File.Exists("o_inbreeding.txt")) File.Delete("o_inbreeding.txt");
                if (File.Exists("o_hindex.txt")) File.Delete("o_hindex.txt");
                if (File.Exists("o_assignment.txt")) File.Delete("o_assignment.txt");
                if (File.Exists("o_spatial.txt")) File.Delete("o_spatial.txt");
                if (File.Exists("o_relationship.txt")) File.Delete("o_relationship.txt");
                if (File.Exists("o_heritability.txt")) File.Delete("o_heritability.txt");
                if (File.Exists("o_parentage_simulation.txt")) File.Delete("o_parentage_simulation.txt");
                if (File.Exists("o_parentage_paternity.txt")) File.Delete("o_parentage_paternity.txt");
                if (File.Exists("o_parentage_parentpair.txt")) File.Delete("o_parentage_parentpair.txt");
                if (File.Exists("o_parentage_unknown.txt")) File.Delete("o_parentage_unknown.txt");
                if (File.Exists("o_parentage_error.txt")) File.Delete("o_parentage_error.txt");
                if (File.Exists("o_parentage_sample.txt")) File.Delete("o_parentage_sample.txt");
                if (File.Exists("o_amova.txt")) File.Delete("o_amova.txt");
                if (File.Exists("o_mantel.txt")) File.Delete("o_mantel.txt");

                if (PHENOTYPE_INPUT == "")
                    PHENOTYPE_INPUT = "input.txt";

                if (PHENOTYPE_INPUT.IndexOf("\n") == -1)
                {
                    if (File.Exists(PHENOTYPE_INPUT))
                        PHENOTYPE_INPUT = File.ReadAllText(PHENOTYPE_INPUT);
                    else
                    {
                        ShowErrorMessage("Cannot read input file from the path in the 'phenotypes/genotypes' textbox.", "Error", 0);
                        return;
                    }
                }

                if (!Prepare(StringToMatrix(PHENOTYPE_INPUT), N_THREAD)) return;

                {
                    CalcFrequency(N_THREAD);
                    SetResText(form1.FrequencyResBox, "allele frequency estimation", "o_frequency.txt");
                }

                NULLSQDIST = GetNullSqDist(total_pop.loc);

                if (CALC_PARENTAGE)
                {
                    //prepare individual gametes for parentage analysis
                    gametebodydict = new ConcurrentDictionary<uint, GENOBODY>[MAX_PLOIDY + 1, L];
                    Parallel.For(0, L, new ParallelOptions() { MaxDegreeOfParallelism = N_THREAD }, l =>
                    //for (int l = 0; l < L; ++l)
                    {
                        for (int pl = 1; pl <= MAX_PLOIDY; ++pl)
                        {
                            gametebodydict[pl, l] = new ConcurrentDictionary<uint, GENOBODY>();
                            foreach (PHENOBODY pb in phenobodydict[pl, l].Values)
                                pb.GetGametes(ALPHA[l, pl], gametebodydict[pl, l]);
                        }
                    });

                    foreach (IND ind in inds)
                        ind.GetGametes(gametebodydict);

                    //Rodzen et al. (2004)
                    //prepare dummy dominant allele frequency
                    if (PARENTAGE_METHOD == ParentageMethod.Dominant)
                    {
                        freq_dominant = new Dictionary<int, double>[L];
                        for (int l = 0; l < L; ++l)
                        {
                            freq_dominant[l] = new Dictionary<int, double>();
                            Dictionary<int, double> freq = freq_dominant[l];
                            int nphenotype = 0;
                            foreach (PHENOTYPE ph in total_pop.phenotype[l].Values)
                            {
                                if (ph.hash == 0) continue;
                                nphenotype += ph.count;
                                foreach (int a in ph.alleles.Distinct())
                                {
                                    if (!freq.ContainsKey(a))
                                        freq[a] = 0;
                                    freq[a] += ph.count;
                                }
                            }

                            foreach (int k in freq.Keys.ToArray())
                                freq[k] = 1 - Math.Sqrt(1 - freq[k] / nphenotype);
                        }
                    }
                }

                //Diversity
                {
                    CalcDiversity();
                    SetResText(form1.DiversityResBox, "genetic diversity estimation", "o_diversity.txt");
                }

                if (CALC_SPATIAL || 
                    CALC_RELATIONSHIP && RELATIONSHIP_Hardy1999)
                {
                    //calculate allele freq and squared allele freq
                    foreach (SUBPOP s in subpops)
                        foreach (LOC l in s.loc)
                        {
                            l.freq2 = new Dictionary<int, double>[2];
                            Dictionary<int, double> freq1 = l.freq2[0] = l.freq;
                            Dictionary<int, double> freq2 = l.freq2[1] = new Dictionary<int, double>();
                            foreach (int a in l.freq.Keys)
                                freq2[a] = s.phenotype[l.id].Values.Where(p => p.hash != 0).
                                            Sum(p => p.freq.ContainsKey(a) ? p.count * p.freq[a] * p.freq[a] : 0) / s.loc[l.id].nphenotypes;
                        }

                    for (int rl = 0; rl < regions.Length; ++rl)
                        foreach (SUBPOP tr in regions[rl])
                            foreach (LOC l in tr.loc)
                            {
                                l.freq2 = new Dictionary<int, double>[2];
                                Dictionary<int, double> freq1 = l.freq2[0] = new Dictionary<int, double>();
                                Dictionary<int, double> freq2 = l.freq2[1] = new Dictionary<int, double>();

                                foreach (int a in l.freq.Keys)
                                {
                                    int sw1 = tr.subpops.Sum(s => s.loc[l.id].nphenotypes);
                                    freq1[a] = tr.subpops.Sum(s => s.loc[l.id].freq2[0][a] * s.loc[l.id].nphenotypes) / sw1;
                                    freq2[a] = tr.subpops.Sum(s => s.loc[l.id].freq2[1][a] * s.loc[l.id].nphenotypes) / sw1;
                                }
                            }
                }

                if (CALC_NE && NE_NOMURA2008 ||
                    CALC_DIFF && DIFF_Huang2019 ||
                    CALC_INBREEDING && INBREEDING_HuangUnpub ||
                    CALC_RELATIONSHIP && (RELATIONSHIP_HuangUnpub || RELATIONSHIP_HuangUnpubm) ||
                    CALC_DIST && (DIST_Roger1973 || DIST_Slatkin1995) && DIFF_Huang2019)
                {
                    CalcHomozygosity();
                }

                if (CALC_DISTRIBUTION)
                {
                    if (!CalcDistribution()) return;
                    SetResText(form1.DistributionResBox, "phenotype distribution test", "o_distribution.txt");
                }

                if (CALC_LINKAGE)
                {
                    CalcLinkage();
                    SetResText(form1.LinkageResBox, "linkage disequilibrium test", "o_linkage.txt");
                }

                if (CALC_NE)
                {
                    CalcNe(N_THREAD);
                    if (CALC_NE) SetResText(form1.NeResBox, "effective population size estimation", "o_ne.txt");
                }

                {
                    CalcDiff();  //parallel, genotype3
                    if (CALC_DIFF) SetResText(form1.DiffResBox, "genetic differentiation estimation", "o_differentation.txt");
                }

                if (CALC_DIST)
                {
                    CalcDistance();
                    SetResText(form1.DistResBox, "genetic distance estimation", "o_distance.txt");
                }

                if (CALC_ORDINATION)
                {
                    CalcOrdination();
                    SetResText(form1.OrdinationResBox, "ordination analysis", "o_ordination.txt");
                }

                if (CALC_CLUSTERING)
                {
                    CalcClustering();
                    SetResText(form1.ClusteringResBox, "hierarchical clustering", "o_clustering.txt");
                }

                if (CALC_INBREEDING)
                {
                    CalcInbreeding();
                    SetResText(form1.InbreedingResBox, "individual inbreeding coefficient estimation", "o_inbreeding.txt");
                }

                if (CALC_HINDEX)
                {
                    CalcHIndex();
                    SetResText(form1.HIndexResBox, "individual heterozygosity index estimation", "o_hindex.txt");
                }

                if (CALC_ASSIGNMENT)
                {
                    CalcAssignment(); //parallel, genotype
                    SetResText(form1.AssignmentResBox, "population assignment", "o_assignment.txt");
                }

                if (CALC_SPATIAL)
                {
                    CalcSpatial(); //parallel, genotype
                    SetResText(form1.SpatialResBox, "spatial pattern analysis", "o_spatial.txt");
                }

                if (CALC_RELATIONSHIP)
                {
                    CalcRelationship(); //parallel, genotype
                    SetResText(form1.RelationshipResBox, "relationship coefficient estimation", "o_relationship.txt");
                }

                if (CALC_HERITABILITY)
                {
                    CalcHeritability(); //parallel, genotype
                    SetResText(form1.HeritabilityResBox, "heritability estimation", "o_heritability.txt");
                }

                if (CALC_QST)
                {
                    CalcQst();
                    SetResText(form1.QstResBox, "Qst estimation", "o_qst.txt");
                }

                if (CALC_PARENTAGE)
                {
                    CalcParentage();          //parallel
                    SetResText(form1.ParentageSimResBox, "parentage analysis (simulation)", "o_parentage_simulation.txt");
                    SetResText(form1.ParentagePaternityResBox, "parentage analysis (paternity)", "o_parentage_paternity.txt");
                    SetResText(form1.ParentageParentPairResBox, "parentage analysis (parent pair)", "o_parentage_parentpair.txt");
                    SetResText(form1.ParentageUnknownResBox, "parentage analysis (parent pair with unknown sexes)", "o_parentage_unknown.txt");
                    SetResText(form1.ParentageErrorResBox, "parentage analysis (genotyping erorr rate estimation)", "o_parentage_error.txt");
                    SetResText(form1.ParentageSampleResBox, "parentage analysis (sample rate estimation)", "o_parentage_sample.txt");
                }

                if (CALC_AMOVA)
                {
                    CalcAMOVA();   //parallel
                    SetResText(form1.AMOVAResBox, "AMOVA", "o_amova.txt");
                }

                if (CALC_STRUCTURE)
                {
                    CalcStructure();  //parallel
                }

                if (CALC_BAYESASS)
                {
                    CalcBayesAss();  //parallel
                }

                GC.Collect();
                runstate = GlobalRunState.end;
            }

            #endregion

            #region Frequency

            public static void EMSubSelfing(Point4 xp, object[] par)
            {
                int nthreads = (int)par[0];
                SUBPOP p = (SUBPOP)par[1];
                int L = p.L;

                double s = xp.i2r_selfing(), sli = 0;

                Parallel.For(0, L, new ParallelOptions() { MaxDegreeOfParallelism = nthreads }, l =>
                {
                    p.loc[l].s = s;
                    double li = p.EMSub(l);
                    lock (p)
                    { sli += li; }
                });

                xp.li = sli;
            }

            public void CalcFrequencySelfing(int nthreads)
            {
                foreach (SUBPOP p in subpops)
                {
                    Point4 x = Point4.DownHillSimplex(1, 1, EMSubSelfing, new object[] { nthreads, p });
                    Array.ForEach(p.loc, l => l.s = x.real[0]);
                    Increment();
                }
            }

            public void EMSubPES(Point4 xp, object[] par)
            {
                int l = (int)par[0];
                SUBPOP[] subpops = (SUBPOP[])par[1];

                xp.i2r_selfing();
                total_pop.loc[l].rs = xp.real[0];
                GetAlpha(total_pop.loc, l);
                xp.li = 0;
                foreach (SUBPOP p in subpops)
                    xp.li += p.EMSub(l);
            }

            public void CalcFrequencyPES(int nthreads)
            {
                Parallel.For(0, L, new ParallelOptions() { MaxDegreeOfParallelism = nthreads }, l =>
                {
                    Point4 x = Point4.DownHillSimplex(1, 1, EMSubPES, new object[] { l, subpops });
                    total_pop.loc[l].rs = x.real[0];
                    Array.ForEach(subpops, p => p.loc[l].rs = x.real[0]);
                    Increment();
                });
            }

            public void CalcFrequency(int nthreads)
            {
                GC.Collect();
                Progress = "Estimating allele frequency";

                //Initialize
                if (!CONSIDER_SELFING && DR_MODE != DoubleReductionModel.PESRS)
                {
                    //no selfing, fixed model
                    ProgressValue = 0;
                    ProgressMax = L * subpops.Length;
                    if (all == this)
                        SetProgress(ProgressValue, ProgressMax);

                    var PL = (from SUBPOP p in subpops from LOC l in p.loc select new { pop = p, loc = l }).ToArray();

                    GetAlpha(total_pop.loc);

                    Parallel.ForEach(PL, new ParallelOptions { MaxDegreeOfParallelism = nthreads }, pl =>
                    {
                        pl.loc.s = 0;
                        pl.pop.EMSub(pl.loc.id);
                        Increment();
                    });
                }

                if (DR_MODE != DoubleReductionModel.PESRS && CONSIDER_SELFING)
                {
                    //selfing, fixed model
                    if (SELFING_ESTIMATOR == SelfingRateEstimator.HuangML)
                    {
                        ProgressValue = 0;
                        ProgressMax = subpops.Length;
                        if (all == this) SetProgress(ProgressValue, ProgressMax);
                        CalcFrequencySelfing(nthreads);
                    }
                    else
                    {
                        ProgressValue = 0;
                        ProgressMax = L * subpops.Length;
                        if (all == this)
                            SetProgress(ProgressValue, ProgressMax);

                        GetAlpha(total_pop.loc);

                        var PL = (from SUBPOP p in subpops from LOC l in p.loc select new { pop = p, loc = l }).ToList();

                        foreach (SUBPOP p in subpops)
                            p.s = p.HardySelfingEstimator();

                        Parallel.ForEach(PL, new ParallelOptions { MaxDegreeOfParallelism = nthreads }, pl =>
                        {
                            pl.loc.s = pl.pop.s;
                            pl.pop.EMSub(pl.loc.id);
                            Increment();
                        });
                    }
                }

                if (DR_MODE == DoubleReductionModel.PESRS && !CONSIDER_SELFING)
                {
                    //no selfing, PES + rs model
                    ProgressValue = 0;
                    ProgressMax = L;
                    if (all == this) SetProgress(ProgressValue, ProgressMax);

                    CalcFrequencyPES(nthreads);
                }

                //unify
                for (int l = 0; l < L; ++l)
                {
                    foreach (SUBPOP s in subpops)
                        if (s.loc[l].nhaplotypes == 0)
                            SetVal(s.loc[l].freq, 0);

                    for (int rl = 0; rl < regions.Length; ++rl)
                        foreach (SUBPOP tr in regions[rl])
                            tr.loc[l].Unite(tr.subpops, l);
                }

                int[][] allele = new int[L][];
                StreamWriter wt = new StreamWriter(new FileStream("o_frequency.txt", FileMode.Create, FileAccess.Write), Encoding.Unicode);
                OUTPUT_FREQUENCY = wt;

                int maxk = total_pop.loc.Max(l => l.freq.Count);
                for (int l = 0; l < L; ++l)
                {
                    wt.Write(total_pop.loc[l].name + "\t" + total_pop.loc[l].freq.Count + "\t");
                    allele[l] = total_pop.loc[l].freq.Keys.OrderBy(a => a).ToArray();
                }
                wt.Write("\r\n");

                for (int rl = regions.Length - 1; rl >= 0; --rl)
                    foreach (SUBPOP tr in regions[rl])
                    {
                        wt.Write(tr.name + "\r\n");
                        for (int i = 0; i < maxk; ++i)
                        {
                            for (int l = 0; l < L; ++l)
                                wt.Write(allele[l].Length <= i ? "\t\t" : (allele[l][i] == NULL_ALLELE ? "null" : allele[l][i].ToString()) + "\t" + tr.loc[l].freq[allele[l][i]].ToString(DECIMAL) + "\t");
                            wt.Write("\r\n");
                        }
                    }

                foreach (SUBPOP s in subpops)
                {
                    wt.Write(s.name + "\r\n");
                    if (DR_MODE == DoubleReductionModel.PESRS)
                    {
                        Array.ForEach(total_pop.loc, l => wt.Write("rs\t" + l.rs.ToString(DECIMAL) + "\t"));
                        wt.Write("\r\n");
                    }
                    if (CONSIDER_SELFING)
                    {
                        Array.ForEach(s.loc, l => wt.Write("s\t" + l.s.ToString(DECIMAL) + "\t"));
                        wt.Write("\r\n");
                    }
                    if (CONSIDER_NEGATIVE)
                    {
                        Array.ForEach(s.loc, l => wt.Write("beta\t" + l.beta.ToString(DECIMAL) + "\t"));
                        wt.Write("\r\n");
                    }

                    for (int i = 0; i < maxk; ++i)
                    {
                        for (int l = 0; l < L; ++l)
                            wt.Write(allele[l].Length <= i ? "\t\t" : (allele[l][i] == NULL_ALLELE ? "null" : allele[l][i].ToString()) + "\t" + s.loc[l].freq[allele[l][i]].ToString(DECIMAL) + "\t");
                        wt.Write("\r\n");
                    }
                }

                wt.Flush();
                wt.Close();
            }

            #endregion

            #region Diversity

            private void GetNonExcl(LOC l, ref double ne1p, ref double ne2p, ref double nepp, ref double neid, ref double nesid)
            {
                double a2 = 0, a3 = 0, a4 = 0, a5 = 0, a6 = 0;
                foreach (int i in l.freq.Keys)
                {
                    a2 += l.freq[i] * l.freq[i];
                    a3 += l.freq[i] * l.freq[i] * l.freq[i];
                    a4 += l.freq[i] * l.freq[i] * l.freq[i] * l.freq[i];
                    a5 += l.freq[i] * l.freq[i] * l.freq[i] * l.freq[i] * l.freq[i];
                    a6 += l.freq[i] * l.freq[i] * l.freq[i] * l.freq[i] * l.freq[i] * l.freq[i];
                }

                ne1p = 1 - (1 - 4 * a2 + 2 * a2 * a2 + 4 * a3 - 3 * a4);
                ne2p = 1 - (1 - 2 * a2 * a2 - 2 * a2 + a3 + 3 * a2 * a3 - 3 * a5 + 2 * a4);
                nepp = 1 - (1 + 4 * a4 - 4 * a5 - 3 * a6 - 8 * a2 * a2 + 8 * a2 * a3 + 2 * a3 * a3);
                nesid = 1 - (0.75 - 0.5 * a2 - 0.5 * a2 * a2 + 0.25 * a4);
                neid = 1 - (1 + 3 * a4 - 4 * a2 * a2);
            }

            public void CalcDiversity()
            {
                Progress = "Estimating genetic diversity";

                GC.Collect();
                //k n ho he pic ar fis
                int S = subpops.Length;
                int R = S == 1 ? 0 : region_count + (regions.Length >= 1 ? 1 : 0);

                double[,] K = new double[S + R, L + 1];
                double[,] N = new double[S + R, L + 1];
                double[,] HO = new double[S + R, L + 1];
                double[,] HE = new double[S + R, L + 1];
                double[,] PIC = new double[S + R, L + 1];
                double[,] AE = new double[S + R, L + 1];//Effective number of alleles
                double[,] AR = new double[S + R, L + 1];//Allelic richness
                double[,] I = new double[S + R, L + 1];//Shannon's I
                double[,] NP = new double[S + R, L + 1];//private allele
                double[,] ne1p = new double[S + R, L + 1];
                double[,] ne2p = new double[S + R, L + 1];
                double[,] nepp = new double[S + R, L + 1];
                double[,] neid = new double[S + R, L + 1];
                double[,] nesid = new double[S + R, L + 1];
                double[,,] FIX = new double[regions.Length + 1, S + R, L + 1];
                //SetVal(FIX, 0);

                //Initialize cgem
                for (int rl = 0; rl < regions.Length; ++rl)
                    foreach (SUBPOP tr in regions[rl])
                        tr.phenotype = new Dictionary<uint, PHENOTYPE>[L];

                //V1.2
                //Add up counts for genotypes and phenotypes
                Parallel.For(0, L, new ParallelOptions() { MaxDegreeOfParallelism = N_THREAD }, l =>
                //for (int l = 0; l < L; ++l)
                {
                    //Alloc
                    for (int rl = 0; rl < regions.Length; ++rl)
                        foreach (SUBPOP tr in regions[rl])
                            tr.phenotype[l] = new Dictionary<uint, PHENOTYPE>();

                    foreach (SUBPOP tp in subpops)
                    {
                        //add up phenotypes, copy genotypes
                        foreach (PHENOTYPE ph in tp.phenotype[l].Values)
                        {
                            tp.GetGenoPoster(ph, l);

                            SUBPOP tr = tp.region;
                            while (tr != null)
                            {
                                if (!tr.phenotype[l].ContainsKey(ph.hash))
                                    tr.phenotype[l][ph.hash] = new PHENOTYPE(ph);
                                tr.phenotype[l][ph.hash].count += ph.count;
                                tr = tr.region;
                            }
                        }
                    }

                    //calc genotypes for regions
                    for (int rl = 0; rl < regions.Length; ++rl)
                        foreach (SUBPOP tr in regions[rl])
                            foreach (PHENOTYPE ph in tr.phenotype[l].Values)
                                if (ph.alleles.Length != 0)
                                    tr.GetGenoPoster(ph, l);
                });

                int p = R;
                //each pop
                for (int i = 0; i < S; ++i, ++p)
                {
                    SUBPOP tp = subpops[i];
                    Parallel.For(0, L, new ParallelOptions() { MaxDegreeOfParallelism = N_THREAD }, l =>
                    //for (int l = 0; l < L; ++l)
                    {
                        double s1 = 0, s2 = 0;
                        foreach (int a in tp.loc[l].freq.Keys)
                        {
                            double pr = tp.loc[l].freq[a];
                            if (tp.loc[l].freq[a] > MINALLELEFREQ)
                            {
                                K[p, l]++;
                                HE[p, l] += pr * pr;
                                AE[p, l] += pr * pr;
                                I[p, l] += -pr * Math.Log(pr);
                                s1 += pr * pr;
                                s2 += pr * pr * pr * pr;
                                NP[p, l] += subpops.Count(s => s.loc[l].freq[a] > MINALLELEFREQ) == 1 ? 1 : 0;
                            }
                            else
                            {
                                //not present in this pop
                                AR[p, l] += Math.Pow(1 - total_pop.loc[l].freq[a], tp.loc[l].nhaplotypes);
                            }
                        }
                        AR[p, l] += K[p, l];
                        PIC[p, l] = 1 - s1 - s1 * s1 + s2;

                        foreach (PHENOTYPE ph in tp.phenotype[l].Values)
                        {
                            if (ph.hash == 0) continue;
                            N[p, l] += ph.count;
                            HO[p, l] += ph.count * ph.genotypes.Sum(g => g.poster * g.GetHIndex());
                        }

                        HO[p, l] /= N[p, l];
                        HE[p, l] = 1 - HE[p, l];
                        AE[p, l] = 1 / AE[p, l];
                        FIX[0, p, l] = 1 - HO[p, l] / HE[p, l];
                        GetNonExcl(tp.loc[l], ref ne1p[p, l], ref ne2p[p, l], ref nepp[p, l], ref neid[p, l], ref nesid[p, l]);
                        tp.loc[l].AE = AE[p, l];

                        SUBPOP tr = tp.region;
                        double nho = double.IsNaN(HO[p, l] * N[p, l]) ? 0 : HO[p, l] * N[p, l];
                        for (int clay = 0, offset = R; clay < regions.Length; ++clay)
                        {
                            offset -= regions[clay].Length;
                            HO[offset + tr.id, l] += nho;
                            tr = tr.region;
                        }
                    });
                }

                //region
                p = R - 1;
                for (int rl = 0; rl < regions.Length; ++rl)
                    for (int i = regions[rl].Length - 1; i >= 0; --i, --p)
                    {
                        SUBPOP tr = regions[rl][i];
                        Parallel.For(0, L, new ParallelOptions() { MaxDegreeOfParallelism = N_THREAD }, l =>
                        //for (int l = 0; l < L; ++l)
                        {
                            double s1 = 0, s2 = 0;
                            foreach (int a in tr.loc[l].freq.Keys)
                            {
                                double pr = tr.loc[l].freq[a];
                                if (tr.loc[l].freq[a] > MINALLELEFREQ)
                                {
                                    K[p, l]++;
                                    HE[p, l] += pr * pr;
                                    AE[p, l] += pr * pr;
                                    I[p, l] += -pr * Math.Log(pr);
                                    s1 += pr * pr;
                                    s2 += pr * pr * pr * pr;
                                    NP[p, l] += regions[rl].Count(s => s.loc[l].freq[a] > MINALLELEFREQ) == 1 ? 1 : 0;
                                }
                                else
                                {
                                    //not present in this pop
                                    AR[p, l] += Math.Pow(1 - total_pop.loc[l].freq[a], tr.loc[l].nhaplotypes);
                                }
                            }
                            AR[p, l] += K[p, l];
                            PIC[p, l] = 1 - s1 - s1 * s1 + s2;
                            N[p, l] += tr.phenotype[l].Sum(ph => ph.Key != 0 ? ph.Value.count : 0);
                            HO[p, l] /= N[p, l];
                            HE[p, l] = 1 - HE[p, l];
                            AE[p, l] = 1 / AE[p, l];
                            tr.loc[l].AE = AE[p, l];
                            FIX[0, p, l] = 1 - HO[p, l] / HE[p, l];
                            for (int rl2 = 0; rl2 <= rl; ++rl2)
                            {
                                double tw2 = 0, hs = tr.GetRegionHomozygosity(rl + 1 - rl2, l, ref tw2);
                                FIX[rl2 + 1, p, l] = 1 - (1 - hs / tw2) / HE[p, l];
                            }
                            GetNonExcl(tr.loc[l], ref ne1p[p, l], ref ne2p[p, l], ref nepp[p, l], ref neid[p, l], ref nesid[p, l]);
                        });
                    }

                //each locus
                Parallel.For(0, R + S, new ParallelOptions() { MaxDegreeOfParallelism = N_THREAD }, p2 =>
                //for (p = 0; p < R + S; ++p)
                {
                    ne1p[p2, L] = 1;
                    ne2p[p2, L] = 1;
                    nepp[p2, L] = 1;
                    neid[p2, L] = 1;
                    nesid[p2, L] = 1;
                    int cl = 0;
                    for (int l = 0; l < L; ++l)
                    {
                        if (K[p2, l] == 0) continue;

                        cl++;
                        K[p2, L] += K[p2, l];
                        N[p2, L] += N[p2, l];
                        HO[p2, L] += HO[p2, l];
                        HE[p2, L] += HE[p2, l];
                        PIC[p2, L] += PIC[p2, l];
                        AE[p2, L] += AE[p2, l];
                        AR[p2, L] += AR[p2, l];
                        I[p2, L] += I[p2, l];
                        NP[p2, L] += NP[p2, l];
                        for (int rl = 0; rl <= regions.Length; ++rl)
                            FIX[rl, p2, L] += FIX[rl, p2, l];
                        ne1p[p2, L] *= ne1p[p2, l];
                        ne2p[p2, L] *= ne2p[p2, l];
                        nepp[p2, L] *= nepp[p2, l];
                        neid[p2, L] *= neid[p2, l];
                        nesid[p2, L] *= nesid[p2, l];
                    }
                    K[p2, L] /= cl;
                    N[p2, L] /= cl;
                    HO[p2, L] /= cl;
                    HE[p2, L] /= cl;
                    PIC[p2, L] /= cl;
                    AE[p2, L] /= cl;
                    AR[p2, L] /= cl;
                    I[p2, L] /= cl;
                    NP[p2, L] /= cl;
                    for (int rl = 0; rl <= regions.Length; ++rl)
                        FIX[rl, p2, L] /= cl;
                });

                StreamWriter wt = new StreamWriter(new FileStream("o_diversity.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_DIVERSITY = wt;

                wt.Write("Pop\tPloidy\tLocus\tk\tn\tHo\tHe\tPIC\tAe\tAr\tI\tNP\tNE-1P\tNE-2P\tNE-PP\tNE-I\tNE-SI\tFix\tFsx");
                for (int rl = 1; rl < regions.Length; ++rl)
                    wt.Write("\tFc" + rl + "x");
                wt.Write("\r\n");

                p = 0;
                for (int rl = regions.Length - 1; rl >= 0; --rl)
                    for (int i = 0; i < regions[rl].Length; ++i, ++p)
                    {
                        SUBPOP tr = regions[rl][i];
                        wt.Write(tr.name + "\t" + tr.subpops.Min(s => s.ploidy) + "~" + tr.subpops.Max(s => s.ploidy) + "\tAvg\t" + K[p, L].ToString(DECIMAL) + "\t" + N[p, L].ToString(DECIMAL) + "\t" + HO[p, L].ToString(DECIMAL) + "\t" + HE[p, L].ToString(DECIMAL) + "\t" + PIC[p, L].ToString(DECIMAL) + "\t" + AE[p, L].ToString(DECIMAL) + "\t" + AR[p, L].ToString(DECIMAL) + "\t" + I[p, L].ToString(DECIMAL) + "\t" + NP[p, L].ToString(DECIMAL) + "\t" + ne1p[p, L].ToString(DECIMAL) + "\t" + ne2p[p, L].ToString(DECIMAL) + "\t" + nepp[p, L].ToString(DECIMAL) + "\t" + neid[p, L].ToString(DECIMAL) + "\t" + nesid[p, L].ToString(DECIMAL));
                        for (int rl2 = 0; rl2 < rl + 2; ++rl2)
                            wt.Write("\t" + FIX[rl2, p, L].ToString(DECIMAL));
                        wt.Write("\r\n");
                    }

                for (int i = 0; i < S; ++i, ++p)
                {
                    SUBPOP tp = subpops[i];
                    wt.Write(tp.name + "\t" + tp.ploidy + "\tAvg\t" + K[p, L].ToString(DECIMAL) + "\t" + N[p, L].ToString(DECIMAL) + "\t" + HO[p, L].ToString(DECIMAL) + "\t" + HE[p, L].ToString(DECIMAL) + "\t" + PIC[p, L].ToString(DECIMAL) + "\t" + AE[p, L].ToString(DECIMAL) + "\t" + AR[p, L].ToString(DECIMAL) + "\t" + I[p, L].ToString(DECIMAL) + "\t" + NP[p, L].ToString(DECIMAL) + "\t" + ne1p[p, L].ToString(DECIMAL) + "\t" + ne2p[p, L].ToString(DECIMAL) + "\t" + nepp[p, L].ToString(DECIMAL) + "\t" + neid[p, L].ToString(DECIMAL) + "\t" + nesid[p, L].ToString(DECIMAL) + "\t" + FIX[0, p, L].ToString(DECIMAL) + "\r\n");
                }

                p = 0;
                for (int rl = regions.Length - 1; rl >= 0; --rl)
                    for (int i = 0; i < regions[rl].Length; ++i, ++p)
                    {
                        SUBPOP tr = regions[rl][i];
                        for (int l = 0; l < L; ++l)
                        {
                            wt.Write(tr.name + "\t" + tr.subpops.Min(s => s.ploidy) + "~" + tr.subpops.Max(s => s.ploidy) + "\t" + total_pop.loc[l].name + "\t" + K[p, l] + "\t" + N[p, l] + "\t" + HO[p, l].ToString(DECIMAL) + "\t" + HE[p, l].ToString(DECIMAL) + "\t" + PIC[p, l].ToString(DECIMAL) + "\t" + AE[p, l].ToString(DECIMAL) + "\t" + AR[p, l].ToString(DECIMAL) + "\t" + I[p, l].ToString(DECIMAL) + "\t" + NP[p, l].ToString(DECIMAL) + "\t" + ne1p[p, l].ToString(DECIMAL) + "\t" + ne2p[p, l].ToString(DECIMAL) + "\t" + nepp[p, l].ToString(DECIMAL) + "\t" + neid[p, l].ToString(DECIMAL) + "\t" + nesid[p, l].ToString(DECIMAL));
                            for (int rl2 = 0; rl2 < rl + 2; ++rl2)
                                wt.Write("\t" + FIX[rl2, p, l].ToString(DECIMAL));
                            wt.Write("\r\n");
                        }
                    }

                for (int i = 0; i < S; ++i, ++p)
                {
                    SUBPOP tp = subpops[i];
                    for (int l = 0; l < L; ++l)
                        wt.Write(tp.name + "\t" + tp.ploidy + "\t" + total_pop.loc[l].name + "\t" + K[p, l] + "\t" + N[p, l] + "\t" + HO[p, l].ToString(DECIMAL) + "\t" + HE[p, l].ToString(DECIMAL) + "\t" + PIC[p, l].ToString(DECIMAL) + "\t" + AE[p, l].ToString(DECIMAL) + "\t" + AR[p, l].ToString(DECIMAL) + "\t" + I[p, l].ToString(DECIMAL) + "\t" + NP[p, l].ToString(DECIMAL) + "\t" + ne1p[p, l].ToString(DECIMAL) + "\t" + ne2p[p, l].ToString(DECIMAL) + "\t" + nepp[p, l].ToString(DECIMAL) + "\t" + neid[p, l].ToString(DECIMAL) + "\t" + nesid[p, l].ToString(DECIMAL) + "\t" + FIX[0, p, l].ToString(DECIMAL) + "\r\n");
                }

                wt.Flush();
                wt.Close();
            }

            public void CalcHomozygosity()
            {
                Progress = "Estimating unbiased homozogysity";

                List<SUBPOP> pops = new List<SUBPOP>();
                pops.AddRange(subpops);
                for (int rl = 0; rl < regions.Length; ++rl)
                    pops.AddRange(regions[rl]);

                ProgressValue = 0;
                ProgressMax = pops.Count;
                SetProgress(ProgressValue, ProgressMax);

                Parallel.For(0, pops.Count, new ParallelOptions() { MaxDegreeOfParallelism = N_THREAD }, i =>
                {
                    pops[i].GetMsl();
                    Increment();
                });
            }

            #endregion

            #region Distribution

            public bool CalcDistribution()
            {
                Progress = "Testing phenotype distribution";
                ProgressValue = 0;
                ProgressMax = ((DISTRIBUTION_POP ? subpops.Length : 0) + (DISTRIBUTION_REG && region_count > 0 ? region_count - 1 : 0) + (DISTRIBUTION_TOT ? 1 : 0)) * L;
                SetProgress(ProgressValue, ProgressMax);

                StreamWriter wt = new StreamWriter(new FileStream("o_distribution.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_DISTRIBUTION = wt;

                wt.Write(ISGENOTYPE ? //OK
                    "Genotype distribution test\r\nPop\tLocus\tG\td.f.\tP-val\tFDR-Q\t#Geno\t#Par\tLnL\tAICc\tBIC\r\n" :
                    "Allelic phenotype distribution test\r\nPop\tLocus\tG\td.f.\tP-val\tFDR-Q\t#Pheno\t#Par\tLnL\tAICc\tBIC\r\n");

                double tot_li = 0, tot_npar = 0, tot_aicc = 0, tot_bic = 0, tot_ntypes = 0;

                if (DISTRIBUTION_TOT)
                {
                    if (subpops.Count(s => s.ploidy != subpops[0].ploidy) == 0)
                        total_pop.DistributionTest(wt, ref tot_ntypes);
                    else if (REMIND_WARNING && !ShowMessage3Buttons("Distribution test is not performed for the total population, because the ploidy levels are varying among populations."))
                        return false;
                }

                if (DISTRIBUTION_REG)
                {
                    for (int rl = 0; rl < regions.Length - 1; ++rl)
                        foreach (SUBPOP tr in regions[rl])
                        {
                            if (tr.ploidy > 0)
                                tr.DistributionTest(wt, ref tot_ntypes);
                            else if (REMIND_WARNING && !ShowMessage3Buttons("Distribution test is not performed for " + tr.name + ", because the ploidy levels are different among populations in this region."))
                                return false;
                        }
                }

                if (DISTRIBUTION_POP)
                {
                    tot_ntypes = 0;
                    foreach (SUBPOP tp in subpops)
                    {
                        tot_li += tp.DistributionTest(wt, ref tot_ntypes);
                        tot_npar += tp.loc.Sum(l => l.freq.Count(f => f.Value > MINALLELEFREQ && f.Key != NULL_ALLELE)) - 1 +
                           (CONSIDER_SELFING ? 1 : 0) +
                           (CONSIDER_NEGATIVE ? 1 : 0) * L +
                           (CONSIDER_NULL ? 1 : 0) * L;
                    }
                    tot_npar += (DR_MODE == DoubleReductionModel.PESRS ? 1 : 0) * L;
                    tot_aicc = 2 * tot_npar - 2 * tot_li + 2 * tot_npar * (tot_npar + 1) / (tot_ntypes - tot_npar - 1);
                    tot_bic = -2 * tot_li + tot_npar * Math.Log(tot_ntypes);
                }

                wt.Write("Total likelihood: " + tot_li.ToString(DECIMAL) + "\r\n" +
                    "Total #par: " + tot_npar.ToString("F0") + "\r\n" +
                    "Total #genotypes/phenotypes: " + tot_ntypes.ToString("F0") + "\r\n" +
                    "Total AICc: " + tot_aicc.ToString(DECIMAL) + "\r\n" +
                    "Total BIC: " + tot_bic.ToString(DECIMAL) + "\r\n");

                modelteststr =
                    tot_li.ToString(DECIMAL) + "\t" +
                    tot_npar.ToString(DECIMAL) + "\t" +
                    tot_ntypes.ToString(DECIMAL) + "\t" +
                    tot_aicc.ToString(DECIMAL) + "\t" +
                    tot_bic.ToString(DECIMAL) + "\r\n";

                wt.Write("\r\n");
                wt.Flush();
                wt.Close();
                return true;
            }

            #endregion

            #region Linkage

            public static void BurrowDelta(bool istable, ref double[,] Dobs, ref double[,] Dexp, ref double Dr2a, ref double Dr2b, ref double df, IND[] inds, SUBPOP pop, int l1, int l2)
            {
                //Burrows's Delta test
                LOC loc1 = pop.loc[l1], loc2 = pop.loc[l2];

                double[,] G = new double[MAX_PLOIDY + 1, MAX_PLOIDY + 1];
                Dictionary<int, double> pAA = CloneKey(loc1.freq), pBB = CloneKey(loc2.freq);
                Dictionary<int, double> fre1 = CloneKey(loc1.freq), fre2 = CloneKey(loc2.freq);

                //obtain subpops
                SUBPOP[] subpops = pop.inds.Select(i => i.subpop).Distinct().ToArray();

                //recalculate allele frequency from individuals with both types
                double fre1w = 0, fre2w = 0, wpair = 0, sv2 = 0;
                foreach (SUBPOP subpop in subpops)
                {
                    Dictionary<uint, int> type1 = new Dictionary<uint, int>(), type2 = new Dictionary<uint, int>();
                    foreach (IND ind in subpop.inds)
                    {
                        uint ha1 = ind.g[l1].hash, ha2 = ind.g[l2].hash;
                        if (ha1 == 0 || ha2 == 0) continue;
                        if (!type1.ContainsKey(ha1)) type1[ha1] = 0;
                        if (!type2.ContainsKey(ha2)) type2[ha2] = 0;
                        type1[ha1]++;
                        type2[ha2]++;
                    }

                    foreach (var type in type1)
                    {
                        int count = type.Value;
                        PHENOTYPE ph = subpop.phenotype[l1][type.Key];
                        AddMul(fre1, ph.freq, count * ph.ploidy);
                        fre1w += count * ph.ploidy;

                        wpair += count * BINOMIAL[ph.ploidy, 2];
                        sv2 += count * ph.ploidy * ph.ploidy;
                        foreach (GENOTYPE gh in ph.genotypes)
                            foreach (var a in gh.alleles)
                                pAA[a.Key] += BINOMIAL[a.Value, 2] * gh.poster * count;
                    }

                    foreach (var type in type2)
                    {
                        int count = type.Value;
                        PHENOTYPE ph = subpop.phenotype[l2][type.Key];
                        AddMul(fre2, ph.freq, type.Value * ph.ploidy);
                        fre2w += type.Value * ph.ploidy;

                        foreach (GENOTYPE gh in ph.genotypes)
                            foreach (var a in gh.alleles)
                                pBB[a.Key] += BINOMIAL[a.Value, 2] * gh.poster * count;
                    }
                }

                Mul(fre1, fre1, 1.0 / fre1w);
                Mul(fre2, fre2, 1.0 / fre2w);

                if (wpair == 0)
                {
                    Mul(pAA, fre1, fre1);
                    Mul(pBB, fre2, fre2);
                }
                else
                {
                    Mul(pAA, pAA, 1.0 / wpair);
                    Mul(pBB, pBB, 1.0 / wpair);
                }

                int k1 = fre1.Count(f => f.Value > MINALLELEFREQ), k2 = fre2.Count(f => f.Value > MINALLELEFREQ);
                df = (k1 - 1) * (k2 - 1);

                if (istable)
                {
                    Dobs = new double[k1, k2];
                    Dexp = new double[k1, k2];
                }

                IND[] tinds = inds.Where(i => i.g[l1].hash != 0 && i.g[l2].hash != 0).ToArray();
                int iA = 0, iB = 0;
                double r2a = 0, r2b = 0;
                foreach (int A in fre1.Keys)
                {
                    double p = fre1[A];
                    if (p < MINALLELEFREQ) continue;
                    iB = 0;
                    foreach (int B in loc2.freq.Keys)
                    {
                        double q = fre2[B], DAB = 0, nhaplo = 0;
                        if (q < MINALLELEFREQ) continue;

                        for (int v = 1; v <= MAX_PLOIDY; ++v)
                        {
                            SetVal(G, 0);
                            int n = 0, h = 0;
                            foreach (IND ind in tinds)
                            {
                                if (ind.ploidy != v) continue;
                                n++;
                                if (ind.g[l1].alleles.Contains(A) && ind.g[l2].alleles.Contains(B))
                                    foreach (GENOTYPE g1 in ind.g[l1].genotypes)
                                        foreach (GENOTYPE g2 in ind.g[l2].genotypes)
                                            G[g1.alleles[A], g2.alleles[B]] += g1.poster * g2.poster;
                            }
                            if (n == 0) continue;

                            //unify two locus unphased genotypic frequency
                            Mul(G, G, 1.0 / n);

                            h = v * n;
                            double Dab = -p * q * v;
                            for (int i = 1; i <= v; ++i)
                                for (int j = 1; j <= v; ++j)
                                    Dab += i * j * G[i, j] / v;

                            DAB += h * Dab;
                            nhaplo += h;
                        }

                        double ntilde = nhaplo * nhaplo / sv2, vtilde = sv2 / nhaplo;
                        //DAB = ntilde / (ntilde - 1) * DAB / nhaplo;//Waples 2006 bias correction, removed on 2021/4/14
                        DAB = DAB / nhaplo;
                        if (istable)
                        {
                            Dobs[iA, iB] = sv2 * p * q + nhaplo * DAB;
                            Dexp[iA, iB] = sv2 * p * q;
                        }
                        double R = (p * (1 - p) + (vtilde - 1) * (pAA[A] - p * p)) * (q * (1 - q) + (vtilde - 1) * (pBB[B] - q * q));//weight 
                        r2a += DAB * DAB;
                        r2b += R;//England 2006
                        iB++;
                    }
                    iA++;
                }
                Dr2a += r2a;
                Dr2b += r2b;
            }

            public class LS
            {
                public int id;
                public double count;

                public LS(int id2)
                {
                    id = id2;
                    count = 0;
                }
            }

            public void LinkageTestThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                IND[] inds = (IND[])((object[])obj)[2];
                double[] GP = (double[])((object[])obj)[3];
                double[] G = (double[])((object[])obj)[4];
                double[] df = (double[])((object[])obj)[5];
                double[] P2 = (double[])((object[])obj)[6];
                double[] SE = (double[])((object[])obj)[7];
                int[] switches = (int[])((object[])obj)[8];

                double[] DG = (double[])((object[])obj)[9];
                double[] Ddf = (double[])((object[])obj)[10];
                double[] DP = (double[])((object[])obj)[11];
                double[] DP2 = (double[])((object[])obj)[12];
                double[] DSE = (double[])((object[])obj)[13];
                int[] Dswitches = (int[])((object[])obj)[14];
                double[] DR2a = (double[])((object[])obj)[15];
                double[] DR2b = (double[])((object[])obj)[16];
                SUBPOP pop = (SUBPOP)((object[])obj)[17];


                for (int l1 = 0, c = 0; l1 < L; ++l1)
                {
                    for (int l2 = l1 + 1; l2 < L; ++l2)
                    {
                        if (c % nthreads != id)
                        {
                            c++;
                            continue;
                        }

                        if (pop.loc[l1].nhaplotypes == 0 || pop.loc[l2].nhaplotypes == 0 ||
                            pop.inds.Count(i => i.g[l1].hash != 0 && i.g[l2].hash != 0) == 0)
                        {
                            GP[c] = G[c] = df[c] = P2[c] = SE[c] = DG[c] = Ddf[c] = DP[c] = DP2[c] = DSE[c] = DR2a[c] = DR2b[c] = double.NaN;
                            c++;
                            Increment();
                            continue;
                        }


                        Random rnd = new Random(SEED ^ (c + 0x47D80FCC));//bug fixed on 20220324
                        Dictionary<ulong, double> table = new Dictionary<ulong, double>();
                        Dictionary<uint, LS> c1 = new Dictionary<uint, LS>(), c2 = new Dictionary<uint, LS>();
                        double[,] Dobs = null, Dexp = null; double tdf = 0;

                        BurrowDelta(true, ref Dobs, ref Dexp, ref DR2a[c], ref DR2b[c], ref tdf, inds, pop, l1, l2);
                        CombineTable(Dobs, Dexp, ref Ddf[c], ref DG[c], ref DP[c], ref DP2[c], LINKAGE_RAYMOND,
                            rnd, ref DSE[c], ref Dswitches[c], LINKAGE_BURNIN, LINKAGE_BATCHES, LINKAGE_ITERATIONS);//OK

                        if (pop.ploidy > 0)
                        {
                            int nt = 0;
                            if (!ISGENOTYPE)//OK
                                foreach (IND ind in inds)
                                {
                                    uint ha1 = ind.g[l1].hash, ha2 = ind.g[l2].hash;
                                    if (ha1 == 0 || ha2 == 0) continue;
                                    ulong ha = (((ulong)ha1) << 32) | ((ulong)ha2);
                                    if (!c1.ContainsKey(ha1)) c1[ha1] = new LS(c1.Count);
                                    if (!c2.ContainsKey(ha2)) c2[ha2] = new LS(c2.Count);
                                    if (!table.ContainsKey(ha)) table[ha] = 0;
                                    c1[ha1].count++;
                                    c2[ha2].count++;
                                    table[ha]++;
                                    nt++;
                                }
                            else
                                foreach (IND ind in inds)
                                {
                                    foreach (GENOTYPE g1 in ind.g[l1].genotypes)
                                        foreach (GENOTYPE g2 in ind.g[l2].genotypes)
                                        {
                                            uint ha1 = g1.hash, ha2 = g2.hash;
                                            ulong ha = (((ulong)ha1) << 32) | ((ulong)ha2);
                                            if (!c1.ContainsKey(ha1)) c1[ha1] = new LS(c1.Count);
                                            if (!c2.ContainsKey(ha2)) c2[ha2] = new LS(c2.Count);
                                            if (!table.ContainsKey(ha)) table[ha] = 0;
                                            double pr = g1.poster * g2.poster;
                                            c1[ha1].count += pr;
                                            c2[ha2].count += pr;
                                            table[ha] += pr;
                                        }
                                    if (ind.g[l1].hash != 0 && ind.g[l2].hash != 0)
                                        nt++;
                                }

                            double[,] obs = new double[c1.Count, c2.Count];
                            foreach (ulong ha in table.Keys)
                            {
                                uint ha1 = (uint)(ha >> 32);
                                uint ha2 = (uint)ha;
                                obs[c1[ha1].id, c2[ha2].id] = table[ha];
                            }

                            CombineTable(obs, null, ref df[c], ref G[c], ref GP[c], ref P2[c], LINKAGE_RAYMOND,
                                rnd, ref SE[c], ref switches[c], LINKAGE_BURNIN, LINKAGE_BATCHES, LINKAGE_ITERATIONS);//OK
                        }
                        else
                        {
                            df[c] = G[c] = GP[c] = P2[c] = SE[c] = double.NaN;
                            switches[c] = 0;
                        }
                        c++;
                        Increment();
                    }
                }
            }

            private StringBuilder[] ot_linkage;

            public void CalcLinkage()
            {
                int Lpair = L * (L - 1) / 2;

                Progress = "Testing linkage disequilibrium";
                ProgressValue = 0;
                ProgressMax = Lpair * ((LINKAGE_POP ? subpops.Length : 0) + (LINKAGE_REG && region_count > 0 ? region_count - 1 : 0) + (LINKAGE_TOT ? 1 : 0));
                SetProgress(ProgressValue, ProgressMax);
                ot_linkage = new StringBuilder[ProgressMax];

                StreamWriter wt = new StreamWriter(new FileStream("o_linkage.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_LINKAGE = wt;

                wt.Write(ISGENOTYPE ? //OK
                    "Linkage disequilibrium test based on genotypic data\r\n\t\t\t" :
                    "Linkage disequilibrium test based on phenotypic data\r\n\t\t\t");
                if (LINKAGE_FISHER) wt.Write("Fisher's G test\t\t\t\t");
                if (LINKAGE_FISHER && LINKAGE_RAYMOND) wt.Write("Raymond & Rousset's Markrov Chain test\t\t\t\t");
                if (LINKAGE_BURROWS) wt.Write("Burrows's Delta test\t\t\t\t\t");
                if (LINKAGE_BURROWS && LINKAGE_RAYMOND) wt.Write("Raymond & Rousset's Markrov Chain test\t\t\t\t");
                wt.Write("\r\nPop\tA\tB\t");
                if (LINKAGE_FISHER) wt.Write("G\tdf\tP\tFDR-Q\t");
                if (LINKAGE_FISHER && LINKAGE_RAYMOND) wt.Write("switches\tSE\tP\tFDR-Q\t");
                if (LINKAGE_BURROWS) wt.Write("r2\tG\tdf\tP\tFDR-Q\t");
                if (LINKAGE_BURROWS && LINKAGE_RAYMOND) wt.Write("switches\tSE\tP\tFDR-Q\t");
                wt.Write("\r\n");

                double[] G = new double[Lpair], df = new double[Lpair], GP = new double[Lpair], Q = null;
                double[] P2 = new double[Lpair], SE = new double[Lpair], Q2 = null;
                int[] switches = new int[Lpair];
                double[] DG = new double[Lpair], Ddf = new double[Lpair], DP = new double[Lpair], DQ = null;
                double[] DP2 = new double[Lpair], DSE = new double[Lpair], DR2a = new double[Lpair], DR2b = new double[Lpair], DQ2 = null;
                int[] Dswitches = new int[Lpair];

                if (LINKAGE_TOT)
                {
                    CallThread(LinkageTestThread, N_THREAD,
                        new object[] { total_pop.inds, GP, G, df, P2, SE, switches, DG, Ddf, DP, DP2, DSE, Dswitches, DR2a, DR2b, total_pop },
                        ProgressValue + Lpair, ref ProgressValue);

                    if (LINKAGE_FISHER) Q = FDRCorrection(GP);
                    if (LINKAGE_FISHER && LINKAGE_RAYMOND) Q2 = FDRCorrection(P2);
                    if (LINKAGE_BURROWS) DQ = FDRCorrection(DP);
                    if (LINKAGE_BURROWS && LINKAGE_RAYMOND) DQ2 = FDRCorrection(DP2);

                    for (int i = 0, c = 0; i < L; ++i)
                        for (int j = i + 1; j < L; ++j)
                        {
                            wt.Write(total_pop.name + "\t" + total_pop.loc[i].name + "\t" + total_pop.loc[j].name
                            + (LINKAGE_FISHER ? "\t" + G[c].ToString(DECIMAL) + "\t" + df[c] + "\t" + GP[c].ToString(DECIMAL) + "\t" + Q[c].ToString(DECIMAL) : "")
                            + (LINKAGE_FISHER && LINKAGE_RAYMOND ? "\t" + switches[c] + "\t" + SE[c].ToString(DECIMAL) + "\t" + P2[c].ToString(DECIMAL) + "\t" + Q2[c].ToString(DECIMAL) : "")
                            + (LINKAGE_BURROWS ? "\t" + (DR2a[c] / DR2b[c]).ToString(DECIMAL) + "\t" + DG[c].ToString(DECIMAL) + "\t" + Ddf[c] + "\t" + DP[c].ToString(DECIMAL) + "\t" + DQ[c].ToString(DECIMAL) : "")
                            + (LINKAGE_BURROWS && LINKAGE_RAYMOND ? "\t" + Dswitches[c] + "\t" + DSE[c].ToString(DECIMAL) + "\t" + DP2[c].ToString(DECIMAL) + "\t" + DQ2[c].ToString(DECIMAL) : "")
                                + "\r\n");
                            c++;
                        }
                }

                if (LINKAGE_REG)
                {
                    for (int rl = regions.Length - 2; rl >= 0; --rl)
                        foreach (SUBPOP tr in regions[rl])
                        {
                            CallThread(LinkageTestThread, N_THREAD,
                                new object[] { tr.inds, GP, G, df, P2, SE, switches, DG, Ddf, DP, DP2, DSE, Dswitches, DR2a, DR2b, tr },
                                ProgressValue + Lpair, ref ProgressValue);

                            if (LINKAGE_FISHER) Q = FDRCorrection(GP);
                            if (LINKAGE_FISHER && LINKAGE_RAYMOND) Q2 = FDRCorrection(P2);
                            if (LINKAGE_BURROWS) DQ = FDRCorrection(DP);
                            if (LINKAGE_BURROWS && LINKAGE_RAYMOND) DQ2 = FDRCorrection(DP2);

                            for (int i = 0, c = 0; i < L; ++i)
                                for (int j = i + 1; j < L; ++j)
                                {
                                    wt.Write(tr.name + "\t" + total_pop.loc[i].name + "\t" + total_pop.loc[j].name
                                        + (LINKAGE_FISHER ? "\t" + G[c].ToString(DECIMAL) + "\t" + df[c] + "\t" + GP[c].ToString(DECIMAL) + "\t" + Q[c].ToString(DECIMAL) : "")
                                        + (LINKAGE_FISHER && LINKAGE_RAYMOND ? "\t" + switches[c] + "\t" + SE[c].ToString(DECIMAL) + "\t" + P2[c].ToString(DECIMAL) + "\t" + Q2[c].ToString(DECIMAL) : "")
                                        + (LINKAGE_BURROWS ? "\t" + (DR2a[c] / DR2b[c]).ToString(DECIMAL) + "\t" + DG[c].ToString(DECIMAL) + "\t" + Ddf[c] + "\t" + DP[c].ToString(DECIMAL) + "\t" + DQ[c].ToString(DECIMAL) : "")
                                        + (LINKAGE_BURROWS && LINKAGE_RAYMOND ? "\t" + Dswitches[c] + "\t" + DSE[c].ToString(DECIMAL) + "\t" + DP2[c].ToString(DECIMAL) + "\t" + DQ2[c].ToString(DECIMAL) : "")
                                        + "\r\n");
                                    c++;
                                }
                        }
                }

                if (LINKAGE_POP)
                {
                    foreach (SUBPOP tp in subpops)
                    {
                        CallThread(LinkageTestThread, N_THREAD,
                            new object[] { tp.inds, GP, G, df, P2, SE, switches, DG, Ddf, DP, DP2, DSE, Dswitches, DR2a, DR2b, tp },
                            ProgressValue + Lpair, ref ProgressValue);

                        if (LINKAGE_FISHER) Q = FDRCorrection(GP);
                        if (LINKAGE_FISHER && LINKAGE_RAYMOND) Q2 = FDRCorrection(P2);
                        if (LINKAGE_BURROWS) DQ = FDRCorrection(DP);
                        if (LINKAGE_BURROWS && LINKAGE_RAYMOND) DQ2 = FDRCorrection(DP2);

                        for (int i = 0, c = 0; i < L; ++i)
                            for (int j = i + 1; j < L; ++j)
                            {
                                wt.Write(tp.name + "\t" + total_pop.loc[i].name + "\t" + total_pop.loc[j].name
                                    + (LINKAGE_FISHER ? "\t" + G[c].ToString(DECIMAL) + "\t" + df[c] + "\t" + GP[c].ToString(DECIMAL) + "\t" + Q[c].ToString(DECIMAL) : "")
                                    + (LINKAGE_FISHER && LINKAGE_RAYMOND ? "\t" + switches[c] + "\t" + SE[c].ToString(DECIMAL) + "\t" + P2[c].ToString(DECIMAL) + "\t" + Q2[c].ToString(DECIMAL) : "")
                                    + (LINKAGE_BURROWS ? "\t" + (DR2a[c] / DR2b[c]).ToString(DECIMAL) + "\t" + DG[c].ToString(DECIMAL) + "\t" + Ddf[c] + "\t" + DP[c].ToString(DECIMAL) + "\t" + DQ[c].ToString(DECIMAL) : "")
                                    + (LINKAGE_BURROWS && LINKAGE_RAYMOND ? "\t" + Dswitches[c] + "\t" + DSE[c].ToString(DECIMAL) + "\t" + DP2[c].ToString(DECIMAL) + "\t" + DQ2[c].ToString(DECIMAL) : "")
                                    + "\r\n");
                                c++;
                            }
                    }
                }

                wt.Write("\r\n\r\n");
                wt.Flush();
                wt.Close();
            }

            #endregion

            #region NE
            public void CalcNe(int nthreads)
            {
                GC.Collect();
                Progress = "Estimating effective population size";

                int S = subpops.Length;
                int R = S == 1 ? 0 : region_count;
                int p = 0;
                int tprogress = 0;

                for (int i = 0; i < S; ++i, ++p)
                {
                    SUBPOP tp = subpops[i];
                    if (NE_PUDOVKIN2009) tprogress += L;
                    if (NE_NOMURA2008 || (CALC_DIFF && DIFF_Huang2019)) tprogress += tp.inds.Length + L * 2;
                    if (NE_WAPLES2010) tprogress += L * (L - 1) / 2;
                }

                for (int rl = regions.Length - 1; rl >= 0; --rl)
                    for (int i = 0; i < regions[rl].Length; ++i, ++p)
                    {
                        SUBPOP tr = regions[rl][i];
                        if (NE_PUDOVKIN2009) tprogress += L;
                        if (NE_NOMURA2008 || (CALC_DIFF && DIFF_Huang2019)) tprogress += tr.inds.Length + L * 2;
                        if (NE_WAPLES2010) tprogress += L * (L - 1) / 2;
                    }

                ProgressValue = 0;
                ProgressMax = tprogress;

                //k n ho he pic ar fis
                StreamWriter wt = new StreamWriter(new FileStream("o_ne.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_NE = wt;

                wt.Write("\t\t\t");
                if (NE_PUDOVKIN2009) wt.Write("Pudovkin 2009\t\t\t\t\t\t");
                if (NE_NOMURA2008) wt.Write("Nomura 2008\t\t\t\t\t");
                if (NE_WAPLES2010) wt.Write("Waples 2010\t\t\t\t\t");

                wt.Write("\r\nPop\tPloidy\t#ind\tL");
                if (NE_PUDOVKIN2009) wt.Write("\tD\tNe\tSE(Ne)\t95% CI\tSE(1/vNe)");
                if (NE_NOMURA2008) wt.Write("\ttheta_xy\tNe\tSE(Ne)\t95% CI\tSE(1/vNe)");
                if (NE_WAPLES2010) wt.Write("\tr^2_Delta\tNe\tSE(Ne)\t95% CI\tSE(1/vNe)");

                for (int i = 0; i < S; ++i, ++p)
                {
                    SUBPOP tp = subpops[i];
                    tp.SubpopNe(nthreads, wt);
                }

                for (int rl = regions.Length - 1; rl >= 0; --rl)
                    for (int i = 0; i < regions[rl].Length; ++i, ++p)
                    {
                        SUBPOP tr = regions[rl][i];
                        tr.Msl = new double[L];
                        tr.SubpopNe(nthreads, wt);
                    }
                wt.Flush();
                wt.Close();
            }

            #endregion

            #region Differentiation
            List<double[,]> PFST = new List<double[,]>();
            List<double[,]>[] RFST;
            List<string> FSTNAME = new List<string>();

            public static double[,] GetHaplotype2(IND[] inds, Dictionary<int, int>[] map1, int[] J, int Jt, int nhaplo)
            {
                //analysis structure
                int L = inds[0].g.Length;
                int N = inds.Length;
                double[,] re = new double[nhaplo, Jt];

                int[] stidx = new int[inds.Length];
                for (int i = 1; i < inds.Length; ++i)
                    stidx[i] = stidx[i - 1] + inds[i - 1].ploidy;

                Parallel.For(0, inds.Length, new ParallelOptions() { MaxDegreeOfParallelism = N_THREAD }, i =>
                //for (int i = 0; i < inds.Count; ++i)
                {
                    int st = stidx[i];
                    IND ind = inds[i];
                    for (int l = 0, lp1 = 0; l < L; ++l)
                    {
                        if (ind.g[l].hash == 0)
                        {
                            //missing haplotype, weight
                            foreach (var a in ind.subpop.loc[l].freq)
                            {
                                int mapid = map1[l][a.Key];
                                for (int p = 0; p < ind.ploidy; ++p)
                                    re[st + p, lp1 + mapid] = a.Value;
                            }
                        }
                        else
                        {
                            foreach (GENOTYPE gh in ind.g[l].genotypes)
                            {
                                double pr = gh.poster;
                                var b = gh.alleles2.ToList();
                                b.Sort();
                                for (int p = 0; p < ind.ploidy; ++p)
                                    re[st + p, lp1 + map1[l][b[p]]] += pr;
                            }
                        }
                        lp1 += J[l];
                    }
                });
                return re;
            }

            public static void ArrangeInds(SUBPOP pop, IND[] inds, ref int ninds)
            {
                if (pop.subpops != null && pop.subpops.Length > 0)
                    foreach (SUBPOP s in pop.subpops)
                        ArrangeInds(s, inds, ref ninds);
                else
                {
                    Array.Copy(pop.inds, 0, inds, ninds, pop.inds.Length);
                    ninds += pop.inds.Length;
                }
            }

            public static HAPLOTYPE[] GetHaplotype(SUBPOP pop, int nlay, bool ignoreind, bool enable_missing)
            {
                //analysis amova
                int L = pop.loc.Length;
                HAPLOTYPE[] h = new HAPLOTYPE[pop.nhaplotypes];
                IND[] inds2 = new IND[pop.inds.Length];
                int inds2c = 0;
                ArrangeInds(pop, inds2, ref inds2c);

                int[] stidx = new int[inds2.Length];
                for (int i = 1; i < inds2.Length; ++i)
                    stidx[i] = stidx[i - 1] + inds2[i - 1].ploidy;

                Parallel.For(0, inds2.Length, new ParallelOptions() { MaxDegreeOfParallelism = N_THREAD }, i =>
                //for (int i = 0; i < inds2.Length; ++i)
                {
                    IND ind = inds2[i];
                    int st = stidx[i];
                    for (int p = 0; p < ind.ploidy; ++p)
                    {
                        HAPLOTYPE th = new HAPLOTYPE();
                        th.ind = ind;
                        th.allele = new Dictionary<int, double>[L];
                        for (int l = 0; l < L; ++l)
                            th.allele[l] = new Dictionary<int, double>();
                        h[st + p] = th;
                    }

                    for (int l = 0; l < L; ++l)
                    {
                        if (ind.g[l].hash == 0)
                        {
                            //missing haplotype
                            if (enable_missing)
                                for (int p = 0; p < ind.ploidy; ++p)
                                    h[st + p].allele[l] = ind.subpop.loc[l].freq;
                            else
                                for (int p = 0; p < ind.ploidy; ++p)
                                    h[st + p].allele[l] = null;
                        }
                        else
                        {
                            foreach (GENOTYPE gh in ind.g[l].genotypes)
                            {
                                double pr = gh.poster;
                                int cp = 0;
                                foreach (int a in gh.alleles2.OrderBy(a => a))
                                {
                                    if (!h[st + cp].allele[l].ContainsKey(a))
                                        h[st + cp].allele[l][a] = 0;
                                    h[st + cp++].allele[l][a] += pr;
                                }

                            }
                        }
                    }
                });
                return h;
            }

            public static void GetInds(SUBPOP pop, List<IND> inds)
            {
                if (pop.subpops == null || pop.subpops.Length == 0)
                    inds.AddRange(pop.inds);
                else foreach (SUBPOP s in pop.subpops)
                        GetInds(s, inds);
            }

            public static double GetFst(SUBPOP[] subpops, FstEstimator estimator)
            {
                //Single Thread
                switch (estimator)
                {
                    case FstEstimator.WeightGenoIAM: return Fst_WeightGenotype(subpops, true);
                    case FstEstimator.WeightGenoSMM: return Fst_WeightGenotype(subpops, false);
                    case FstEstimator.Slatkin1995: return Fst_Slatkin1995(subpops);
                    case FstEstimator.Nei1973: return Fst_Nei1973(subpops, false);
                    case FstEstimator.Hudson1992: return Fst_Hudson1992(subpops);
                    case FstEstimator.Hedrick2005: return Fst_Hedrick2005(subpops);
                    case FstEstimator.Jost2008: return Fst_Jost2008(subpops);
                    case FstEstimator.Huang2019: return Fst_Huang2019(subpops);
                    case FstEstimator.SimGenoIAM: return Fst_Genotype(subpops, 2, 2, true);
                    case FstEstimator.SimGenoSMM: return Fst_Genotype(subpops, 2, 2, false);
                    case FstEstimator.SimNei1973: return Fst_Nei1973(subpops, true);
                }
                return 0;
            }

            public static double[] GetNullSqDist(LOC[] loc)
            {
                double[] re = new double[loc.Length];
                for (int i = 0; i < loc.Length; ++i)
                {
                    int count = 0;
                    double diff = 0;
                    foreach (int a in loc[i].freq.Keys)
                    {
                        if (a == NULL_ALLELE) continue;
                        foreach (int b in loc[i].freq.Keys)
                        {
                            if (b == NULL_ALLELE) continue;
                            if (a != b)
                            {
                                count++;
                                diff += (a - b) * (a - b);
                            }
                        }
                        if (count != 0)
                            re[i] = diff / count;
                    }
                }
                return re;
            }

            public static double GetIAMDist(IND[] inds, int l)
            {
                double re = 0;
                for (int i = 0; i < inds.Length; ++i)
                {
                    re += inds[i].g[l].GetIAMDist();
                    for (int j = 0; j < i; ++j)
                        re += inds[i].g[l].GetIAMDist(inds[j].g[l]);
                }
                return re;
            }

            public static double GetTrueIAMDist(IND[] inds, int l)
            {
                double re = 0;
                for (int i = 0; i < inds.Length; ++i)
                {
                    re += inds[i].g[l].GetTrueIAMDist();
                    for (int j = 0; j < i; ++j)
                        re += inds[i].g[l].GetTrueIAMDist(inds[j].g[l]);
                }
                return re;
            }

            public static double GetSMMDist(IND[] inds, int l, double NULLSQDIST)
            {
                double re = 0;
                for (int i = 0; i < inds.Length; ++i)
                {
                    re += inds[i].g[l].GetSMMDist(NULLSQDIST);
                    for (int j = 0; j < i; ++j)
                        re += inds[i].g[l].GetSMMDist(NULLSQDIST, inds[j].g[l]);
                }
                return re;
            }

            public static double GetTrueSMMDist(IND[] inds, int l, double NULLSQDIST)
            {
                double re = 0;
                for (int i = 0; i < inds.Length; ++i)
                {
                    re += inds[i].g[l].GetTrueSMMDist(NULLSQDIST);
                    for (int j = 0; j < i; ++j)
                        re += inds[i].g[l].GetTrueSMMDist(inds[j].g[l], NULLSQDIST);
                }
                return re;
            }

            public static double Fst_WeightGenotype(SUBPOP[] subpops, bool isiam)
            {
                //Weight genotype method
                double SS0 = 0, SS1 = 0;
                double C00 = 0, C10 = 0, C11 = 0;

                int L = subpops[0].L;

                for (int l = 0; l < L; ++l)
                {
                    int nh = subpops.Sum(s => s.loc[l].nhaplotypes);
                    if (nh == 0) continue;//20210723 fixed, NaN in pairwise Fst

                    double ivt = 1.0 / nh;
                    C00 += nh - subpops.Count(s => s.loc[l].nhaplotypes > 0);
                    C10 += nh - 1;
                    C11 += nh - subpops.Sum(s => s.loc[l].nhaplotypes * s.loc[l].nhaplotypes) / (double)nh;

                    //SSWI
                    foreach (SUBPOP tp in subpops)
                    {
                        double ivp = 1.0 / tp.loc[l].nhaplotypes;
                        foreach (IND ind in tp.inds)
                        {
                            double sd1 = isiam ? ind.g[l].GetIAMDist() : ind.g[l].GetSMMDist(NULLSQDIST[l]);
                            if (sd1 <= 0) continue;
                            SS0 += sd1 * ivp;
                            SS1 += sd1 * ivt;
                        }
                    }

                    for (int pi = 0; pi < subpops.Length; ++pi)
                    {
                        SUBPOP tp1 = subpops[pi];
                        double ivp = 1.0 / tp1.loc[l].nhaplotypes;
                        foreach (PHENOTYPE p1 in tp1.phenotype[l].Values)
                        {
                            if (p1.count <= 0) continue;
                            for (int pj = 0; pj <= pi; ++pj)
                            {
                                SUBPOP tp2 = subpops[pj];
                                foreach (PHENOTYPE p2 in subpops[pj].phenotype[l].Values)
                                {
                                    if (p2.count <= 0) continue;
                                    if (pi == pj && p1.hash < p2.hash) continue;

                                    double count = p1.count * p2.count;

                                    if (pi == pj && p1.hash == p2.hash)
                                        count = p1.count * (p1.count - 1) / 2;

                                    if (count <= 0) continue;

                                    double sd1 = isiam ? p1.GetIAMDist(p2) : p1.GetSMMDist(NULLSQDIST[l], p2);

                                    if (sd1 <= 0) continue;

                                    if (pi == pj) SS0 += count * sd1 * ivp;
                                    SS1 += count * sd1 * ivt;
                                }
                            }
                        }
                    }
                }
                double V0 = SS0 / C00;
                double V1 = (SS1 - V0 * C10) / C11;
                return V1 / (V0 + V1);
            }

            public static double Fst_Genotype(SUBPOP[] subpops, int layer, int weight, bool isiam)
            {
                if (subpops.Length <= 1) return 0;

                IND[] inds = (from SUBPOP tp in subpops from i in tp.inds select i).ToArray();

                int L = subpops[0].L;
                int nl = 0;
                double SSWI = 0, SSWP = 0, SSTOT = 0, FST = 0;
                double VWI = 0, VWP = 0, VAI = 0, VAP = 0;
                double Np = 0, Ni = 0, Nh = 0;
                double N11 = 0, N21 = 0, N22 = 0, N31 = 0, N32 = 0, N33 = 0;

                for (int l = 0; l < L; ++l)
                {
                    if (subpops[0].loc[l].freq.Count < 2) continue;
                    double sswi = 0, sswp = 0, sstot = 0;
                    double np = 0, ni = 0, nh = 0;
                    double n11 = 0, n21 = 0, n22 = 0, n31 = 0, n32 = 0, n33 = 0;
                    double svi2dvp = 0, svi2dvt = 0, svp2dvt = 0;

                    foreach (SUBPOP tp in subpops)
                    {
                        int vp = 0;
                        double svi2 = 0;
                        foreach (IND i in tp.inds)
                        {
                            if (i.g[l].hash != 0)
                            {
                                vp += i.ploidy;
                                svi2 += i.ploidy * i.ploidy;
                                ni++;
                            }
                        }

                        if (vp > 0)
                        {
                            np++;
                            nh += vp;
                            svi2dvp += svi2 / vp;
                            svi2dvt += svi2;
                            svp2dvt += vp * vp;
                        }
                        sswp += (isiam ? GetTrueIAMDist(tp.inds, l) : GetTrueSMMDist(tp.inds, l, NULLSQDIST[l])) / vp;
                    }

                    svi2dvt /= nh;
                    svp2dvt /= nh;

                    if (np <= 1) continue;
                    nl++;

                    sstot = (isiam ? GetTrueIAMDist(inds, l) : GetTrueSMMDist(inds, l, NULLSQDIST[l])) / nh;
                    if (layer == 3) foreach (IND i in inds)
                            sswi += (isiam ? i.g[l].GetTrueIAMDist() : i.g[l].GetTrueSMMDist(NULLSQDIST[l])) / i.g[l].ploidy;

                    Nh += nh;
                    Ni += ni;
                    Np += np;

                    SSWI += sswi;
                    SSWP += sswp;
                    SSTOT += sstot;

                    if (layer == 2)
                    {
                        n11 = nh - np;
                        n21 = nh - svp2dvt;
                        n22 = nh - 1;

                        N11 += n11;
                        N21 += n21;
                        N22 += n22;

                        double vwp = sswp / n11;
                        double vap = (n11 * sstot - n22 * sswp) / (n11 * n21);

                        VWP += vwp;
                        VAP += vap;

                        FST += vap / (vwp + vap);
                    }
                    else
                    {
                        n11 = nh - ni;
                        n21 = nh - svi2dvp;
                        n22 = nh - np;
                        n31 = nh - svp2dvt;
                        n32 = nh - svi2dvt;
                        n33 = nh - 1;

                        N11 += n11;
                        N21 += n21;
                        N22 += n22;
                        N31 += n31;
                        N32 += n32;
                        N33 += n33;

                        double vwi = sswi / n11;
                        double vai = (n11 * sswp - n22 * sswi) / (n11 * n21);
                        double vap = (n22 * n32 * sswi - n21 * n33 * sswi - n11 * n32 * sswp + n11 * n21 * sstot) / (n11 * n21 * n31);

                        VWI += vwi;
                        VAI += vai;
                        VAP += vap;

                        FST += vap / (vwi + vai + vap);
                    }
                }

                if (layer == 2)
                {
                    switch (weight)
                    {
                        case 2: //weight SS
                            VWP = SSWP / N11;
                            VAP = (N11 * SSTOT - N22 * SSWP) / (N11 * N21);
                            return VAP / (VWP + VAP);
                        case 3: //weight Var
                            return VAP / (VWP + VAP);
                        case 4: //weight FST
                            return FST / nl;
                    }
                }
                else
                {
                    switch (weight)
                    {
                        case 2: //weight SS
                            VWI = SSWI / N11;
                            VAI = (N11 * SSWP - N22 * SSWI) / (N11 * N21);
                            VAP = (N22 * N32 * SSWI - N21 * N33 * SSWI - N11 * N32 * SSWP + N11 * N21 * SSTOT) / (N11 * N21 * N31);
                            return VAP / (VWI + VAI + VAP);
                        case 3: //weight Var
                            return VAP / (VWI + VAI + VAP);
                        case 4: //weight FST
                            return FST / nl;
                    }
                }
                return 0;
            }

            public static double GetDist(SUBPOP[] subpops, int l, double NULLSQDIST, bool IsIAM)
            {
                int vt = 0;
                Dictionary<int, double> allele = SUBPOP.UniteFrequency(subpops, l, ref vt);
                return IsIAM ? GetIAMDist(allele, vt) : GetSMMDist(allele, vt, NULLSQDIST);
            }

            public static double GetSMMDist(Dictionary<int, double> allele, int vp, double NULLSQDIST)
            {
                double re = 0;
                foreach (var a in allele)
                {
                    int ka = a.Key;
                    double va = a.Value * vp;
                    foreach (var b in allele)
                    {
                        int kb = b.Key;
                        double vb = b.Value * vp;

                        if (ka >= kb) continue;
                        if (ka == NULL_ALLELE || kb == NULL_ALLELE)
                            re += va * vb * NULLSQDIST;
                        else
                            re += va * vb * (ka - kb) * (ka - kb);
                    }
                }
                return re / 2;
            }

            public static double GetIAMDist(Dictionary<int, double> allele, int vp)
            {
                double re = vp * vp;
                foreach (double va in allele.Values)
                    re -= va * va;
                return re / 2;
            }

            public static double Fst_Slatkin1995(SUBPOP[] subpops)
            {
                //allele frequency based
                if (subpops.Length <= 1) return 0;

                int L = subpops[0].L;
                double f1 = 0, f2 = 0;
                for (int l = 0; l < L; ++l)
                {
                    double Sw1 = 0, Sw2 = 0, St1 = 0, St2 = 0;
                    int k2 = subpops[0].loc[l].freq.Count;
                    if (k2 < 2) continue;

                    int Np = 0, Nh = 0;
                    Dictionary<int, double> allele = new Dictionary<int, double>();
                    int[] als = null;
                    foreach (SUBPOP tp in subpops)
                    {
                        int nh = tp.loc[l].nhaplotypes;
                        if (nh == 0) continue;

                        foreach (var k in tp.loc[l].freq)
                        {
                            if (!allele.ContainsKey(k.Key))
                                allele[k.Key] = 0;
                            allele[k.Key] += k.Value * nh;
                        }
                        if (als == null) als = allele.Keys.ToArray();
                        Nh += nh;
                        Np++;

                        double d = 0; //2x
                        Sw2 += nh * (nh - 1) / 2;//x
                        for (int i = 0; i < als.Length; ++i)
                            for (int j = i + 1; j < als.Length; ++j)
                                d += tp.loc[l].freq[als[i]] * tp.loc[l].freq[als[j]] * (als[i] - als[j]) * (als[i] - als[j]);
                        Sw1 += d * nh * nh;
                    }

                    if (Np < 2) continue;
                    St2 += Nh * (Nh - 1) / 2;
                    for (int i = 0; i < als.Length; ++i)
                        for (int j = i + 1; j < als.Length; ++j)
                            St1 += allele[als[i]] * allele[als[j]] * (als[i] - als[j]) * (als[i] - als[j]);

                    double Sw = Sw1 / Sw2, St = St1 / St2;
                    if (!double.IsNaN(Sw) && !double.IsNaN(St) && !double.IsInfinity(Sw) && !double.IsInfinity(St))
                    {
                        f1 += St - Sw;
                        f2 += St;
                    }
                }

                return f1 / f2;
            }

            public static double Fst_Nei1973(SUBPOP[] subpops, bool issim)
            {
                if (subpops.Length <= 1) return 0;

                int L = subpops[0].L; double DA = 0, DB = 0;
                for (int l = 0; l < L; ++l)
                {
                    if (subpops[0].loc[l].freq.Count < 2) continue;
                    double hs = 0, ht = 0;
                    int nt = 0, ns = 0, ns2 = 0;
                    Dictionary<int, double> allele = CloneKey(subpops[0].loc[l].freq);
                    Dictionary<int, double> sallele = CloneKey(subpops[0].loc[l].freq);
                    if (issim)
                    {
                        foreach (SUBPOP tp in subpops)
                        {
                            tp.CalcFreq(sallele, l, ref ns);
                            AddMul(allele, sallele, ns);
                            hs += (1 - SumSquare(sallele)) * ns * ns;
                            ns2 += ns * ns;
                            nt += ns;
                        }
                        Mul(allele, allele, 1.0 / nt);
                        hs /= ns2;
                        ht = 1 - SumSquare(allele);
                    }
                    else
                    {
                        allele = SUBPOP.UniteFrequency(subpops, l, ref nt);
                        foreach (SUBPOP tp in subpops)
                        {
                            hs += (1 - SumSquare(tp.loc[l].freq)) * tp.loc[l].nhaplotypes;
                            ns2 += tp.loc[l].nhaplotypes;
                        }
                        hs /= ns2;
                        ht = 1 - SumSquare(allele);
                    }
                    if (ns2 == 0) continue;//20210723 fixed, NaN in pairwise Fst
                    DA += ht - hs;
                    DB += ht;
                }
                return DA / DB;
            }

            public static double[] M_Nomura2008(double nrrate, double[] J, IND[] inds, int nthreads, POP parent)
            {
                if (inds == null || inds.Length == 0) return null;

                int N = inds.Length, L = inds[0].g.Length;
                double[] M = new double[L];
                double[,] sxy = new double[N, N];
                Nomura2008NrRateEntry[] pxyl = new Nomura2008NrRateEntry[N * (N - 1) / 2];

                Parallel.For(0, N, new ParallelOptions() { MaxDegreeOfParallelism = nthreads }, i =>
                {
                    IND xi = inds[i];
                    for (int j = i + 1; j < N; ++j)
                    {
                        IND yi = inds[j];
                        double sum = 0;
                        for (int l = 0; l < L; ++l)
                        {
                            if (J != null && (J[l] == 1 || double.IsNaN(J[l])) || xi.g[l].hash == 0 || yi.g[l].hash == 0) continue;
                            sum += SumProd(xi.g[l].freq, yi.g[l].freq);
                        }
                        sxy[i, j] = sxy[j, i] = sum;
                    }

                    if (parent != null) parent.Increment();
                });

                for (int l = 0; l < L; ++l)
                {
                    if (J != null && J[l] == 1)
                    {
                        M[l] = 1;
                        continue;
                    }
                    if (J != null && double.IsNaN(J[l]))
                    {
                        M[l] = double.NaN;
                        continue;
                    }

                    PHENOTYPE[] pheno = inds.Where(i => i.g[l].hash != 0).Select(i => i.g[l]).ToArray();
                    int n = pheno.Length;
                    Array.Clear(pxyl, 0, n * (n - 1) / 2);

                    Parallel.For(0, pheno.Length, new ParallelOptions() { MaxDegreeOfParallelism = nthreads }, i =>
                    {
                        int b = i * (i - 1) / 2;
                        PHENOTYPE x = pheno[i];
                        for (int j = 0; j < i; ++j)
                        {
                            PHENOTYPE y = pheno[j];
                            double pxy = SumProd(x.freq, y.freq);
                            pxyl[b + j].SetVal(sxy[i, j] - pxy, pxy, x.ploidy * y.ploidy);
                        }
                    });

                    Array.Sort(pxyl, 0, n * (n - 1) / 2);
                    int nnr = (int)(nrrate * n * (n - 1) / 2);

                    int tiest = nnr - 1, tieed = nnr - 1;
                    double tieval = pxyl[nnr - 1].a;
                    while (tiest >= 0 && Math.Abs(pxyl[tiest].a - tieval) < 1e-10) tiest--;
                    while (tieed < pxyl.Length && Math.Abs(pxyl[tieed].a - tieval) < 1e-10) tieed++;

                    double tf1 = 0, tf2 = 0;
                    for (int i = tiest + 1; i < tieed; ++i)
                    {
                        tf1 += pxyl[i].b * pxyl[i].w;
                        tf2 += pxyl[i].w;
                    }
                    double tieprop = ((nnr - 1) - (tiest + 1) + 1.0) / ((tieed - 1) - (tiest + 1) + 1.0);

                    double f1 = 0, f2 = 0;
                    for (int i = 0; i <= tiest; ++i)
                    {
                        f1 += pxyl[i].b * pxyl[i].w;
                        f2 += pxyl[i].w;
                    }

                    f1 += tf1 * tieprop;
                    f2 += tf2 * tieprop;
                    M[l] = f1 / f2;

                    if (parent != null) parent.Increment();
                }

                return M;
            }

            private static double Fst_Huang2019(SUBPOP[] subpops)
            {
                if (subpops.Length <= 1) return 0;
                int L = subpops[0].loc.Length;
                IND[] inds = (from s in subpops from i in s.inds select i).ToArray();

                int nt = 0;
                double[] J = new double[L];
                for (int l = 0; l < L; ++l)
                    J[l] = SumSquare(SUBPOP.UniteFrequency(subpops, l, ref nt));

                double[] mtl = M_Nomura2008(NRRATE, J, inds, 1, null);//necessary
                double[] msl = new double[L];

                for (int l = 0; l < L; ++l)
                    msl[l] = subpops.Sum(s => s.Msl[l] * s.loc[l].nhaplotypes * s.loc[l].nhaplotypes) / subpops.Sum(s => s.loc[l].nhaplotypes * s.loc[l].nhaplotypes);

                double DA = 0, DB = 0;
                for (int l = 0; l < L; ++l)
                {
                    if (subpops[0].loc[l].freq.Count < 2) continue;
                    DA += msl[l] - mtl[l];
                    DB += 1 - mtl[l];
                }
                return DA / DB;
            }

            public static double Fst_Hudson1992(SUBPOP[] subpops)
            {
                if (subpops.Length <= 1) return 0;

                int L = subpops[0].L;
                double f1 = 0, f2 = 0;
                for (int l = 0; l < L; ++l)
                {
                    int k2 = subpops[0].loc[l].freq.Count;
                    if (k2 < 2) continue;

                    int Np = 0, Nh = 0;
                    double Dw = 0, Nw = 0;
                    Dictionary<int, double> allele = new Dictionary<int, double>();
                    foreach (SUBPOP tp in subpops)
                    {
                        int nh = tp.loc[l].nhaplotypes;
                        if (nh == 0) continue;
                        foreach (var k in tp.loc[l].freq)
                        {
                            if (!allele.ContainsKey(k.Key))
                                allele[k.Key] = 0;
                            allele[k.Key] += k.Value * nh;
                        }
                        Nh += nh;
                        Np++;

                        Dw += nh * (nh - 1); //2x
                        Nw += nh * (nh - 1);//2x
                        foreach (double v in tp.loc[l].freq.Values)
                        {
                            double na = nh * v;
                            Dw -= na * (na - 1); //substrate same
                        }
                    }

                    if (Np < 2) continue;
                    double Db = Nh * (Nh - 1), Nb = Db;
                    foreach (double v in allele.Values)
                        Db -= v * (v - 1);

                    double hw = Dw / Nw, hb = (Db - Dw) / (Nb - Nw);
                    if (!double.IsNaN(hw) && !double.IsNaN(hb) && !double.IsInfinity(hw) && !double.IsInfinity(hb))
                    {
                        f1 += hb - hw;
                        f2 += hb;
                    }
                }

                return f1 / f2;
            }

            public static double Fst_Hedrick2005(SUBPOP[] subpops)
            {
                if (subpops.Length <= 1) return 0;

                int L = subpops[0].L;
                double DA = 0, DB = 0;
                for (int l = 0; l < L; ++l)
                {
                    if (subpops[0].loc[l].freq.Count < 2) continue;

                    double ht = 0, hs = 0;
                    int S = 0, nt = 0;
                    Dictionary<int, double> allele = SUBPOP.UniteFrequency(subpops, l, ref nt);

                    foreach (SUBPOP tp in subpops)
                    {
                        int ns = tp.loc[l].nhaplotypes;
                        if (ns == 0) continue;
                        hs += (1 - SumSquare(tp.loc[l].freq)) * ns;
                        S++;
                    }

                    if (S < 2) continue;
                    hs /= nt;
                    ht = 1 - SumSquare(allele);
                    DA += (ht - hs) * (S - 1 + hs);
                    DB += (1 - hs) * ht * (S - 1);
                }

                return DA / DB;
            }

            public static double Fst_Jost2008(SUBPOP[] subpops)
            {
                //D
                if (subpops.Length <= 1) return 0;

                int L = subpops[0].L;
                double DA = 0, DB = 0;
                for (int l = 0; l < L; ++l)
                {
                    if (subpops[0].loc[l].freq.Count < 2) continue;

                    double ht = 0, hs = 0;
                    int S = 0, nt = 0;
                    Dictionary<int, double> allele = SUBPOP.UniteFrequency(subpops, l, ref nt);

                    foreach (SUBPOP tp in subpops)
                    {
                        int ns = tp.loc[l].nhaplotypes;
                        if (ns == 0) continue;
                        hs += (1 - SumSquare(tp.loc[l].freq)) * ns;
                        S++;
                    }

                    if (S < 2) continue;
                    hs /= nt;
                    ht = 1 - SumSquare(allele);
                    DA += (ht - hs) * S;
                    DB += ht * (S - 1);
                }

                return DA / DB;
            }

            public static void TestDiffPhenotype(SUBPOP[] pops, StreamWriter wt, StringBuilder re, Random rnd, DiffType type, int rl)
            {
                if (pops.Length < 2) return;

                int ploidy = pops[0].ploidy;
                foreach (SUBPOP p in pops)
                    if (p.ploidy != ploidy) return;

                double gt = 0, dft = 0, gp = 0;
                int L = pops[0].L, S = pops.Length;
                double[] g = new double[L], df = new double[L], pval = new double[L];
                double[] p2 = new double[L], se = new double[L], c = new double[S];
                int[] switches = new int[L];
                double[][,] obs = new double[L][,];

                for (int l = 0; l < L; ++l)
                {
                    Dictionary<uint, double> hash = new Dictionary<uint, double>();
                    double ct = 0;
                    int Strue = 0;
                    for (int i = 0; i < S; ++i)
                    {
                        c[i] = 0;
                        SUBPOP s = pops[i];
                        foreach (PHENOTYPE ph in s.phenotype[l].Values)
                        {
                            if (ph.count > 0)
                            {
                                c[i] += ph.count;
                                if (!hash.ContainsKey(ph.hash))
                                    hash[ph.hash] = 0;
                                hash[ph.hash] += ph.count;
                            }
                        }
                        ct += c[i];
                        if (c[i] > 0)
                            Strue++;
                    }

                    obs[l] = new double[Strue, hash.Count];

                    int hi = 0;
                    foreach (uint h in hash.Keys)
                    {
                        if (h == 0) continue; //bug fixed @ 20200731, don't count empty phenotypes
                        for (int i = 0, i2 = 0; i < S; ++i)
                        {
                            if (c[i] == 0) continue;
                            SUBPOP s = pops[i];
                            obs[l][i2, hi] = s.phenotype[l].ContainsKey(h) ? s.phenotype[l][h].count : 0;
                            i2++;
                        }
                        hi++;
                    }

                    CombineTable(obs[l], null, ref df[l], ref g[l], ref pval[l], ref p2[l], DIFF_TESTPERM, rnd, ref se[l], ref switches[l], DIFF_BURNIN, DIFF_BATCHES, DIFF_ITERATIONS);//OK

                    gt += g[l];
                    dft += df[l];
                }
                gp = 1 - ChiSquareDistCDF(gt, dft);

                switch (type)
                {
                    case DiffType.AmongRegsInTot: Append(wt, re, "Among all regions level " + (rl + 1) + "\t"); break;
                    case DiffType.AmongPopsInTot: Append(wt, re, "Among all populations\t"); break;
                    case DiffType.AmongPopsInReg:
                        if (rl == 0)
                            Append(wt, re, "Among all populations in " + pops[0].region.name + "\t");
                        else
                            Append(wt, re, "Among all regions level " + rl + " in " + pops[0].region.name + "\t");
                        break;
                    case DiffType.BetweenRegs: Append(wt, re, pops[0].name + "\t" + pops[1].name); break;
                    case DiffType.BetweenPops: Append(wt, re, pops[0].name + "\t" + pops[1].name); break;
                }

                //global test res
                Append(wt, re, "\t" + gt.ToString(DECIMAL));
                Append(wt, re, "\t" + dft.ToString("F0"));
                Append(wt, re, "\t" + gp.ToString(DECIMAL));

                for (int l = 0; l < L; ++l)
                {
                    Append(wt, re, "\t" + g[l].ToString(DECIMAL));
                    Append(wt, re, "\t" + df[l].ToString("F0"));
                    Append(wt, re, "\t" + pval[l].ToString(DECIMAL));

                    if (DIFF_TESTPERM)
                    {
                        Append(wt, re, "\t" + switches[l]);
                        Append(wt, re, "\t" + se[l].ToString(DECIMAL));
                        Append(wt, re, "\t" + p2[l].ToString(DECIMAL));
                    }
                }
                Append(wt, re, "\r\n");
            }

            public static void TestDiffAllele(SUBPOP[] pops, LOC[] loc, StreamWriter wt, StringBuilder re, Random rnd, DiffType type)
            {
                if (pops.Length < 2) return;
                //bool REMOVE_PHENO_EXP3 = false;

                double gt = 0, dft = 0, gp = 0;
                int L = pops[0].L, S = pops.Length;
                double[] g = new double[L], df = new double[L], pval = new double[L];
                double[] p2 = new double[L], se = new double[L];
                int[] switches = new int[L];

                for (int l = 0; l < L; ++l)
                {
                    int K = 0, Strue = 0;
                    double ct = 0;
                    Dictionary<int, int> Kidx = new Dictionary<int, int>();
                    foreach (int a in loc[l].freq.Keys)
                    {
                        bool flag = false;
                        for (int i = 0; i < S; ++i)
                        {
                            if (pops[i].loc[l].freq[a] > 0)
                            {
                                flag = true;
                                Kidx[a] = K;
                                break;
                            }
                        }
                        if (flag)
                            K++;
                    }

                    foreach (SUBPOP s in pops)
                        if (s.loc[l].nhaplotypes > 0)
                            Strue++;

                    double[,] obs = new double[Strue, K];
                    for (int i = 0, i2 = 0; i < S; ++i)
                    {
                        SUBPOP s = pops[i];
                        if (s.loc[l].nhaplotypes == 0) continue;
                        foreach (int a in s.loc[l].freq.Keys)
                            if (Kidx.ContainsKey(a))
                                obs[i2, Kidx[a]] = s.loc[l].freq[a] * s.loc[l].nhaplotypes;
                        ct += s.loc[l].nhaplotypes;
                        i2++;
                    }

                    foreach (int a in loc[l].freq.Keys)
                    {
                        if (!Kidx.ContainsKey(a)) continue;
                        double ot = 0;
                        foreach (SUBPOP s in pops)
                            ot += s.loc[l].freq[a] * s.loc[l].nhaplotypes;

                        for (int i = 0, i2 = 0; i < S; ++i)
                        {
                            SUBPOP s = pops[i];
                            if (s.loc[l].nhaplotypes == 0) continue;
                            obs[i2, Kidx[a]] = s.loc[l].freq[a] * s.loc[l].nhaplotypes;
                            i2++;
                        }
                    }

                    CombineTable(obs, null, ref df[l], ref g[l], ref pval[l], ref p2[l], DIFF_TESTPERM,
                                 rnd, ref se[l], ref switches[l], DIFF_BURNIN, DIFF_BATCHES, DIFF_ITERATIONS);//OK

                    gt += g[l];
                    dft += df[l];
                }
                gp = 1 - ChiSquareDistCDF(gt, dft);

                switch (type)
                {
                    case DiffType.AmongRegsInTot: Append(wt, re, "Among all regions\t"); break;
                    case DiffType.AmongPopsInTot: Append(wt, re, "Among all populations\t"); break;
                    case DiffType.AmongPopsInReg: Append(wt, re, "Among all populations in " + pops[0].name + "\t"); break;
                    case DiffType.BetweenRegs: Append(wt, re, pops[0].name + "\t" + pops[1].name); break;
                    case DiffType.BetweenPops: Append(wt, re, pops[0].name + "\t" + pops[1].name); break;
                }

                //global test res
                Append(wt, re, "\t" + gt.ToString(DECIMAL));
                Append(wt, re, "\t" + dft.ToString("F0"));
                Append(wt, re, "\t" + gp.ToString(DECIMAL));

                for (int l = 0; l < L; ++l)
                {
                    Append(wt, re, "\t" + g[l].ToString(DECIMAL));
                    Append(wt, re, "\t" + df[l].ToString("F0"));
                    Append(wt, re, "\t" + pval[l].ToString(DECIMAL));

                    if (DIFF_TESTPERM)
                    {
                        Append(wt, re, "\t" + switches[l]);
                        Append(wt, re, "\t" + se[l].ToString(DECIMAL));
                        Append(wt, re, "\t" + p2[l].ToString(DECIMAL));
                    }
                }
                Append(wt, re, "\r\n");
            }

            public void CalcFstThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                SUBPOP[] subpops = (SUBPOP[])((object[])obj)[2];
                FstEstimator estimator = (FstEstimator)((object[])obj)[4];
                FstType type = (FstType)((object[])obj)[5];

                if (type == FstType.Among)
                {
                    double[] fst1 = (double[])((object[])obj)[3];
                    for (int i = 0, c = 0; i < subpops.Length; ++i)
                    {
                        if (c++ % nthreads != id) continue;
                        fst1[i] = GetFst(subpops[i].subpops, estimator);
                        Increment();
                    }
                }
                else
                {
                    double[,] fst = (double[,])((object[])obj)[3];
                    for (int i = 0, c = 0; i < subpops.Length; ++i)
                    {
                        for (int j = 0; j < i; ++j)
                        {
                            if (c++ % nthreads != id) continue;
                            fst[i, j] = fst[j, i] = GetFst(new SUBPOP[] { subpops[i], subpops[j] }, estimator);
                            Increment();
                        }
                    }
                }
            }

            public void TestPhenoThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                SUBPOP[] subpops = (SUBPOP[])((object[])obj)[2];
                StringBuilder[] Sb2 = (StringBuilder[])((object[])obj)[3];
                DiffType type = (DiffType)((object[])obj)[4];
                int rl = (int)((object[])obj)[5];

                int c = 0, i = 0;
                if (type == DiffType.AmongPopsInReg)
                {
                    for (; i < subpops.Length; ++i)
                    {
                        if (c++ % nthreads != id) continue;
                        Random rnd = new Random(SEED ^ (c + 0x6E0BE46A));//bug fixed on 20220324
                        TestDiffPhenotype(subpops[i].subpops, null, Sb2[c - 1] = new StringBuilder(), rnd, type, rl);
                        Increment();
                    }
                }
                else
                {
                    for (; i < subpops.Length; ++i)
                    {
                        for (int j = i + 1; j < subpops.Length; ++j)
                        {
                            if (c++ % nthreads != id) continue;
                            Random rnd = new Random(SEED ^ (c + 0x4FA0CF8B));//bug fixed on 20220324
                            TestDiffPhenotype(new SUBPOP[] { subpops[i], subpops[j] }, null, Sb2[c - 1] = new StringBuilder(), rnd, type, -1);
                            Increment();
                        }
                    }
                }
            }

            public void TestAlleleThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                SUBPOP[] subpops = (SUBPOP[])((object[])obj)[2];
                StringBuilder[] Sb = (StringBuilder[])((object[])obj)[3];
                DiffType type = (DiffType)((object[])obj)[4];

                int c = 0, i = 0;
                if (type == DiffType.AmongPopsInReg)
                {
                    for (; i < subpops.Length; ++i)
                    {
                        if (c++ % nthreads != id) continue;
                        Random rnd = new Random(SEED ^ (c + 0x5081C146));//bug fixed on 20220324
                        SUBPOP tr = subpops[i];
                        Sb[c - 1] = new StringBuilder();
                        TestDiffAllele(tr.subpops, total_pop.loc, null, Sb[c - 1], rnd, type);
                        Increment();
                    }
                }
                else
                {
                    for (; i < subpops.Length; ++i)
                    {
                        SUBPOP tp = subpops[i];
                        for (int j = i + 1; j < subpops.Length; ++j)
                        {
                            if (c++ % nthreads != id) continue;
                            Random rnd = new Random(SEED ^ (c + 0x5A46025E));//bug fixed on 20220324
                            SUBPOP tp2 = subpops[j];
                            Sb[c - 1] = new StringBuilder();
                            TestDiffAllele(new SUBPOP[] { tp, tp2 }, total_pop.loc, null, Sb[c - 1], rnd, type);
                            Increment();
                        }
                    }
                }
            }

            public static void Append(StreamWriter wt, StringBuilder re, string a)
            {
                if (wt != null) wt.Write(a);
                if (re != null) re.Append(a);
            }

            public void CalcDiff()
            {
                Progress = "Calculating genetic differentation";
                ProgressValue = 0;
                ProgressMax =
                        ((CALC_DIFF && DIFF_REG || (CALC_DIST && DIST_REG && (DIST_Reynolds1983 || DIST_Slatkin1995))) ? region_dyad_count / 2 : 0) +
                        ((CALC_DIFF && DIFF_POP || (CALC_DIST && DIST_POP && (DIST_Reynolds1983 || DIST_Slatkin1995))) ? subpops.Length * (subpops.Length - 1) / 2 : 0) +
                        (CALC_DIFF && DIFF_TOT && DIFF_POP ? 1 : 0) +
                        (CALC_DIFF && DIFF_TOT && DIFF_REG ? region_count : 0) +
                        (CALC_DIFF && DIFF_REG && DIFF_POP ? region_count : 0);
                RFST = regions.Length > 0 ? new List<double[,]>[regions.Length - 1] : null;
                if (ProgressMax == 0) return;

                List<int>[] allele = new List<int>[L];
                double[,] fst = new double[subpops.Length, subpops.Length];
                double[][,] rfst = regions.Length == 0 ? null : new double[regions.Length - 1][,];
                double[][] scfst = regions.Length == 0 ? null : new double[regions.Length - 1][];
                for (int rl = 0; rl < regions.Length - 1; ++rl)
                {
                    rfst[rl] = new double[regions[rl].Length, regions[rl].Length];
                    scfst[rl] = new double[regions[rl].Length];
                }
                double stfst = 0;
                double[] ctfst = regions.Length == 0 ? null : new double[regions.Length - 1];

                StreamWriter wt = new StreamWriter(new FileStream("o_differentation.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_DIFFERENTIATION = wt;

                ////Fst
                bool[] method = new bool[]{
                    DIFF_Huang2018IAM, DIFF_Huang2018SMM, DIFF_Slatkin1995, DIFF_Nei1973, DIFF_Hudson1992, DIFF_Hedrick2005, DIFF_Jost2008, DIFF_Huang2019 };
                string[] method_name = new string[]{
                    "Huang et al. 2021 Weight Genotype IAM", "Huang et al. 2021 Weight Genotype SMM", "Slatkin 1995 Rst", "Nei 1973 Gst",  "Hudson 1992",  "Hedrick 2005 G'st",  "Jost 2008 D",  "Huang et al. unpub" };

                int count = 0;
                for (int i = 0; i < method.Length; ++i)
                    if (method[i]) count++;
                ProgressMax *= count;
                SetProgress(ProgressValue, ProgressMax);

                for (int m = 0; m < method.Length; ++m)
                {
                    if (!method[m]) continue;

                    if (CALC_DIFF && DIFF_TOT && DIFF_REG)
                    {
                        //among regs in total
                        for (int rl = 0; rl < regions.Length - 1; ++rl)
                        {
                            ctfst[rl] = GetFst(regions[rl], (FstEstimator)m);
                            Increment();
                        }
                    }

                    if (CALC_DIFF && DIFF_TOT && DIFF_POP)
                    {
                        //among pops in total
                        stfst = GetFst(subpops, (FstEstimator)m);
                        Increment();
                    }

                    if (CALC_DIFF && DIFF_REG && DIFF_POP)
                    {
                        //among pops/subregions in reg
                        for (int rl = 0; rl < regions.Length - 1; ++rl)
                            CallThread(CalcFstThread, N_THREAD,
                                       new object[] { regions[rl], scfst[rl], (FstEstimator)m, FstType.Among },
                            ProgressValue + regions[rl].Length, ref ProgressValue);
                    }

                    if (CALC_DIFF && DIFF_REG || (CALC_DIST && DIST_REG && (DIST_Reynolds1983 || DIST_Slatkin1995)))
                    {
                        //between regions
                        if (regions.Length > 0)
                        {
                            for (int rl = 0; rl < regions.Length - 1; ++rl)
                            {
                                RFST[rl] = new List<double[,]>();
                                CallThread(CalcFstThread, N_THREAD,
                                           new object[] { regions[rl], rfst[rl], (FstEstimator)m, FstType.Between },
                                ProgressValue + regions[rl].Length * (regions[rl].Length - 1) / 2, ref ProgressValue);
                                RFST[rl].Add(Clone(rfst[rl]));
                                FSTNAME.Add(method_name[m]);
                            }
                        }
                    }

                    if (CALC_DIFF && DIFF_POP || (CALC_DIST && DIST_POP && (DIST_Reynolds1983 || DIST_Slatkin1995)))
                    {
                        //between pops
                        CallThread(CalcFstThread, N_THREAD,
                                   new object[] { subpops, fst, (FstEstimator)m, FstType.Between },
                        ProgressValue + subpops.Length * (subpops.Length - 1) / 2, ref ProgressValue);
                        PFST.Add(Clone(fst));
                        FSTNAME.Add(method_name[m]);
                    }

                    wt.Write("Method: " + method_name[m]);

                    if (CALC_DIFF && DIFF_TOT && DIFF_REG)
                        for (int rl = regions.Length - 2; rl >= 0; --rl)
                            wt.Write("\r\nAmong all regions level " + (rl + 1) + " = " + ctfst[rl].ToString(DECIMAL) + "\r\n");

                    if (CALC_DIFF && DIFF_TOT && DIFF_POP)
                        wt.Write("\r\nAmong all populations = " + stfst.ToString(DECIMAL) + "\r\n");

                    if (CALC_DIFF && DIFF_REG && DIFF_POP)
                        for (int rl = regions.Length - 2; rl >= 0; --rl)
                            for (int i = 0; i < regions[rl].Length; ++i)
                                if (rl == 0)
                                    wt.Write("\r\nAmong all populations in " + regions[rl][i].name + " = " + scfst[rl][i].ToString(DECIMAL) + "\r\n");
                                else
                                    wt.Write("\r\nAmong all regions level " + rl + " in " + regions[rl][i].name + " = " + scfst[rl][i].ToString(DECIMAL) + "\r\n");

                    if (CALC_DIFF && DIFF_REG)
                    {
                        for (int rl = regions.Length - 2; rl >= 0; --rl)
                        {
                            wt.Write("\r\nBetween regions level " + (rl + 1) + ":");
                            for (int i = 0; i < regions[rl].Length; ++i)
                                wt.Write("\t" + regions[rl][i].name);
                            wt.Write("\r\n");

                            for (int i = 0; i < regions[rl].Length; ++i)
                            {
                                SUBPOP tr = regions[rl][i];
                                wt.Write(tr.name);
                                for (int j = 0; j < regions[rl].Length; ++j)
                                {
                                    SUBPOP tr2 = regions[rl][j];
                                    wt.Write("\t" + rfst[rl][i, j].ToString(DECIMAL));
                                }
                                wt.Write("\r\n");
                            }
                        }
                    }

                    if (CALC_DIFF && DIFF_POP)
                    {
                        wt.Write("\r\nBetween populations:");
                        for (int i = 0; i < subpops.Length; ++i)
                            wt.Write("\t" + subpops[i].name);
                        wt.Write("\r\n");

                        for (int i = 0; i < subpops.Length; ++i)
                        {
                            SUBPOP tp = subpops[i];
                            wt.Write(tp.name);
                            for (int j = 0; j < subpops.Length; ++j)
                            {
                                SUBPOP tp2 = subpops[j];
                                wt.Write("\t" + fst[i, j].ToString(DECIMAL));
                            }
                            wt.Write("\r\n");
                        }
                    }

                    wt.Write("\r\n\r\n");
                }


                //Test differentation
                Progress = "Testing genetic differentation";
                ProgressValue = 0;
                ProgressMax =
                    ((DIFF_REG && DIFF_TOT ? 1 : 0) +
                     (DIFF_POP && DIFF_TOT ? 1 : 0) +
                     (DIFF_POP && DIFF_REG && region_count > 0 ? region_count - 1 : 0) +
                     (DIFF_REG ? region_dyad_count : 0) +
                     (DIFF_POP ? region_dyad_count : 0)) *
                        ((CALC_DIFF && DIFF_TESTALLELE ? 1 : 0) + (CALC_DIFF && DIFF_TESTPHENO ? 1 : 0));
                SetProgress(ProgressValue, ProgressMax);

                //test

                if (CALC_DIFF && DIFF_TESTPHENO)
                {
                    //Header
                    wt.Write(ISGENOTYPE ? "Genotypic differentiation test\r\n" : "Phenotypic differentiation test\r\n");//OK
                    StringBuilder sb2 = new StringBuilder();

                    wt.Write("\t\tAll loci\t\t\t");
                    for (int l = 0; l < L; ++l)
                    {
                        wt.Write(total_pop.loc[l].name + "\t\t\t");
                        if (DIFF_TESTPERM)
                            wt.Write("\t\t\t");
                    }
                    wt.Write("\r\n\t\tFisher's G test\t\t\t");
                    for (int l = 0; l < L; ++l)
                    {
                        wt.Write("Fisher's G test\t\t\t");
                        if (DIFF_TESTPERM)
                            wt.Write("Raymond & Rousset's test\t\t\t");
                    }

                    wt.Write("\r\nA\tB\tG\td.f.\tP");
                    for (int l = 0; l < L; ++l)
                    {
                        wt.Write("\tG\td.f.\tP");
                        if (DIFF_TESTPERM)
                            wt.Write("\tswitches\tS.E.\tP");
                    }
                    wt.Write("\r\n");

                    if (DIFF_REG && DIFF_TOT)
                    {
                        //among regions in total
                        for (int rl = regions.Length - 2; rl >= 0; --rl)
                        {
                            TestDiffPhenotype(regions[rl], wt, null, new Random(SEED), DiffType.AmongRegsInTot, rl);
                            Increment();
                        }
                    }

                    if (DIFF_POP && DIFF_TOT)
                    {
                        //among pops in total
                        TestDiffPhenotype(subpops, wt, null, new Random(SEED), DiffType.AmongPopsInTot, -1);
                        Increment();
                    }

                    if (DIFF_POP && DIFF_REG)
                    {
                        //among pops/subregions in region
                        for (int rl = regions.Length - 1; rl >= 0; --rl)
                        {
                            StringBuilder[] Sb2 = new StringBuilder[regions[rl].Length];

                            CallThread(TestPhenoThread, N_THREAD,
                                       new object[] { regions[rl], Sb2, DiffType.AmongPopsInReg, rl },
                            ProgressValue + regions[rl].Length * 1, ref ProgressValue);

                            foreach (StringBuilder s in Sb2)
                                wt.Write(s);
                        }
                    }

                    if (DIFF_REG)
                    {
                        //between region pairs
                        for (int rl = regions.Length - 1; rl >= 0; --rl)
                        {
                            StringBuilder[] Sb2 = new StringBuilder[regions[rl].Length * (regions[rl].Length - 1) / 2];

                            CallThread(TestPhenoThread, N_THREAD,
                                       new object[] { regions[rl], Sb2, DiffType.BetweenRegs, -1 },
                            ProgressValue + regions[rl].Length * (regions[rl].Length - 1) / 2 * 1, ref ProgressValue);

                            foreach (StringBuilder s in Sb2)
                                wt.Write(s);
                        }
                    }

                    if (DIFF_POP)
                    {
                        //between pops pairs
                        StringBuilder[] Sb2 = new StringBuilder[subpops.Length * (subpops.Length - 1) / 2];

                        CallThread(TestPhenoThread, N_THREAD,
                                   new object[] { subpops, Sb2, DiffType.BetweenPops, -1 },
                        ProgressValue + subpops.Length * (subpops.Length - 1) / 2 * 1, ref ProgressValue);

                        foreach (StringBuilder s in Sb2)
                            wt.Write(s);
                    }

                    wt.Write("\r\n\r\n");
                }

                if (CALC_DIFF && DIFF_TESTALLELE)
                {
                    //Header
                    wt.Write("Allelic differentiation test\r\n");

                    wt.Write("\t\tAll loci\t\t\t");
                    for (int l = 0; l < L; ++l)
                    {
                        wt.Write(total_pop.loc[l].name + "\t\t\t");
                        if (DIFF_TESTPERM)
                            wt.Write("\t\t\t");
                    }
                    wt.Write("\r\n\t\tFisher's G test\t\t\t");
                    for (int l = 0; l < L; ++l)
                    {
                        wt.Write("Fisher's G test\t\t\t");
                        if (DIFF_TESTPERM)
                            wt.Write("Raymond & Rousset's test\t\t\t");
                    }

                    wt.Write("\r\nA\tB\tG\td.f.\tP");
                    for (int l = 0; l < L; ++l)
                    {
                        wt.Write("\tG\td.f.\tP");
                        if (DIFF_TESTPERM)
                            wt.Write("\tswitches\tS.E.\tP");
                    }
                    wt.Write("\r\n");

                    if (DIFF_REG && DIFF_TOT)
                    {
                        //among regions in total
                        for (int rl = regions.Length - 2; rl >= 0; --rl)
                        {
                            TestDiffAllele(regions[rl], total_pop.loc, wt, null, new Random(SEED), DiffType.AmongRegsInTot);
                            Increment();
                        }
                    }

                    if (DIFF_POP && DIFF_TOT)
                    {
                        //among pops in total
                        TestDiffAllele(subpops, total_pop.loc, wt, null, new Random(SEED), DiffType.AmongPopsInTot);
                        Increment();
                    }

                    if (DIFF_POP && DIFF_REG)
                    {
                        //among pops/subregions in reg
                        for (int rl = regions.Length - 1; rl >= 0; --rl)
                        {
                            StringBuilder[] Sb = new StringBuilder[regions[rl].Length];
                            CallThread(TestAlleleThread, N_THREAD,
                                       new object[] { regions[rl], Sb, DiffType.AmongPopsInReg },
                            ProgressValue + regions[rl].Length, ref ProgressValue);

                            foreach (StringBuilder s in Sb) wt.Write(s);
                        }
                    }

                    if (DIFF_REG)
                    {
                        //between regions
                        for (int rl = regions.Length - 2; rl >= 0; --rl)
                        {
                            StringBuilder[] Sb = new StringBuilder[regions[rl].Length * (regions[rl].Length - 1) / 2];

                            CallThread(TestAlleleThread, N_THREAD,
                                       new object[] { regions[rl], Sb, 4 },
                            ProgressValue + regions[rl].Length * (regions[rl].Length - 1) / 2, ref ProgressValue);

                            foreach (StringBuilder s in Sb) wt.Write(s);
                        }
                    }

                    if (DIFF_POP)
                    {
                        //between pops
                        StringBuilder[] Sb = new StringBuilder[subpops.Length * (subpops.Length - 1) / 2];

                        CallThread(TestAlleleThread, N_THREAD,
                                   new object[] { subpops, Sb, 5 },
                        ProgressValue + subpops.Length * (subpops.Length - 1) / 2, ref ProgressValue);

                        foreach (StringBuilder s in Sb) wt.Write(s);
                    }
                }

                wt.Flush();
                wt.Close();
            }

            #endregion

            #region Dist
            public class DIST
            {
                public string title;
                public int n;
                public string[] names;//
                public double[,] dist;
                public int[] color;//
            }

            public class ORDINATION : DIST
            {
                public OrdinationType type; 
                public int maxp;
                public double[,] coordinate;
                public double[] variance;

                public ORDINATION()
                {

                }

                public ORDINATION(IND[] inds, LOC[] loc, int nalleles)
                {
                    n = inds.Length;
                    type = OrdinationType.PCA;
                    title = "Individual: PCA";

                    names = new string[n];
                    color = new int[n];
                    dist = new double[n, nalleles];
                    for (int i = 0; i < n; ++i)
                    {
                        names[i] = inds[i].name;
                        color[i] = inds[i].subpop.id;
                        for (int l = 0, ai = 0; l < loc.Length; ++l)
                            foreach (int a in loc[l].freq.Keys)
                                dist[i, ai++] = GetMissingFreq(inds[i], l, a);
                    }
                }

                public ORDINATION(SUBPOP[] subpops, LOC[] loc, int nalleles, string _title)
                {
                    n = subpops.Length;
                    type = OrdinationType.PCA;
                    title = _title;

                    names = new string[n];
                    color = new int[n];
                    dist = new double[n, nalleles];
                    for (int i = 0; i < n; ++i)
                    {
                        names[i] = subpops[i].name;
                        color[i] = subpops[i].region == null ? 0 : subpops[i].region.id;
                        for (int l = 0, ai = 0; l < loc.Length; ++l)
                            foreach (int a in loc[l].freq.Keys)
                                dist[i, ai++] = GetDictionaryValue(subpops[i].loc[l].freq, a);
                    }
                }

                public ORDINATION(DIST d)
                {
                    n = d.n;
                    title = d.title.Replace(": ", ": PCoA with ");
                    names = d.names;
                    dist = d.dist;
                    color = d.color;
                }

                public double EuclideanDist(double[,] x, int i, int j)
                {
                    double re = 0;
                    int p = x.GetLength(1);
                    for (int k = 0; k < p; ++k)
                        re += (x[i, k] - x[j, k]) * (x[i, k] - x[j, k]);
                    return Math.Sqrt(re);
                }

                public string Array2String(double[,] x)
                {
                    int m = x.GetLength(0);
                    int n = x.GetLength(1);

                    StringBuilder re = new StringBuilder();
                    for (int i = 0; i < m; ++i)
                    {
                        for (int j = 0; j < n; ++j)
                            re.Append(x[i, j].ToString("F4") + "\t");
                        re.Append("\r\n");
                    }

                    return re.ToString();
                }

                public void pca(StringBuilder re, int ndim)
                {
                    re.AppendLine(title);

                    int np = dist.GetLength(1);
                    maxp = Math.Min(np, ndim);
                    double[,] cov = new double[np, np];
                    double Vt = 0;
                    int ninds = dist.GetLength(0);

                    // Calculate covariance matrix
                    if (ninds > 1)
                        for (int i = 0; i < np; ++i)
                        {
                            for (int j = 0; j <= i; ++j)
                            {
                                double ex = 0, ey = 0, exy = 0;
                                int ndata = 0;
                                for (int k = 0; k < n; ++k)
                                {
                                    if (double.IsNaN(dist[k, i]) || double.IsNaN(dist[k, j])) continue;
                                    ndata++;
                                    ex += dist[k, i];
                                    ey += dist[k, j];
                                    exy += dist[k, i] * dist[k, j];
                                }
                                if (ndata == 0) continue;
                                ex /= ndata;
                                ey /= ndata;
                                exy /= ndata;

                                cov[i, j] = cov[j, i] = (exy - ex * ey) * ninds / (ninds - 1);
                                if (i == j) Vt += cov[i, j];
                            }
                        }
                    else
                        Vt = double.NaN;

                    var M = LinearAlgebra.Matrix<double>.Build;
                    var uv = M.DenseOfArray(cov).Evd(LinearAlgebra.Symmetricity.Symmetric);

                    // Sort by eigen-values in descending order
                    var U = uv.EigenVectors;
                    var V = uv.EigenValues;

                    int[] idx = GetIdxSeq(V.Count);
                    int nz = V.Count(o => o.Real > 0 && Math.Abs(o.Imaginary) < 1e-6);

                    for (int i = 0; i < V.Count; ++i)
                        for (int j = i + 1; j < V.Count; ++j)
                            if (V[idx[i]].Real - Math.Abs(V[idx[i]].Imaginary) < V[idx[j]].Real - Math.Abs(V[idx[j]].Imaginary))
                            {
                                int ti = idx[i];
                                idx[i] = idx[j];
                                idx[j] = ti;
                            }

                    // Copy
                    maxp = Math.Min(nz, maxp);
                    double[,] eigenvector = new double[np, maxp];
                    for (int i = 0; i < np; ++i)
                        for (int j = 0; j < maxp; ++j)
                            eigenvector[i, j] = U[i, idx[j]];
                    
                    if (ninds > 1)
                    {
                        coordinate = (M.DenseOfArray(dist) * M.DenseOfArray(eigenvector)).ToArray();


                        // Coordinate with maximum absoulte value should be positive (to consistent with pca)
                        for (int j = 0; j < maxp; ++j)
                        {
                            int maxid = 0;
                            double maxabs = -1;
                            for (int i = 0; i < n; ++i)
                            {
                                if (Math.Abs(coordinate[i, j]) > maxabs)
                                {
                                    maxabs = Math.Abs(coordinate[i, j]);
                                    maxid = i;
                                }
                            }

                            if (coordinate[maxid, j] < 0)
                            {
                                for (int i = 0; i < n; ++i)
                                    coordinate[i, j] = -coordinate[i, j];
                            }
                        }

                        variance = new double[maxp];
                        for (int j = 0; j < maxp; ++j)
                            variance[j] = V[idx[j]].Real;
                    }

                    re.Append("Transformed coordinate");
                    for (int j = 0; j < maxp; ++j)
                        re.Append("\tPC" + (j + 1));
                    re.Append("\r\n");
                    for (int i = 0; i < n; ++i)
                    {
                        re.Append(names[i]);
                        for (int j = 0; j < maxp; ++j)
                            re.Append("\t" + coordinate[i, j].ToString(DECIMAL));
                        re.Append("\r\n");
                    }

                    re.Append("Eigenvector");
                    for (int j = 0; j < maxp; ++j)
                        re.Append("\tPC" + (j + 1));
                    re.Append("\r\n");
                    for (int i = 0; i < np; ++i)
                    {
                        for (int j = 0; j < maxp; ++j)
                            re.Append("\t" + eigenvector[i, j].ToString(DECIMAL));
                        re.Append("\r\n");
                    }

                    re.Append("\r\nTotal variance\t" + Vt.ToString(DECIMAL));

                    re.Append("\r\nVariance");
                    for (int j = 0; j < maxp; ++j)
                        re.Append("\t" + variance[j].ToString(DECIMAL));

                    re.Append("\r\n% Variance");
                    for (int j = 0; j < maxp; ++j)
                        re.Append("\t" + (variance[j] / Vt * 100).ToString(DECIMAL));

                    re.Append("\r\nCumulative % Variance");
                    double Cumu = 0;
                    for (int j = 0; j < maxp; ++j)
                    {
                        Cumu += variance[j];
                        re.Append("\t" + (Cumu / Vt * 100).ToString(DECIMAL));
                    }

                    re.Append("\r\n\r\n");
                }

                public void pcoa(StringBuilder re, int ndim)
                {
                    re.AppendLine(title);

                    maxp = Math.Min(n, ndim);
                    double[,] D = Clone(dist);
                    double[,] C = new double[n, n];

                    // Maximum normal distance
                    double ma = 0;
                    for (int i = 0; i < n; ++i)
                        for (int j = i; j < n; ++j)
                            if (ma < D[i, j] && D[i, j] < 1e300)
                                ma = D[i, j];

                    // Check distances
                    for (int i = 0; i < n; ++i)
                        for (int j = i; j < n; ++j)
                        {
                            if (D[i, j] < 0 || double.IsInfinity(D[i, j]) || double.IsNaN(D[i, j]))
                                D[i, j] = D[j, i] = 0;
                            if (D[i, j] > 1e300)
                                D[i, j] = D[j, i] = ma * 1.2;
                        }

                    // Total variance
                    double Vt = 0;
                    for (int i = 0; i < n; ++i)
                        for (int j = 0; j < i; ++j)
                            Vt += D[i, j] * D[i, j];
                    Vt /= n * (n - 1);

                    // Centering
                    for (int i = 0; i < n; ++i)
                        for (int j = 0; j < n; ++j)
                            D[i, j] = -0.5 * D[i, j] * D[i, j];

                    SetVal(C, -1.0 / n);
                    for (int i = 0; i < n; ++i)
                        C[i, i] = 1 - 1.0 / n;

                    var M = LinearAlgebra.Matrix<double>.Build;
                    var G = M.DenseOfArray(C) * M.DenseOfArray(D) * M.DenseOfArray(C);
                    var uv = G.Evd(LinearAlgebra.Symmetricity.Symmetric);

                    // Sort by eigen values in descending order
                    var U = uv.EigenVectors;
                    var V = uv.EigenValues;

                    int[] idx = GetIdxSeq(V.Count);
                    int nz = V.Count(o => o.Real > 0 && Math.Abs(o.Imaginary) < 1e-6);

                    for (int i = 0; i < V.Count; ++i)
                        for (int j = i + 1; j < V.Count; ++j)
                            if (V[idx[i]].Real - Math.Abs(V[idx[i]].Imaginary) < V[idx[j]].Real - Math.Abs(V[idx[j]].Imaginary))
                            {
                                int ti = idx[i];
                                idx[i] = idx[j];
                                idx[j] = ti;
                            }

                    maxp = Math.Min(nz, maxp);

                    re.Append("\r\nTransformed coordinate");
                    for (int j = 0; j < maxp; ++j)
                        re.Append("\tPC" + (j + 1));
                    re.Append("\r\n");

                    // Eigen-vectors
                    coordinate = new double[n, maxp];

                    // Eigen-values
                    variance = new double[maxp];

                    // Calculate coordinates
                    for (int i = 0; i < n; ++i)
                        for (int j = 0; j < maxp; ++j)
                            coordinate[i, j] = U[i, idx[j]];

                    // Coordinate with maximum absoulte value should be positive (to consistent with pca)
                    for (int j = 0; j < maxp; ++j)
                    {
                        int maxid = 0;
                        double maxabs = -1;
                        for (int i = 0; i < n; ++i)
                        {
                            if (Math.Abs(coordinate[i, j]) > maxabs)
                            {
                                maxabs = Math.Abs(coordinate[i, j]);
                                maxid = i;
                            }
                        }

                        if (coordinate[maxid, j] < 0)
                        {
                            for (int i = 0; i < n; ++i)
                                coordinate[i, j] = -coordinate[i, j];
                        }
                    }

                    for (int i = 0; i < n; ++i)
                    {
                        re.Append(names[i]);
                        for (int j = 0; j < maxp; ++j)
                            re.Append("\t" + coordinate[i, j].ToString(DECIMAL));
                        re.Append("\r\n");
                    }

                    re.Append("\r\nTotal variance\t" + Vt.ToString(DECIMAL));

                    re.Append("\r\nVariance");
                    for (int j = 0; j < maxp; ++j)
                    {
                        variance[j] = V[idx[j]].Real / (n - 1);
                        re.Append("\t" + variance[j].ToString(DECIMAL));
                    }

                    re.Append("\r\n% Variance");
                    for (int j = 0; j < maxp; ++j)
                        re.Append("\t" + (variance[j] / Vt * 100).ToString(DECIMAL));

                    re.Append("\r\nCumulative % Variance");
                    double Cumu = 0;
                    for (int j = 0; j < maxp; ++j)
                    {
                        Cumu += variance[j];
                        re.Append("\t" + (Cumu / Vt * 100).ToString(DECIMAL));
                    }
                    re.Append("\r\n\r\n");
                }

                public Image DrawOrdination(ref byte[] VecFile, int picwidth, int picheight)
                {
                    if (variance == null || variance.Length < 2) return null;
                    double maxy = -1e300, miny = 1e300, rangey = 0; //PC1
                    double maxx = -1e300, minx = 1e300, rangex = 0; //PC2

                    int co0 = 0, co1 = 0;
                    try
                    {
                        string[] t = ORDINATION_AXES.Split(new char[] { ',', ' ', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);
                        int c0 = int.Parse(t[0]) - 1, c1 = int.Parse(t[1]) - 1;
                        if (c0 < coordinate.GetLength(1) && c1 < coordinate.GetLength(1))
                        {
                            co0 = c0;
                            co1 = c1;
                        }
                        else
                            MessageBox.Show("Error: axes exceed range, there are " + coordinate.GetLength(1) + " axes extracted.");
                    }
                    catch
                    {
                        MessageBox.Show("Error: Cannot parse axes string '" + ORDINATION_AXES + "'.");
                    }


                    for (int i = 0; i < n; ++i)
                    {
                        if (coordinate[i, co0] > maxx) maxx = coordinate[i, co0];
                        if (coordinate[i, co0] < minx) minx = coordinate[i, co0];
                        if (coordinate[i, co1] > maxy) maxy = coordinate[i, co1];
                        if (coordinate[i, co1] < miny) miny = coordinate[i, co1];
                    }

                    rangey = maxy - miny;
                    rangex = maxx - minx;
                    if (rangex == 0)
                    {
                        maxx += 1e-6;
                        minx -= 1e-6;
                    }
                    if (rangey == 0)
                    {
                        maxy += 1e-6;
                        miny -= 1e-6;
                    }

                    double zx = 0, zy = 0;
                    if (minx * maxx > 0) zx = (minx + maxx) / 2;
                    if (miny * maxy > 0) zy = (miny + maxy) / 2;

                    rangey = maxy - miny;
                    rangex = maxx - minx;

                    int margin = 30;
                    double yscale = (picheight - 2 * margin) / rangey;
                    double xscale = (picwidth - 2 * margin) / rangex;

                    Bitmap bmp = new Bitmap(picwidth, picheight);
                    //Vector
                    Stream ms = new MemoryStream();
                    Metafile mf = new Metafile(ms, Graphics.FromImage(bmp).GetHdc());
                    Graphics g = Graphics.FromImage(mf);

                    g.Clear(Color.White);

                    Pen a1 = new Pen(new SolidBrush(Color.Black), 2);
                    Pen a2 = new Pen(new SolidBrush(Color.Red), 2);
                    a2.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;
                    StringFormat stcenter = new StringFormat();
                    stcenter.Alignment = StringAlignment.Center;
                    stcenter.LineAlignment = StringAlignment.Center;
                    StringFormat stleft = new StringFormat();
                    stleft.Alignment = StringAlignment.Near;
                    stleft.LineAlignment = StringAlignment.Center;
                    StringFormat stright = new StringFormat();
                    stright.Alignment = StringAlignment.Far;
                    stright.LineAlignment = StringAlignment.Center;
                    StringFormat sttop = new StringFormat();
                    sttop.Alignment = StringAlignment.Center;
                    sttop.LineAlignment = StringAlignment.Near;
                    StringFormat stbottom = new StringFormat();
                    stbottom.Alignment = StringAlignment.Center;
                    stbottom.LineAlignment = StringAlignment.Far;

                    //x-axis line
                    g.DrawLine(
                        zy == 0 ? a1 : a2,
                        new PointF((float)(margin + (minx - minx) * xscale), (float)(picheight - margin - (zy - miny) * yscale)),
                        new PointF((float)(margin + (maxx - minx) * xscale), (float)(picheight - margin - (zy - miny) * yscale)));

                    //y-axis line
                    g.DrawLine(
                        zx == 0 ? a1 : a2,
                        new PointF((float)(margin + (zx - minx) * xscale), (float)(picheight - margin - (miny - miny) * yscale)),
                        new PointF((float)(margin + (zx - minx) * xscale), (float)(picheight - margin - (maxy - miny) * yscale)));

                    //minx
                    g.DrawString(minx.ToString(DECIMAL),
                                  new Font("Arial", ORDINATION_FONT_SIZE / DPI_SCALE),
                                  new SolidBrush(Color.Black),
                                  new RectangleF((float)(margin + (minx - minx) * xscale) - 150,
                                   (float)(picheight - margin - (zy - miny) * yscale),
                                   (float)(300),
                                   (float)(60)),
                                  sttop);

                    //maxx
                    g.DrawString(maxx.ToString(DECIMAL),
                                  new Font("Arial", ORDINATION_FONT_SIZE / DPI_SCALE),
                                  new SolidBrush(Color.Black),
                                  new RectangleF((float)(margin + (maxx - minx) * xscale) - 150,
                                   (float)(picheight - margin - (zy - miny) * yscale),
                                   (float)(300),
                                   (float)(60)),
                                  sttop);
                    
                    //x-axis axe name
                    g.DrawString("PC" + (co0 + 1),
                                  new Font("Arial", ORDINATION_FONT_SIZE / DPI_SCALE),
                                  new SolidBrush(Color.Black),
                                  new RectangleF((float)(margin + (maxx - minx) * xscale) - 150,
                                   (float)(picheight - margin - (zy - miny) * yscale) - 60,
                                   (float)(300),
                                   (float)(60)),
                                  stbottom);

                    //miny
                    g.DrawString(miny.ToString(DECIMAL),
                                  new Font("Arial", ORDINATION_FONT_SIZE / DPI_SCALE),
                                  new SolidBrush(Color.Black),
                                  new RectangleF((float)(margin + (zx - minx) * xscale),
                                   (float)(picheight - margin - (miny - miny) * yscale) - 30,
                                   (float)(300),
                                   (float)(60)),
                                  stleft);

                    //maxy
                    g.DrawString(maxy.ToString(DECIMAL),
                                  new Font("Arial", ORDINATION_FONT_SIZE / DPI_SCALE),
                                  new SolidBrush(Color.Black),
                                  new RectangleF((float)(margin + (zx - minx) * xscale),
                                   (float)(picheight - margin - (maxy - miny) * yscale) - 30,
                                   (float)(200),
                                   (float)(60)),
                                  stleft);

                    //y-axis axe name
                    g.DrawString("PC" + (co1 + 1),
                                  new Font("Arial", ORDINATION_FONT_SIZE / DPI_SCALE),
                                  new SolidBrush(Color.Black),
                                  new RectangleF((float)(margin + (zx - minx) * xscale) - 300,
                                   (float)(picheight - margin - (maxy - miny) * yscale) - 30,
                                   (float)(300),
                                   (float)(60)),
                                  stright);

                    Dictionary<int, int> colorid = new Dictionary<int, int>();
                    foreach (int c in color)
                        if (!colorid.ContainsKey(c))
                            colorid[c] = colorid.Count;

                    Color[] colors = GetDarkColor(colorid.Count);

                    for (int i = 0; i < n; ++i)
                    {
                        int padleft = 0;

                        if (ORDINATION_STYLE == 0 || ORDINATION_STYLE == 3 || ORDINATION_STYLE == 4)
                        {
                            padleft = ORDINATION_FONT_SIZE;

                            g.DrawString(ORDINATION_MARKER[color[i] % ORDINATION_MARKER.Length].ToString(),
                                        new Font("Arial", ORDINATION_MARKER_SIZE / DPI_SCALE),
                                        new SolidBrush(colors[colorid[color[i]]]),
                                        new RectangleF((float)(margin + (coordinate[i, co0] - minx) * xscale - 500),
                                        (float)(picheight - margin - (coordinate[i, co1] - miny) * yscale - 30),
                                        (float)(1000),
                                        (float)(60)),
                                        stcenter);
                        }

                        //Center
                        if (ORDINATION_STYLE == 1 || ORDINATION_STYLE == 2)
                            g.DrawString(ORDINATION_STYLE == 1 ? (i + 1).ToString() : names[i],
                                new Font("Arial", ORDINATION_FONT_SIZE / DPI_SCALE),
                                new SolidBrush(colors[colorid[color[i]]]),
                                new RectangleF((float)(margin + (coordinate[i, co0] - minx) * xscale - 500),
                                (float)(picheight - margin - (coordinate[i, co1] - miny) * yscale - 30),
                                (float)(1000),
                                (float)(60)),
                                stcenter);

                        //Left
                        if (ORDINATION_STYLE == 3 || ORDINATION_STYLE == 4)
                            g.DrawString(ORDINATION_STYLE == 3 ? (i + 1).ToString() : names[i],
                                new Font("Arial", ORDINATION_FONT_SIZE / DPI_SCALE),
                                new SolidBrush(colors[colorid[color[i]]]),
                                new RectangleF((float)(padleft + margin + (coordinate[i, co0] - minx) * xscale),
                                (float)(picheight - margin - (coordinate[i, co1] - miny) * yscale - 30),
                                (float)(1000),
                                (float)(60)),
                                stleft);
                    }

                    g.Dispose();
                    ms.Seek(0, SeekOrigin.Begin);
                    VecFile = new byte[ms.Length];
                    ms.Read(VecFile, 0, (int)ms.Length);
                    ms.Seek(0, SeekOrigin.Begin);

                    g = Graphics.FromImage(bmp);
                    g.DrawImage(new Metafile(ms), 0, 0, bmp.Width, bmp.Height);
                    MemoryStream m = new MemoryStream();
                    bmp.Save(m, ImageFormat.Png);

                    ms.Dispose();
                    g.Dispose();
                    bmp.Dispose();
                    return Image.FromStream(m);
                }
            }


            public class CLUSTERING : DIST
            {
                public class NODE
                {
                    public bool isend;
                    public string endname;
                    public double x;
                    public double y; //dist
                    public int[] id;
                    public NODE left;
                    public NODE right;
                };


                public ClusteringMethod method;
                public string method_name;
                public double[,] dcur; int ncur;
                public double[,] dnew;
                public List<NODE> node;
                public StringBuilder sd;

                public CLUSTERING(DIST d)
                {
                    n = d.n;
                    title = d.title;
                    names = d.names;
                    dist = d.dist;
                    color = d.color;
                }

                public void Clustering(StringBuilder _sd, ClusteringMethod _method, string name)
                {
                    method_name = name;
                    method = _method;
                    node = new List<NODE>();
                    sd = _sd;
                    ncur = n;
                    dcur = Clone(dist);
                    for (int i = 0; i < n; ++i)
                        for (int j = 0; j < i; ++j)
                            if (dcur[i, j] < 0)
                                dcur[i, j] = dcur[j, i] = 0;
                    dnew = Clone(dcur);
                    dnew = new double[n, n];

                    for (int i = 0; i < n; ++i)
                    {
                        NODE tc = new NODE();//Released
                        tc.isend = true;
                        tc.endname = names[i];
                        tc.x = i;
                        tc.y = 0;
                        tc.id = new int[1] { i };
                        tc.left = null;
                        tc.right = null;
                        node.Add(tc);
                    }
                    Clustering();
                    Print();
                }

                public void Print(NODE c = null, double cy = 0)
                {
                    if (c == null)
                    {
                        c = node[0];
                        if (c.isend)
                            sd.Append(title.Replace(" ", "_").Replace(":", "_") + "_" + method_name + ":" + c.endname + ":0;\r\n");
                        else
                        {
                            sd.Append(title.Replace(" ", "_").Replace(":", "_") + "_" + method_name + ":(");
                            Print(c.left, c.y);
                            sd.Append(",");
                            Print(c.right, c.y);
                            sd.AppendLine(");");
                        }
                    }
                    else if (c.isend)
                    {
                        sd.Append(c.endname + ":");
                        sd.Append((cy - c.y).ToString(DECIMAL));
                    }
                    else
                    {
                        sd.Append("(");
                        Print(c.left, c.y);
                        sd.Append(",");
                        Print(c.right, c.y);
                        sd.Append("):");
                        sd.Append((cy - c.y).ToString(DECIMAL));
                    }
                }

                public void Clustering()
                {
                    while (ncur > 1)
                    {
                        NODE tc = new NODE();
                        int a = 0, b = 0;

                        tc.isend = false;
                        tc.endname = null;
                        tc.y = FindMinIdx(ref a, ref b) / 2;
                        tc.x = (node[a].x + node[b].x) * 0.5;
                        tc.id = Concatenate(node[a].id, node[b].id);
                        tc.left = node[a];
                        tc.right = node[b];

                        ///
                        StringBuilder sb = new StringBuilder();
                        for (int i = 0; i < ncur; ++i)
                        {
                            for (int j = 0; j < ncur; ++j)
                            {
                                sb.Append(dcur[i, j].ToString("F3"));
                                sb.Append("\t");
                            }
                            sb.Append("\r\n");
                        }
                        ///
                        ReduceMatrix(a, b);
                        node[a] = tc;
                        node.RemoveAt(b);
                    }
                }

                public double FindMinIdx(ref int a, ref int b)
                {
                    double minv = 1e300;
                    for (int i = 0; i < ncur; ++i)
                        for (int j = i + 1; j < ncur; ++j)
                            if (minv > dcur[i, j])
                            {
                                minv = dcur[i, j];
                                a = i;
                                b = j;
                            }
                    return minv;
                }

                public void ReduceMatrix(int a2, int b2)
                {
                    int nnew = ncur - 1;
                    int a = Math.Min(a2, b2), b = Math.Max(a2, b2);
                    for (int i = 0; i < ncur; ++i)
                    {
                        if (i == b) continue;
                        int i2 = i > b ? i - 1 : i;
                        for (int j = 0; j < ncur; ++j)
                            dnew[i2, j > b ? j - 1 : j] = dcur[i, j];
                    }

                    int na = node[a].id.Length, nb = node[b].id.Length;

                    switch (method)
                    {
                        case ClusteringMethod.NEAREST:
                            for (int c = 0; c < ncur; ++c)
                            {
                                if (c == a || c == b) continue;
                                int cnew = c > b ? c - 1 : c;
                                double dac = dcur[a, c], dbc = dcur[b, c];
                                dnew[cnew, a] = dnew[a, cnew] = Math.Min(dac, dbc);
                            }
                            break;
                        case ClusteringMethod.FURTHEST:
                            for (int c = 0; c < ncur; ++c)
                            {
                                if (c == a || c == b) continue;
                                int cnew = c > b ? c - 1 : c;
                                double dac = dcur[a, c], dbc = dcur[b, c];
                                dnew[cnew, a] = dnew[a, cnew] = Math.Max(dac, dbc);
                            }
                            break;
                        case ClusteringMethod.UPGMA:
                            for (int c = 0; c < ncur; ++c)
                            {
                                if (c == a || c == b) continue;
                                int cnew = c > b ? c - 1 : c;
                                double dac = dcur[a, c], dbc = dcur[b, c];
                                dnew[cnew, a] = dnew[a, cnew] = (dac * na + dbc * nb) / (na + nb);
                            }
                            break;
                        case ClusteringMethod.UPGMC:
                            for (int c = 0; c < ncur; ++c)
                            {
                                if (c == a || c == b) continue;
                                int cnew = c > b ? c - 1 : c;
                                double dac = dcur[a, c], dbc = dcur[b, c], dab = dcur[a, b];
                                dnew[cnew, a] = dnew[a, cnew] = Math.Sqrt((na * dac * dac + nb * dbc * dbc) / (na + nb) - (dab * dab * na * nb) / (na + nb) / (na + nb));
                            }
                            break;
                        case ClusteringMethod.WPGMA:
                            for (int c = 0; c < ncur; ++c)
                            {
                                if (c == a || c == b) continue;
                                int cnew = c > b ? c - 1 : c;
                                double dac = dcur[a, c], dbc = dcur[b, c];
                                dnew[cnew, a] = dnew[a, cnew] = (dac + dbc) * 0.5;
                            }
                            break;
                        case ClusteringMethod.WPGMC:
                            for (int c = 0; c < ncur; ++c)
                            {
                                if (c == a || c == b) continue;
                                int cnew = c > b ? c - 1 : c;
                                double dac = dcur[a, c], dbc = dcur[b, c], dab = dcur[a, b];
                                dnew[cnew, a] = dnew[a, cnew] = Math.Sqrt(dac * dac * 0.5 + dbc * dbc * 0.5 - dab * dab * 0.25);
                            }
                            break;
                        case ClusteringMethod.WARD:
                            for (int c = 0; c < ncur; ++c)
                            {
                                if (c == a || c == b) continue;
                                int cnew = c > b ? c - 1 : c;
                                double dac = dcur[a, c], dbc = dcur[b, c], dab = dcur[a, b];
                                int nc = node[c].id.Length;
                                dnew[cnew, a] = dnew[a, cnew] = Math.Sqrt(((na + nc) * dac * dac + (nb + nc) * dbc * dbc - nc * dab * dab) / (na + nb + nc));
                            }
                            break;
                    }

                    var dt = dcur;
                    dcur = dnew;
                    dnew = dt;
                    ncur--;
                }
            }

            public List<DIST> dists = new List<DIST>();

            public double[,] Reynolds1983(double[,] fst)
            {
                int m = fst.GetLength(0);
                double[,] re = new double[m, m];

                for (int i = 0; i < m; ++i)
                    for (int j = 0; j < i; ++j)
                        re[i, j] = re[j, i] = -Math.Log(1 - fst[i, j]);
                return re;
            }

            public double[,] Slatkin1995(double[,] fst)
            {
                int m = fst.GetLength(0);
                double[,] re = new double[m, m];

                for (int i = 0; i < m; ++i)
                    for (int j = 0; j < i; ++j)
                        re[i, j] = re[j, i] = fst[i, j] / (1 - fst[i, j]);
                return re;
            }

            public void WriteDistance(double[,] D, string title, StreamWriter wt, string[] names, int[] color)
            {
                DIST td = new DIST();
                td.dist = D;
                td.names = names;
                td.n = names.Length;
                td.title = title;
                td.color = color;
                dists.Add(td);

                wt.WriteLine(title);
                foreach (string n1 in names)
                    wt.Write("\t" + n1);
                wt.Write("\r\n");

                int n = td.n;
                for (int i = 0; i < n; ++i)
                {
                    wt.Write(names[i]);
                    for (int j = 0; j < n; ++j)
                        wt.Write("\t" + D[i, j].ToString(DECIMAL));
                    wt.Write("\r\n");
                }
                wt.Write("\r\n");
            }

            public void CalcDistanceThreadPop(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                SUBPOP[] subpops = (SUBPOP[])((object[])obj)[2];
                double[,] D = (double[,])((object[])obj)[3];
                double[,] Dch = (double[,])((object[])obj)[4];
                double[,] Th = (double[,])((object[])obj)[5];
                double[,] Da = (double[,])((object[])obj)[6];
                double[,] Deu = (double[,])((object[])obj)[7];
                double[,] mu2 = (double[,])((object[])obj)[8];
                double[,] Dm = (double[,])((object[])obj)[9];
                double[,] Dr = (double[,])((object[])obj)[10];

                int c = 0;
                for (int i = 0; i < subpops.Length; ++i)
                {
                    SUBPOP tp = subpops[i];
                    for (int j = 0; j < i; ++j)
                    {
                        if (c++ % nthreads != id) continue;
                        SUBPOP tp2 = subpops[j];

                        double t1 = 0, t2 = 0, Jx1 = 0, Jx2 = 0, Jxy = 0;
                        int eL = 0;
                        for (int l = 0; l < L; ++l)
                        {
                            if (tp.loc[l].nhaplotypes == 0 || tp2.loc[l].nhaplotypes == 0 || tp.loc[l].freq.Count < 2) continue;
                            eL++;
                            foreach (int a in total_pop.loc[l].freq.Keys)
                            {
                                double fr1 = GetMissingFreq(tp, l, a);
                                double fr2 = GetMissingFreq(tp2, l, a);
                                Jx1 += fr1 * fr1;
                                Jx2 += fr2 * fr2;
                            }
                        }
                        Jx1 /= eL; Jx2 /= eL;

                        for (int l = 0; l < L; ++l)
                        {
                            if (tp.loc[l].nhaplotypes == 0 || tp2.loc[l].nhaplotypes == 0 || tp.loc[l].freq.Count < 2) continue;
                            double Sx1 = 0, Sx2 = 0, dr = 0, eu = 0;
                            foreach (int a in total_pop.loc[l].freq.Keys)
                            {
                                double fr1 = GetMissingFreq(tp, l, a);
                                double fr2 = GetMissingFreq(tp2, l, a);
                                if (a != NULL_ALLELE)
                                {
                                    Sx1 += fr1 * a;
                                    Sx2 += fr2 * a;
                                }
                                Jxy += fr1 * fr2;
                                Dch[i, j] += fr1 * fr2 > 0 ? Math.Sqrt(fr1 * fr2) : 0;
                                t1 += (fr1 - fr2) * (fr1 - fr2);
                                t2 += fr1 * fr2;
                                Da[i, j] += fr1 * fr2 > 0 ? Math.Sqrt(fr1 * fr2) : 0;
                                dr += (fr1 - fr2) * (fr1 - fr2) / 2;
                                eu += (fr1 - fr2) * (fr1 - fr2);
                            }
                            Sx1 /= 1 - GetMissingFreq(tp, l, NULL_ALLELE);
                            Sx2 /= 1 - GetMissingFreq(tp2, l, NULL_ALLELE);
                            mu2[i, j] += (Sx1 - Sx2) * (Sx1 - Sx2);
                            Dr[i, j] += dr > 0 ? Math.Sqrt(dr) : 0;
                            Deu[i, j] += eu > 0 ? eu : 0;
                        }

                        Jxy /= eL;
                        D[j, i] = D[i, j] = -Math.Log(Jxy / Math.Sqrt(Jx1 * Jx2)); //Nei
                        Dm[j, i] = Dm[i, j] = (Jx1 + Jx2) / 2 - Jxy;//Nei's minimum
                        Dch[i, j] = Dch[j, i] = 2 / Math.PI * Math.Sqrt(2 * (1 - Dch[i, j] / eL));//Cavalli-Sforza chord distance
                        Th[i, j] = Th[j, i] = Math.Sqrt(t1 / (2 * eL - 2 * t2));//Reynolds, Weir, and Cockerham's genetic distance
                        Da[j, i] = Da[i, j] = 1 - Da[i, j] / eL;//Nei's DA distance 1983
                        Deu[j, i] = Deu[i, j] = Math.Sqrt(Deu[i, j]);//Euclidean distance, do not divide eL to make the results of PCA and PCoa are equal
                        mu2[j, i] = mu2[i, j] = mu2[i, j] / eL;//Goldstein distance 1995
                        Dr[j, i] = Dr[i, j] = Dr[i, j] / eL;//Roger's distance 1972
                        Increment();
                    }
                }
            }

            public void CalcDistanceThreadInd(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                IND[] inds = (IND[])((object[])obj)[2];
                double[,] D = (double[,])((object[])obj)[3];
                double[,] Dch = (double[,])((object[])obj)[4];
                double[,] Th = (double[,])((object[])obj)[5];
                double[,] Da = (double[,])((object[])obj)[6];
                double[,] Deu = (double[,])((object[])obj)[7];
                double[,] mu2 = (double[,])((object[])obj)[8];
                double[,] Dm = (double[,])((object[])obj)[9];
                double[,] Dr = (double[,])((object[])obj)[10];

                int c = 0;
                for (int i = 0; i < inds.Length; ++i)
                {
                    IND ti = inds[i];
                    for (int j = 0; j < i; ++j)
                    {
                        if (c++ % nthreads != id) continue;
                        IND ti2 = inds[j];

                        double t1 = 0, t2 = 0, Jx1 = 0, Jx2 = 0, Jxy = 0;
                        int eL = 0;
                        for (int l = 0; l < L; ++l)
                        {
                            if (total_pop.loc[l].freq.Count < 2) continue;
                            eL++;
                            foreach (int a in total_pop.loc[l].freq.Keys)
                            {
                                double fr1 = GetMissingFreq(ti, l, a);
                                double fr2 = GetMissingFreq(ti2, l, a);
                                Jx1 += fr1 * fr1;
                                Jx2 += fr2 * fr2;
                            }
                        }
                        Jx1 /= eL; Jx2 /= eL;

                        for (int l = 0; l < L; ++l)
                        {
                            if (total_pop.loc[l].freq.Count < 2) continue;
                            double Sx1 = 0, Sx2 = 0, dr = 0, eu = 0;
                            foreach (var a in total_pop.loc[l].freq.Keys)
                            {
                                double fr1 = GetMissingFreq(ti, l, a);
                                double fr2 = GetMissingFreq(ti2, l, a);
                                if (a != NULL_ALLELE)
                                {
                                    Sx1 += fr1 * a;
                                    Sx2 += fr2 * a;
                                }
                                Jxy += fr1 * fr2;
                                Dch[i, j] += fr1 * fr2 > 0 ? Math.Sqrt(fr1 * fr2) : 0;
                                t1 += (fr1 - fr2) * (fr1 - fr2);
                                t2 += fr1 * fr2;
                                Da[i, j] += fr1 * fr2 > 0 ? Math.Sqrt(fr1 * fr2) : 0;
                                dr += (fr1 - fr2) * (fr1 - fr2) / 2;
                                eu += (fr1 - fr2) * (fr1 - fr2);
                            }
                            Sx1 /= 1 - GetMissingFreq(ti, l, NULL_ALLELE);
                            Sx2 /= 1 - GetMissingFreq(ti2, l, NULL_ALLELE);
                            mu2[i, j] += (Sx1 - Sx2) * (Sx1 - Sx2);
                            Dr[i, j] += dr > 0 ? Math.Sqrt(dr) : 0;
                            Deu[i, j] += eu > 0 ? eu : 0;
                        }

                        Jxy /= eL;
                        D[j, i] = D[i, j] = -Math.Log(Jxy / Math.Sqrt(Jx1 * Jx2)); //Nei
                        Dm[j, i] = Dm[i, j] = (Jx1 + Jx2) / 2 - Jxy;//Nei's minimum
                        Dch[i, j] = Dch[j, i] = 2 / Math.PI * Math.Sqrt(2 * (1 - Dch[i, j] / eL));//Cavalli-Sforza chord distance
                        Th[i, j] = Th[j, i] = Math.Sqrt(t1 / (2 * eL - 2 * t2));//Reynolds, Weir, and Cockerham's genetic distance
                        Da[j, i] = Da[i, j] = 1 - Da[i, j] / eL;//Nei's DA distance 1983
                        Deu[j, i] = Deu[i, j] = Math.Sqrt(Deu[i, j]);//Euclidean distance, do not divide eL to make the results of PCA and PCoa are equal
                        mu2[j, i] = mu2[i, j] = mu2[i, j] / eL;//Goldstein distance 1995
                        Dr[j, i] = Dr[i, j] = Dr[i, j] / eL;//Roger's distance 1972
                        Increment();
                    }
                }
            }

            public void CalcDistancePop(SUBPOP[] gr, StreamWriter wt, string title, List<double[,]> Fst)
            {
                double[,] D = new double[gr.Length, gr.Length];
                double[,] Dch = new double[gr.Length, gr.Length];
                double[,] Th = new double[gr.Length, gr.Length];
                double[,] Da = new double[gr.Length, gr.Length];
                double[,] Deu = new double[gr.Length, gr.Length];
                double[,] mu2 = new double[gr.Length, gr.Length];
                double[,] Dm = new double[gr.Length, gr.Length];
                double[,] Dr = new double[gr.Length, gr.Length];

                CallThread(CalcDistanceThreadPop, N_THREAD,
                           new object[] { gr, D, Dch, Th, Da, Deu, mu2, Dm, Dr },
                ProgressValue + gr.Length * (gr.Length - 1) / 2, ref ProgressValue);

                string[] names = new string[gr.Length];
                int[] color = new int[gr.Length];

                for (int i = 0; i < gr.Length; ++i)
                {
                    SUBPOP tp = gr[i];
                    names[i] = tp.name;
                    color[i] = tp.region == null ? 0 : tp.region.id;
                }

                if (DIST_Nei1972) WriteDistance(D, title + ": Nei 1972 standard genetic distance", wt, names, color);
                if (DIST_Cavalli1967) WriteDistance(Dch, title + ": Cavalli-Sforza 1967 chord distance", wt, names, color);
                if (DIST_Reynold1993) WriteDistance(Th, title + ": Reynolds 1983 theta", wt, names, color);
                if (DIST_Nei1983) WriteDistance(Da, title + ": Nei 1983 DA distance", wt, names, color);
                if (DIST_Euclidean) WriteDistance(Deu, title + ": Euclidean distance", wt, names, color);
                if (DIST_Goldstein1995) WriteDistance(mu2, title + ": Goldstein 1995 distance", wt, names, color);
                if (DIST_Nei1973) WriteDistance(Dm, title + ": Nei 1973 minimum genetic distance", wt, names, color);
                if (DIST_Roger1973) WriteDistance(Dr, title + ": Roger 1972 distance", wt, names, color);
                if (DIST_Reynolds1983)
                {
                    int c = 0;
                    foreach (var fst in Fst)
                        WriteDistance(Reynolds1983(fst), title + ": Reynolds 1983 DRA + " + FSTNAME[c++], wt, names, color);
                }
                if (DIST_Slatkin1995)
                {
                    int c = 0;
                    foreach (var fst in Fst)
                        WriteDistance(Slatkin1995(fst), title + ": Slatkin 1995 DSI + " + FSTNAME[c++], wt, names, color);
                }
            }

            public void CalcDistanceInd(IND[] inds, StreamWriter wt)
            {
                double[,] D = new double[inds.Length, inds.Length];
                double[,] Dch = new double[inds.Length, inds.Length];
                double[,] Th = new double[inds.Length, inds.Length];
                double[,] Da = new double[inds.Length, inds.Length];
                double[,] Deu = new double[inds.Length, inds.Length];
                double[,] mu2 = new double[inds.Length, inds.Length];
                double[,] Dm = new double[inds.Length, inds.Length];
                double[,] Dr = new double[inds.Length, inds.Length];

                CallThread(CalcDistanceThreadInd, N_THREAD,
                           new object[] { inds, D, Dch, Th, Da, Deu, mu2, Dm, Dr },
                ProgressValue + inds.Length * (inds.Length - 1) / 2, ref ProgressValue);

                string[] names = new string[inds.Length];
                int[] color = new int[inds.Length];

                for (int i = 0; i < inds.Length; ++i)
                {
                    IND ind = inds[i];
                    names[i] = ind.name;
                    color[i] = ind.subpop.id;
                }

                if (DIST_Nei1972) WriteDistance(D, "Individual: Nei 1972 standard genetic distance", wt, names, color);
                if (DIST_Cavalli1967) WriteDistance(Dch, "Individual: Cavalli-Sforza 1967 chord distance", wt, names, color);
                if (DIST_Reynold1993) WriteDistance(Th, "Individual: Reynolds 1983 theta", wt, names, color);
                if (DIST_Nei1983) WriteDistance(Da, "Individual: Nei 1983 DA distance", wt, names, color);
                if (DIST_Euclidean) WriteDistance(Deu, "Individual: Euclidean distance", wt, names, color);
                if (DIST_Goldstein1995) WriteDistance(mu2, "Individual: Goldstein 1995 distance", wt, names, color);
                if (DIST_Nei1973) WriteDistance(Dm, "Individual: Nei 1973 minimum genetic distance", wt, names, color);
                if (DIST_Roger1973) WriteDistance(Dr, "Individual: Roger 1972 distance", wt, names, color);
            }

            public void CalcDistance()
            {
                Progress = "Calculating genetic distance";
                ProgressValue = 0;
                ProgressMax =
                     (DIST_IND ? inds.Length * (inds.Length - 1) / 2 : 0) +
                     (DIST_POP ? subpops.Length * (subpops.Length - 1) / 2 : 0) +
                     (DIST_REG ? region_dyad_count : 0);
                SetProgress(ProgressValue, ProgressMax);

                StreamWriter wt = new StreamWriter(new FileStream("o_distance.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_DISTANCE = wt;

                if (DIST_IND) CalcDistanceInd(inds, wt);
                if (DIST_POP) CalcDistancePop(subpops, wt, "Population", PFST);
                if (DIST_REG)
                    for (int rl = regions.Length - 2; rl >= 0; --rl)
                        CalcDistancePop(regions[rl], wt, "Region level " + (rl + 1), RFST[rl]);
                wt.Flush();
                wt.Close();
            }

            #endregion

            #region Ordination

            public List<ORDINATION> ordination_results = new List<ORDINATION>();

            public void CalcOrdinationThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                StringBuilder[] Sb = (StringBuilder[])((object[])obj)[2];

                for (int i = 0; i < ordination_results.Count; ++i)
                {
                    if (i % nthreads != id) continue;

                    Sb[i] = new StringBuilder();
                    if (ordination_results[i].type == OrdinationType.PCoA)
                        ordination_results[i].pcoa(Sb[i], ORDINATION_NDIM);
                    else
                        ordination_results[i].pca(Sb[i], ORDINATION_NDIM);
                    Increment();
                }
            }

            public void CalcOrdination()
            {
                int npcoa = ORDINATION_PCOA ? dists.Count : 0;
                int npca = ORDINATION_PCA ? (DIST_IND ? 1 : 0) + (DIST_POP ? 1 : 0) + (DIST_REG ? regions.Length - 1 : 0) : 0;

                Progress = "Performing Ordination";
                ProgressValue = 0;
                ProgressMax = npcoa + npca;
                SetProgress(ProgressValue, ProgressMax);

                if (ORDINATION_PCOA)
                    foreach (DIST d in dists)
                        ordination_results.Add(new ORDINATION(d));

                if (ORDINATION_PCA)
                {
                    //prepare dist array for pca
                    int nalleles = total_pop.loc.Sum(l => l.freq.Count);
                    if (DIST_IND)
                        ordination_results.Add(new ORDINATION(inds, total_pop.loc, nalleles));
                    if (DIST_POP)
                        ordination_results.Add(new ORDINATION(subpops, total_pop.loc, nalleles, "Population: PCA"));
                    if (DIST_REG)
                        for (int rl = 0; rl < regions.Length - 1; ++rl)
                            ordination_results.Add(new ORDINATION(regions[rl], total_pop.loc, nalleles, "Regions level " + (rl + 1) + ": PCA"));
                }

                StringBuilder[] Sb = new StringBuilder[ProgressMax];
                CallThread(CalcOrdinationThread, N_THREAD, new object[] { Sb }, ProgressMax, ref ProgressValue);
                StreamWriter wt = new StreamWriter(new FileStream("o_ordination.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_PCOA = wt;

                foreach (StringBuilder s in Sb) wt.Write(s);
                wt.Flush();
                wt.Close();
            }

            #endregion

            #region Clustering

            public List<string> clustering_out = new List<string>();

            public void CalcClusteringThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                StringBuilder[] Sb = (StringBuilder[])((object[])obj)[2];
                bool[] method = (bool[])((object[])obj)[3];
                string[] method_name = (string[])((object[])obj)[4];

                int c = 0;
                foreach (DIST d in dists)
                {
                    for (int i = 0; i < method.Length; ++i)
                    {
                        if (!method[i]) continue;
                        if (c++ % nthreads != id) continue;
                        Sb[c - 1] = new StringBuilder();
                        new CLUSTERING(d).Clustering(Sb[c - 1], (ClusteringMethod)i, method_name[i]);
                        Increment();
                    }
                }
            }

            public void CalcClustering()
            {
                Progress = "Performingh hierarchical clustering";
                ProgressValue = 0;
                ProgressMax = dists.Count;

                bool[] method = new bool[]{
                    CLUSTERING_NEAREST, CLUSTERING_FURTHEST, CLUSTERING_UPGMA, CLUSTERING_UPGMC, CLUSTERING_WPGMA, CLUSTERING_WPGMC, CLUSTERING_WARD};
                string[] method_name = new string[]{
                    "NEAREST", "FURTHEST", "UPGMA", "UPGMC", "WPGMA", "WPGMC", "WARD"};

                int count = 0;
                for (int i = 0; i < method.Length; ++i)
                    if (method[i]) count++;
                ProgressMax *= count;
                SetProgress(ProgressValue, ProgressMax);

                StringBuilder[] Sb = new StringBuilder[ProgressMax];
                CallThread(CalcClusteringThread, N_THREAD,
                           new object[] { Sb, method, method_name },
                ProgressMax, ref ProgressValue);

                StreamWriter wt = new StreamWriter(new FileStream("o_clustering.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_CLUSTERING = wt;

                foreach (StringBuilder s in Sb)
                {
                    wt.Write(s);
                    clustering_out.Add(s.ToString());
                }
                wt.Flush();
                wt.Close();
            }

            #endregion

            #region Inbreeding


            public unsafe void CalcInbreedingThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                StringBuilder[] Sb = (StringBuilder[])((object[])obj)[2];
                IND[] inds = (IND[])((object[])obj)[3];

                double[] RLoc = new double[L], WLoc = new double[L];
                bool[] estimators = new bool[] { INBREEDING_Ritland1996, INBREEDING_Loiselle1995, INBREEDING_Weir1996, INBREEDING_HuangUnpub };
                double[] res = new double[estimators.Length], se = new double[estimators.Length];
                fixed (double* R = &RLoc[0], W = &WLoc[0])
                    for (int i = 0; i < inds.Length; ++i)
                    {
                        IND x = inds[i];
                        if (i % nthreads != id) continue;
                        StringBuilder re = new StringBuilder();

                        for (int e = 0; e < estimators.Length; ++e)
                        {
                            if (!estimators[e]) continue;
                            if (INBREEDING_JACKKNIFE)
                            {
                                switch ((InbreedingEstimator)e)
                                {
                                    case InbreedingEstimator.KinshipRitland1996: res[e] = KinshipRitland1996(x, x, x.subpop.loc, R, W); break;
                                    case InbreedingEstimator.KinshipLoiselle1995: res[e] = KinshipLoiselle1995(x, x, x.subpop.loc, R, W); break;
                                    case InbreedingEstimator.KinshipWeir1996: res[e] = KinshipWeir1996(x, x, x.subpop.loc, R, W); break;
                                    case InbreedingEstimator.KinshipHuangUnpub: res[e] = KinshipHuangUnpub(x, x, x.subpop.loc, x.subpop.Msl, R, W); break;
                                }
                                se[e] = R_JackknifeSE(res[e], RLoc, WLoc, JackknifeType.WeightedAverage) * x.ploidy / (x.ploidy - 1);
                            }
                            else switch ((InbreedingEstimator)e)
                            {
                                case InbreedingEstimator.KinshipRitland1996: res[e] = KinshipRitland1996(x, x, x.subpop.loc); break;
                                case InbreedingEstimator.KinshipLoiselle1995: res[e] = KinshipLoiselle1995(x, x, x.subpop.loc); break;
                                case InbreedingEstimator.KinshipWeir1996: res[e] = KinshipWeir1996(x, x, x.subpop.loc); break;
                                case InbreedingEstimator.KinshipHuangUnpub: res[e] = KinshipHuangUnpub(x, x, x.subpop.loc, x.subpop.Msl); break;
                            }
                            res[e] = (x.ploidy * res[e] - 1) / (x.ploidy - 1);
                        }


                        re.Append(x.name);
                        re.Append("\t");
                        re.Append(x.subpop.name);
                        re.Append("\t");
                        SUBPOP tr = x.subpop.region;
                        for (int rl = 0; rl < regions.Length - 1; ++rl)
                        {
                            re.Append(tr.name);
                            re.Append("\t");
                            tr = tr.region;
                        }
                        re.Append(x.ploidy);

                        for (int e = 0; e < estimators.Length; ++e)
                        {
                            if (!estimators[e]) continue;

                            re.Append("\t");
                            re.Append(res[e].ToString(DECIMAL));
                            if (INBREEDING_JACKKNIFE)
                            {
                                re.Append("\t");
                                re.Append(se[e].ToString(DECIMAL));
                            }
                        }

                        re.Append("\r\n");
                        Sb[i] = re;
                        Increment();
                    }
            }

            public void CalcInbreeding()
            {
                //make weight sum to one
                Progress = "Estimating individual inbreeding coef";
                ProgressValue = 0;
                ProgressMax = inds.Length;
                SetProgress(ProgressValue, ProgressMax);

                StreamWriter wt = new StreamWriter(new FileStream("o_inbreeding.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_INBREEDING = wt;

                wt.Write("Ind\tPop");
                for (int rl = 0; rl < regions.Length - 1; ++rl)
                    wt.Write("\tRegL" + (rl + 1));
                wt.Write("\tPloidy" +
                          (INBREEDING_Ritland1996 ? "\tRitland 1996" : "") +
                          (INBREEDING_Ritland1996 && INBREEDING_JACKKNIFE ? "\tSE" : "") +
                          (INBREEDING_Loiselle1995 ? "\tLoiselle 1995" : "") +
                          (INBREEDING_Loiselle1995 && INBREEDING_JACKKNIFE ? "\tSE" : "") +
                          (INBREEDING_Weir1996 ? "\tWeir 1996" : "") +
                          (INBREEDING_Weir1996 && INBREEDING_JACKKNIFE ? "\tSE" : "") +
                          (INBREEDING_HuangUnpub ? "\tHuang Unpub" : "") +
                          (INBREEDING_HuangUnpub && INBREEDING_JACKKNIFE ? "\tSE" : "") +
                          "\r\n");

                StringBuilder[] Sb = new StringBuilder[inds.Length];
                CallThread(CalcInbreedingThread, N_THREAD, new object[] { Sb, inds }, inds.Length, ref ProgressValue);

                foreach (StringBuilder s in Sb)
                    wt.Write(s);
                wt.Flush();
                wt.Close();
            }

            #endregion

            #region Hindex

            public void CalcHIndexThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                StringBuilder[] Sb = (StringBuilder[])((object[])obj)[2];
                IND[] inds = (IND[])((object[])obj)[3];
                double[] buf = new double[L];

                for (int i = 0; i < inds.Length; ++i)
                {
                    if (i % nthreads != id) continue;

                    IND x = inds[i];
                    StringBuilder re = new StringBuilder();
                    SUBPOP tp = x.subpop;
                    re.Append(x.name + "\t");
                    re.Append(tp.name + "\t");
                    SUBPOP tr = x.subpop.region;
                    for (int rl = 0; rl < regions.Length - 1; ++rl)
                    {
                        re.Append(tr.name);
                        re.Append("\t");
                        tr = tr.region;
                    }
                    re.Append(tp.ploidy + "\t");
                    double th = 0, tl = 0;
                    for (int l = 0; l < L; ++l)
                    {
                        buf[l] = double.NaN;
                        if (x.g[l].hash == 0) continue;
                        buf[l] = x.g[l].GetHIndex();
                        th += buf[l];
                        tl++;
                    }

                    th /= tl;
                    re.Append(th.ToString(DECIMAL));
                    for (int l = 0; l < L; ++l)
                        re.Append("\t" + buf[l].ToString(DECIMAL));
                    re.Append("\r\n");

                    Sb[i] = re;
                    Increment();
                }
            }

            public void CalcHIndex()
            {
                Progress = "Calculating individual H-index";
                ProgressValue = 0;
                ProgressMax = inds.Length;
                SetProgress(ProgressValue, ProgressMax);

                StreamWriter wt = new StreamWriter(new FileStream("o_hindex.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_HINDEX = wt;

                wt.Write("Ind\tPop");
                for (int rl = 0; rl < regions.Length - 1; ++rl)
                    wt.Write("\tRegL" + (rl + 1));
                wt.Write("\tPloidy\tAverage");
                for (int l = 0; l < L; ++l)
                    wt.Write("\t" + total_pop.loc[l].name);
                wt.Write("\r\n");

                StringBuilder[] Sb = new StringBuilder[inds.Length];
                CallThread(CalcHIndexThread, N_THREAD, new object[] { Sb, inds }, inds.Length, ref ProgressValue);

                foreach (StringBuilder s in Sb)
                    wt.Write(s);
                wt.Flush();
                wt.Close();
            }
            #endregion

            #region Assignment

            public double LogPr(IND x, SUBPOP tp)
            {
                //only used in assignment
                if (ASSIGNMENT_PLOIDY && tp.ploidy != x.ploidy) return -999;
                double e2 = ASSIGNMENT_ERROR, e1 = 1 - ASSIGNMENT_ERROR;
                FastLog flog = FastLog.Default;
                for (int l = 0; l < L; ++l)
                {
                    if (x.g[l].hash == 0) continue;
                    double pr = tp.PFZ(x.g[l], l);
                    double pr_total = total_pop.PFZ(x.g[l], l);

                    flog.Charge(e1 * pr + e2 * pr_total * (1 - pr));
                }
                return flog.Close();
            }

            public void CalcAssignmentThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                StringBuilder[] Sb = (StringBuilder[])((object[])obj)[2];
                IND[] inds = (IND[])((object[])obj)[3];
                SUBPOP[] subpops = (SUBPOP[])((object[])obj)[4];
                SUBPOP[][] regions = (SUBPOP[][])((object[])obj)[5];

                double[] buf = new double[subpops.Length];

                for (int i = 0; i < inds.Length; ++i)
                {
                    if (i % nthreads != id) continue;

                    IND x = inds[i];
                    StringBuilder re = new StringBuilder();
                    double pMaxL = -1e300, pLod = 0, pMaxL2 = -1e300;
                    int pc = 0, pcmax = -1;
                    SUBPOP pp = null;

                    //pop
                    foreach (SUBPOP tp in subpops)
                    {
                        buf[pc] = LogPr(x, tp);
                        if (buf[pc] > pMaxL)
                        {
                            pMaxL = buf[pc];
                            pp = tp;
                            pcmax = pc;
                        }
                        pc++;
                    }

                    for (int j = 0; j < subpops.Length; ++j)
                        if (buf[j] > pMaxL2 && j != pcmax)
                            pMaxL2 = buf[j];

                    pLod = subpops.Length == 1 ? double.NaN : pMaxL - pMaxL2;

                    re.Append(x.name + "\t");
                    re.Append(x.subpop.name + "\t");
                    SUBPOP tr2 = x.subpop.region;
                    for (int rl = 0; rl < regions.Length - 1; ++rl)
                    {
                        re.Append(tr2.name);
                        re.Append("\t");
                        tr2 = tr2.region;
                    }
                    re.Append(x.ploidy + "\t");
                    re.Append(pp.name + "\t");
                    re.Append(pLod.ToString(DECIMAL));
                    for (int j = 0; j < subpops.Length; ++j)
                        re.Append("\t" + buf[j].ToString(DECIMAL));

                    //reg
                    for (int rl = 0; rl < regions.Length - 1; ++rl)
                    {
                        pMaxL = -1e300; pLod = 0; pMaxL2 = -1e300;
                        pc = 0; pcmax = -1;
                        pp = null;

                        foreach (SUBPOP tr in regions[rl])
                        {
                            buf[pc] = LogPr(x, tr);
                            if (buf[pc] > pMaxL)
                            {
                                pMaxL = buf[pc];
                                pp = tr;
                                pcmax = pc;
                            }
                            pc++;
                        }

                        for (int j = 0; j < regions[rl].Length; ++j)
                            if (buf[j] > pMaxL2 && j != pcmax)
                                pMaxL2 = buf[j];

                        pLod = regions[rl].Length == 1 ? double.NaN : pMaxL - pMaxL2;

                        re.Append("\t" + pp.name + "\t" + pLod.ToString(DECIMAL));
                        for (int j = 0; j < regions[rl].Length; ++j)
                            re.Append("\t" + buf[j].ToString(DECIMAL));
                    }
                    re.Append("\r\n");

                    Sb[i] = re;
                    Increment();
                }
            }

            public void CalcAssignment()
            {
                Progress = "Calculating population assignment";
                ProgressValue = 0;
                ProgressMax = inds.Length;
                SetProgress(ProgressValue, ProgressMax);

                StreamWriter wt = new StreamWriter(new FileStream("o_assignment.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_ASSIGNMENT = wt;

                if (regions.Length > 1) wt.Write(new String('\t', regions.Length - 1));
                wt.Write("\t\t\t\t\tlnL for each Pop");
                foreach (SUBPOP tp in subpops)
                    wt.Write("\t");
                for (int rl = 0; rl < regions.Length - 1; ++rl)
                {
                    wt.Write("\t\tlnL for each RegL" + (rl + 1));
                    foreach (SUBPOP tr in regions[rl])
                        wt.Write("\t");
                }

                wt.Write("\r\nInd\tPop");
                for (int rl = 0; rl < regions.Length - 1; ++rl)
                    wt.Write("\tRegL" + (rl + 1));
                wt.Write("\tPloidy\tAssigned Pop\tLOD");
                foreach (SUBPOP tp in subpops)
                    wt.Write("\t" + tp.name);
                for (int rl = 0; rl < regions.Length - 1; ++rl)
                {
                    wt.Write("\tAssigned RegL" + (rl + 1) + "\tLOD");
                    foreach (SUBPOP tr in regions[rl])
                        wt.Write("\t" + tr.name);
                }
                wt.Write("\r\n");

                StringBuilder[] Sb = new StringBuilder[inds.Length];

                CallThread(CalcAssignmentThread, N_THREAD,
                           new object[] { Sb, inds, subpops, regions },
                           inds.Length, ref ProgressValue);

                foreach (StringBuilder s in Sb)
                    wt.Write(s);

                wt.Flush();
                wt.Close();
            }

            #endregion

            #region Spatial

            private double[] distance_intervals;

            public int GetDistanceClass(double dist)
            {
                int i = 0;
                for (; i < distance_intervals.Length; ++i)
                    if (dist < distance_intervals[i])
                        return i;
                return i;
            }

            public int GetDistanceClass(double[] x, double[] y, ref double dist)
            {
                if (double.IsNaN(x[0]) || double.IsNaN(y[0])) return -1;
                return GetDistanceClass(dist = SPATIAL_HAVERSINE ? Haversine(x[0], x[1], y[0], y[1]) : Eculidean(x, y));
            }

            public double GetDistance(double[] x, double[] y)
            {
                if (double.IsNaN(x[0]) || double.IsNaN(y[0])) return -1;
                return SPATIAL_HAVERSINE ? Haversine(x[0], x[1], y[0], y[1]) : Eculidean(x, y);
            }

            public double Eculidean(double[] x, double[] y)
            {
                double dist = 0;
                for (int i = 0; i < x.Length; ++i)
                    dist += (x[i] - y[i]) * (x[i] - y[i]);
                return Math.Sqrt(dist);
            }

            private static double Deg2RadCoef = Math.PI / 180;

            public double Haversine(double lon1, double lat1, double lon2, double lat2)
            {
                lon1 *= Deg2RadCoef;
                lat1 *= Deg2RadCoef;
                lon2 *= Deg2RadCoef;
                lat2 *= Deg2RadCoef;
                return Math.Acos(Math.Sin(lat1) * Math.Sin(lat2) + Math.Cos(lat1) * Math.Cos(lat2) * Math.Cos(lon1 - lon2)) * 6371;
            }

            public void CalcSpatial()
            {
                //make weight sum to one
                Progress = "Performing spatial pattern analysis";
                ProgressValue = 0;
                ProgressMax = inds.Length * (inds.Length - 1) / 2;
                SetProgress(ProgressValue, ProgressMax);

                StreamWriter wt = new StreamWriter(new FileStream("o_spatial.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_SPATIAL = wt;

                //Check coordinates
                if (ncoordinate == 0)
                {
                    wt.Flush();
                    wt.Close();
                    ShowErrorMessage("Cannot find coordinates in input data, their header should be start with [C]. ", "Error", 0);
                    return;
                }

                if (SPATIAL_HAVERSINE)
                {
                    if (ncoordinate != 2)
                    {
                        wt.Flush();
                        wt.Close();
                        ShowErrorMessage("Cannot find convert haversine distance because the number of coordinates is not 2. ", "Error", 0);
                        return;
                    }

                    foreach (IND ind in inds)
                    {
                        if (!double.IsNaN(ind.coordinate[0]) && (ind.coordinate[0] < -90 || ind.coordinate[0] > 90))
                        {
                            wt.Flush();
                            wt.Close();
                            ShowErrorMessage("The latitude (1st coordinate) of individual " + ind.name + " excees range [-90,90].", "Error", 0);
                            return;
                        }
                        else if (!double.IsNaN(ind.coordinate[1]) && (ind.coordinate[1] < -180 || ind.coordinate[1] > 180))
                        {
                            wt.Flush();
                            wt.Close();
                            ShowErrorMessage("The longtitude (2nd coordinate) of individual " + ind.name + " excees range [-180,180].", "Error", 0);
                            return;
                        }
                    }
                }

                if (SPATIAL_DISTCLASS != 0)
                {
                    List<double> d = new List<double>();
                    for (int i = 0; i < inds.Length; ++i)
                    {
                        double[] ci = inds[i].coordinate;
                        for (int j = 0; j < i; ++j)
                        {
                            double dist = GetDistance(ci, inds[j].coordinate);
                            if (dist >= 0) d.Add(dist);
                        }
                    }

                    d.Sort();

                    int ninterval = SPATIAL_DISTCLASS < d.Count - 1 ? SPATIAL_DISTCLASS : d.Count - 1;
                    int nclass = ninterval + 1;
                    double sep = 1.0 / nclass;
                    StringBuilder re = new StringBuilder();
                    for (int i = 1; i <= ninterval; ++i)
                    {
                        int id = (int)(sep * i * d.Count);
                        re.Append((d[id] + d[id + 1]) * 0.5);
                        if (i < ninterval) re.Append(",");
                    }
                    SPATIAL_DISTINTERVAL = re.ToString();
                }

                try
                {
                    string[] interval_str = SPATIAL_DISTINTERVAL.Split(new char[] { ' ', ',', '\t' }, StringSplitOptions.RemoveEmptyEntries);
                    List<double> interval_list = new List<double>();
                    Array.ForEach(interval_str, s => interval_list.Add(double.Parse(s)));
                    interval_list.Sort();
                    distance_intervals = interval_list.ToArray();
                }
                catch
                {
                    wt.Flush();
                    wt.Close();
                    ShowErrorMessage("Distance interval format error: \r\n" + SPATIAL_DISTINTERVAL, "Error", false);
                }

                if (inds.Length > 1)
                    SpatialSub(inds, wt);

                wt.Flush();
                wt.Close();
            }

            private unsafe void SpatialSub(IND[] inds, StreamWriter wt)
            {
                int n = inds.Length;
                int[,] Class = new int[n, n];
                double[,] HardyR = new double[n, n];
                double[,,] HardyRLoc = SPATIAL_JACKKNIFE ? new double[n, n, L] : null;
                int NC = distance_intervals.Length + 1;

                double[] MoranI = new double[NC];
                int[] N = new int[NC];
                int[] N2 = new int[NC];
                double[,] MoranI_Jackknife = new double[NC, L];
                int[,] N_Jackknife = new int[NC, L];
                double[] MoranI_SE = new double[NC];
                double[] Mean = new double[NC];
                double[] MeanLn = new double[NC];

                ConcurrentDictionary<int, int>[] ParticT = new ConcurrentDictionary<int, int>[NC];
                for (int c = 0; c < NC; ++c)
                    ParticT[c] = new ConcurrentDictionary<int, int>();

                Parallel.For(0, n, new ParallelOptions() { MaxDegreeOfParallelism = N_THREAD }, i =>
                {
                    Class[i, i] = -1;
                    for (int j = 0; j < i; ++j)
                    {
                        double dist = 0, I = 0, sw = 0, sr = 0;
                        int c = Class[i, j] = GetDistanceClass(inds[i].coordinate, inds[j].coordinate, ref dist);
                        if (c == -1) continue;

                        if (SPATIAL_JACKKNIFE)
                            fixed (double* R = &HardyRLoc[i, j, 0], W = &HardyRLoc[j, i, 0])
                            {
                                I = HardyR[i, j] = RelatednessHardy1999(inds[i], inds[j], total_pop.loc, R, W);
                                sw = Sum(W, L);
                                sr = Sum(R, L);
                                for (int l = 0; l < L; ++l)
                                {
                                    double tr = (sr - HardyRLoc[i, j, l]) / (sw - HardyRLoc[j, i, l]);
                                    if (!double.IsNaN(tr) && !double.IsInfinity(tr))
                                    {
                                        MoranI_Jackknife[c, l] += tr;
                                        N_Jackknife[c, l]++;
                                    }
                                }
                            }
                        else
                            I = HardyR[i, j] = RelatednessHardy1999(inds[i], inds[j], total_pop.loc);

                        ConcurrentDictionary<int, int> pt = ParticT[c];
                        N[c]++;
                        Mean[c] += dist;
                        MeanLn[c] += Math.Log(dist);

                        if (!double.IsNaN(HardyR[i, j]) && !double.IsInfinity(HardyR[i, j]))
                        {
                            MoranI[c] += HardyR[i, j];
                            N2[c]++;
                        }


                        if (!pt.ContainsKey(i)) pt[i] = 0;
                        if (!pt.ContainsKey(j)) pt[j] = 0;
                        pt[i]++;
                        pt[j]++;

                        Increment();
                    }
                });


                //average distance
                Div(Mean, Mean, N);
                Div(MeanLn, MeanLn, N);
                Div(MoranI, MoranI, N2);
                Div(MoranI_Jackknife, MoranI_Jackknife, N_Jackknife);
                for (int c = 0; c < NC; ++c)
                {
                    double ex = 0, ex2 = 0;
                    for (int l = 0; l < L; ++l)
                    {
                        ex2 += MoranI_Jackknife[c, l] * MoranI_Jackknife[c, l];
                        ex += MoranI_Jackknife[c, l];
                    }
                    ex /= L;
                    ex2 /= L;
                    MoranI_SE[c] = Math.Sqrt((L - 1) * (ex2 - ex * ex));
                }

                wt.WriteLine("Spatial pattern analysis for " + (inds == null ? "populations" : "individuals"));
                wt.WriteLine("Sample size n: " + n);
                wt.WriteLine("Distance type: " + (SPATIAL_HAVERSINE ? "Haversine" : "Euclidean"));
                wt.WriteLine("Class	Range	#pairs	Mean(d)	Mean(ln d)	partic%	CV(#partic)	Moran's I" + (SPATIAL_JACKKNIFE ? "	SE	P" : ""));

                for (int d = 0; d < NC; ++d)
                {
                    wt.Write((d + 1).ToString() + "\t");
                    if (d == 0) wt.Write("0~" + distance_intervals[d].ToString(DECIMAL) + "\t");
                    else if (d < NC - 1) wt.Write(distance_intervals[d - 1].ToString(DECIMAL) + "~" + distance_intervals[d].ToString(DECIMAL) + "\t");
                    else wt.Write(distance_intervals[d - 1].ToString(DECIMAL) + "~∞\t");

                    ConcurrentDictionary<int, int> pt = ParticT[d];

                    wt.Write(N[d].ToString(DECIMAL));
                    if (N[d] == 0)
                    {
                        wt.WriteLine("");
                        continue;
                    }

                    wt.Write("\t" + Mean[d].ToString(DECIMAL));
                    wt.Write("\t" + MeanLn[d].ToString(DECIMAL));
                    wt.Write("\t" + (pt.Count * 100.0 / n).ToString(DECIMAL));

                    double ex = pt.Count > 0 ? pt.Values.Average() : 0;
                    double ex2 = pt.Count > 0 ? pt.Values.Average(o => o * o) : 0;
                    wt.Write("\t" + Math.Sqrt(ex2 / (ex * ex) - 1).ToString(DECIMAL));
                    wt.Write("\t" + MoranI[d].ToString(DECIMAL));

                    if (SPATIAL_JACKKNIFE)
                    {
                        double z = (MoranI[d] + 1 / (n - 1)) / MoranI_SE[d];
                        double Pleft = NormalDistCDF(z), Pright = 1.0 - Pleft, Ptwo = 2 * Math.Min(Pleft, Pright);
                        wt.Write("\t" + MoranI_SE[d].ToString(DECIMAL));
                        wt.Write("\t" + Ptwo.ToString(DECIMAL));
                    }
                    wt.WriteLine("");
                }
            }
            #endregion

            #region Relationship

            private bool Huang2015ML_Initialized = false;
            Dictionary<uint, uint>[] Huang2015ML_maps;
            ulong[][] Huang2015ML_codes;
            //initialize polyploid maximum-likelihood estimator, allocate memory, read genotype pattern tables, etc

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 1)]
            public struct Huang2015MLEntry
            {
                public ulong a;
                public uint b;
            };

            private void Huang2015ML_Initialize()
            {
                if (Huang2015ML_Initialized) return;
                Huang2015ML_maps = new Dictionary<uint, uint>[8];
                Huang2015ML_codes = new ulong[8][];
                Huang2015ML_codes[0] = new ulong[2 + 1];
                Huang2015ML_codes[1] = new ulong[9 + 1];
                Huang2015ML_codes[2] = new ulong[31 + 1];
                Huang2015ML_codes[3] = new ulong[109 + 1];
                Huang2015ML_codes[4] = new ulong[339 + 1];
                Huang2015ML_codes[5] = new ulong[1043 + 1];
                Huang2015ML_codes[6] = new ulong[2998 + 1];
                Huang2015ML_codes[7] = new ulong[8405 + 1];

                int[] len = new int[] { 2, 9, 31, 109, 339, 1043, 2998, 8405 };
                Huang2015MLEntry[] data = new Huang2015MLEntry[12936];
                Marshal.Copy(ML.mlbin_data, 0, Marshal.UnsafeAddrOfPinnedArrayElement(data, 0), 12 * 12936);

                int count = 0;
                for (int p = 0; p < 8; ++p)
                {
                    Dictionary<uint, uint> m = new Dictionary<uint, uint>();
                    ulong[] c = Huang2015ML_codes[p];
                    for (uint i = 1; i <= len[p]; ++i)
                    {
                        c[i] = data[count].a;
                        m[data[count].b] = i;
                        count++;
                    }
                    Huang2015ML_maps[p] = m;
                }
                Huang2015ML_Initialized = true;
            }

            private void Huang2015ML_Uninitialize()
            {
                if (!Huang2015ML_Initialized) return;
                Huang2015ML_codes = null;
                Huang2015ML_maps = null;
                GC.Collect();
                Huang2015ML_Initialized = false;
            }

            private bool Huang2015ML_GetIBS(IND x, IND y, int[] bufa, int[] bufb, uint[,] IBS, int[,,] alleles)
            {
                int px = x.ploidy, py = y.ploidy;
                int maxploidy = px > py ? px : py;

                for (int l = 0; l < L; ++l)
                {
                    if (x.g[l].hash == 0 || y.g[l].hash == 0) IBS[l, 0] = 0;

                    int c = 0;
                    foreach (GENOTYPE gx in x.g[l].genotypes)
                        foreach (GENOTYPE gy in y.g[l].genotypes)
                        {
                            uint ha = 0;

                            Array.Clear(bufa, 0, maxploidy);
                            Array.Clear(bufb, 0, maxploidy);
                            Array.Copy(gx.alleles2, bufa, gx.alleles2.Length);
                            Array.Copy(gy.alleles2, bufb, gy.alleles2.Length);
                            Array.Sort(bufa, 0, gx.alleles2.Length);
                            Array.Reverse(bufa, 0, gx.alleles2.Length);
                            Array.Sort(bufb, 0, gy.alleles2.Length);
                            Array.Reverse(bufb, 0, gy.alleles2.Length);

                            ha = GetHash(bufa, bufb, maxploidy);
                            uint ibs = Huang2015ML_maps[maxploidy - 1][ha];
                            IBS[l, c] = ibs;
                            if (ibs == 0) continue;
                            MatchAllele(
                                Huang2015ML_codes[maxploidy - 1][ibs],
                                bufa, bufb, alleles, l * 1225 * 16 + c * 16, maxploidy);
                            c++;
                        }
                }
                return true;
            }

            public unsafe double RelatednessHuang2015ML(IND x, IND y, LOC[] loc, int[] bufa, int[] bufb, int[,,] alleles, double[,,] coef, uint[,] IBS, double* RLoc = null)
            {
                if (x.ploidy < 1 || x.ploidy > MAX_PLOIDY || y.ploidy < 1 || y.ploidy > MAX_PLOIDY) return double.NaN;

                bool Calc_Coef = true;
                int px = x.ploidy, py = y.ploidy;
                int ploidy = px > py ? py : px;
                if (!Huang2015ML_GetIBS(x, y, bufa, bufb, IBS, alleles)) return double.NaN;

                for (int l = (RLoc == null ? 0 : L) - 1; l >= -1; --l)
                {
                    Point4 x2 = Point4.DownHillSimplex(ploidy, 10, Huang2015ML_Likelihood, new object[] { x, y, loc, alleles, coef, IBS, Calc_Coef, l },
                        p => { p.dim = ploidy; p.diff = Math.Abs(px - py); p.confine = px == py && px % 2 == 0; });

                    int maxploidy = px > py ? px : py;
                    int minploidy = px > py ? py : px;
                    double r = 0;
                    for (int i = 0; i < minploidy; ++i)
                        r += x2.real[i] * (minploidy - i) / maxploidy;
                    if (l == -1) return r;
                    else RLoc[l] = r;
                }
                return 0;
            }

            private void Huang2015ML_Likelihood(Point4 xp, object[] par)
            {
                IND x = (IND)par[0];
                IND y = (IND)par[1];
                LOC[] loc = (LOC[])par[2];
                int[,,] alleles = (int[,,])par[3];
                double[,,] coef = (double[,,])par[4];
                uint[,] IBS = (uint[,])par[5];
                bool Calc_Coef = (bool)par[6];
                int excludeloc = (int)par[7];

                //calc coef
                if (Calc_Coef)
                {
                    Calc_Coef = false;
                    for (int i = 0; i < L; ++i)
                    {
                        int ncandidate = x.g[i].genotypes.Length * y.g[i].genotypes.Length;
                        for (int j = 0; j < ncandidate; ++j)
                            ML.ml_assign(xp.dim + xp.diff,
                                         loc[i].freq,
                                         alleles,//L, 1225, 16
                                         coef, //L, 1225, 9
                                         IBS,  //L, 1225
                                         i, j
                                         );
                    }
                }

                double re = 0;
                xp.i2r();
                for (int i = 0; i < L; ++i)
                {
                    if (i == excludeloc) continue;
                    int ncandidate = x.g[i].genotypes.Length * y.g[i].genotypes.Length, j = 0;
                    foreach (GENOTYPE gx in x.g[i].genotypes)
                        foreach (GENOTYPE gy in y.g[i].genotypes)
                        {
                            double lt = 0;
                            for (int k = 0; k <= xp.dim; ++k)
                                lt += coef[i, j, k + xp.diff] * xp.real[k] / BINOMIAL[xp.diff + k, xp.diff];
                            re += gx.poster * gy.poster * Math.Log(lt);
                            j++;
                        }
                }
                xp.li = re < -1e100 ? -1e100 : re;
            }

            public unsafe static double RelatednessHuang2014Moment(IND x, IND y, LOC[] loc, double* R1 = null, double* R2 = null, double* W1 = null, double* W2 = null)
            {
                if (x.ploidy < 1 || x.ploidy > MAX_PLOIDY || y.ploidy < 1 || y.ploidy > MAX_PLOIDY)
                    return double.NaN;
                double sr1 = 0, sw1 = 0, sr2 = 0, sw2 = 0, tr1 = 0, tw1 = 0, tr2 = 0, tw2 = 0;

                for (int l = 0; l < loc.Length; ++l)
                {
                    tr1 = Huang2014Moment2(x.g[l], y.g[l], loc[l], ref tw1);
                    sr1 += tr1 * tw1;
                    sw1 += tw1;

                    tr2 = Huang2014Moment2(y.g[l], x.g[l], loc[l], ref tw2);
                    sr2 += tr2 * tw2;
                    sw2 += tw2;

                    if (R1 != null)
                    {
                        R1[l] = tr1 * tw1;
                        W1[l] = tw1;
                        R2[l] = tr2 * tw2;
                        W2[l] = tw2;
                    }
                }
                return (sr1 / sw1 + sr2 / sw2) / 2;
            }

            public static double S_Index(GENOTYPE gx, GENOTYPE gy, int maxploidy)
            {
                int re = 0;
                foreach (var a in gx.alleles)
                    if (gy.alleles.ContainsKey(a.Key))
                        re += Math.Min(a.Value, gy.alleles[a.Key]);
                return re / (double)maxploidy;
            }

            public static double Huang2014Moment2(PHENOTYPE x, PHENOTYPE y, LOC loc, ref double weight)
            {
                weight = 0;
                int maxploidy = Math.Max(x.ploidy, y.ploidy);
                int minploidy = Math.Min(x.ploidy, y.ploidy);

                if (x.hash == 0 || y.hash == 0)
                    return 0;

                int start = maxploidy - minploidy;
                double[,] e = new double[maxploidy + 1, maxploidy + 1];
                var Mb = LinearAlgebra.Matrix<double>.Build;
                var E1 = Mb.Dense(maxploidy, maxploidy); //header delta
                var E2 = Mb.Dense(maxploidy, 1); //header 1
                var S = Mb.Dense(maxploidy, maxploidy); //header 1
                var vS = Mb.Dense(maxploidy, 1); //header 1
                var vM = Mb.Dense(maxploidy, maxploidy); //header 1
                var vA = Mb.Dense(maxploidy, 1); //header 1
                var vP = Mb.Dense(maxploidy, 1); //header 1

                for (int j = 0; j < maxploidy; ++j)
                {
                    double s = (maxploidy - j) / (double)maxploidy;
                    S[0, j] = s;
                    for (int i = 1; i < maxploidy; ++i)
                        S[i, j] = S[i - 1, j] * s;
                }

                foreach (GENOTYPE gx in x.genotypes)
                {
                    Array.Clear(e, 0, (maxploidy + 1) * (maxploidy + 1));
                    int refmode = 10000 * y.ploidy + 100 * x.ploidy + gx.GetRefMode();
                    foreach (GENOTYPE gy in y.genotypes)
                    {
                        double Si = S_Index(gx, gy, maxploidy);
                        double p = gx.poster * gy.poster;
                        for (int i = 0; i < maxploidy; ++i)
                            vS[i, 0] += Math.Pow(Si, i + 1) * p;
                    }

                    MOM.mom_assign(refmode, e, loc.freq, gx.alleles2, maxploidy);
                    for (int i = 0; i < maxploidy; ++i)
                    {
                        E2[i, 0] = e[i, maxploidy];
                        for (int j = 0; j < maxploidy; ++j)
                            E1[i, j] = e[i, j] - e[i, maxploidy];
                    }

                    vM += gx.poster * S * E1;
                    vA += gx.poster * S * E2;
                    vP += gx.poster * E2;
                }

                var vD = vS - vA;

                for (int i = minploidy; i < maxploidy; ++i)
                {
                    vD[i, 0] = 0;
                    for (int j = 0; j < maxploidy; ++j)
                        vM[i, j] = vM[j, maxploidy - 1 - i] = 0;
                    vM[i, maxploidy - 1 - i] = 1;
                }

                vM = vM.PseudoInverse();
                var vR = vM * vD;

                double r = 0;
                for (int i = 0; i < maxploidy; ++i)
                    r += vR[i, 0] * (maxploidy - i) / maxploidy;

                if (r > 1.001 || r < -16 || double.IsNaN(r) || double.IsInfinity(r))
                    return 0;
                //weight

                double e1 = 0, e2 = 0;
                double[] Sol = new double[maxploidy];

                double res = 1;
                for (int i = 0; i < maxploidy; ++i)
                    res -= vP[i, 0];

                for (int i = start; i <= maxploidy; ++i)
                {
                    double s = (maxploidy - i) / (double)maxploidy;
                    for (int j = 0; j < maxploidy; ++j)
                        vD[j, 0] = MOM.mp(s, j + 1) - vA[j, 0];
                    for (int j = minploidy; j < maxploidy; ++j)
                        vD[j, 0] = 0;

                    vR = vM * vD;
                    double Sr = 0;
                    for (int j = 0; j < maxploidy; ++j)
                        Sr += vR[j, 0] * (maxploidy - j) / maxploidy;

                    if (i == maxploidy)
                    {
                        e1 += res * Sr;
                        e2 += res * Sr * Sr;
                    }
                    else
                    {
                        e1 += vP[i, 0] * Sr;
                        e2 += vP[i, 0] * Sr * Sr;
                    }
                }
                weight = Truncate(0, 100, 1 / (e2 - e1 * e1));
                return r;
            }

            public unsafe static double RelatednessRitland1996_homo(IND x, IND y, LOC[] loc, double* R1 = null, double* R2 = null, double* W1 = null, double* W2 = null)
            {
                //used for homoploids, estimate three kinship coefficients, then convert into relatedness coefficient
                double sw1 = 0, sr1 = 0, sw2 = 0, sr2 = 0;
                int vmin = Math.Min(x.ploidy, y.ploidy), vmax = Math.Max(x.ploidy, y.ploidy);

                for (int l = 0; l < loc.Length; ++l)
                {
                    if (R1 != null) { R1[l] = W1[l] = R2[l] = W2[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    var fx = x.g[l].freq;
                    var fy = y.g[l].freq;
                    var f = loc[l].freq;

                    double t1 = f.Sum(a => fx.ContainsKey(a.Key) && fy.ContainsKey(a.Key) ? fx[a.Key] * fy[a.Key] / a.Value : 0) - 1;
                    double t2 = f.Sum(a => fx.ContainsKey(a.Key) ? fx[a.Key] * fx[a.Key] / a.Value : 0) - 1;
                    double t3 = f.Sum(a => fy.ContainsKey(a.Key) ? fy[a.Key] * fy[a.Key] / a.Value : 0) - 1;

                    if (!double.IsNaN(t1) && !double.IsNaN(t2) && !double.IsNaN(t3))
                    {
                        sr1 += t1;
                        sw1 += t2;
                        sr2 += t1;
                        sw2 += t3;
                    }
                    else t1 = t2 = t3 = 0;

                    if (R1 != null) { R1[l] = t1; W1[l] = t2; R2[l] = t1; W2[l] = t3; }
                }
                return (sr1 / sw1 + sr2 / sw2) * 0.5;
            }
            
            public unsafe static double RelatednessRitland1996(IND x, IND y, LOC[] loc, double* RLoc = null, double* WLoc = null)
            {
                //used for anisoploids, convert into relatedness coefficients for each locus
                double sw = 0, sr = 0;
                int vmin = Math.Min(x.ploidy, y.ploidy), vmax = Math.Max(x.ploidy, y.ploidy);

                for (int l = 0; l < loc.Length; ++l)
                {
                    if (RLoc != null) { RLoc[l] = WLoc[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    var fx = x.g[l].freq; 
                    var fy = y.g[l].freq;
                    var f = loc[l].freq;

                    /* 1.6x speed
                    double t1 = -1, t2 = -1, t3 = -1;

                    foreach (var a in f)
                    {
                        double px = GetDictionaryValue(fx, a.Key);
                        double py = GetDictionaryValue(fy, a.Key);
                        t1 += px * py / a.Value;
                        t2 += px * px / a.Value;
                        t3 += py * py / a.Value;
                    }
                    */

                    double t1 = f.Sum(a => fx.ContainsKey(a.Key) && fy.ContainsKey(a.Key) ? fx[a.Key] * fy[a.Key] / a.Value : 0) - 1;
                    double t2 = f.Sum(a => fx.ContainsKey(a.Key) ? fx[a.Key] * fx[a.Key] / a.Value : 0) - 1;
                    double t3 = f.Sum(a => fy.ContainsKey(a.Key) ? fy[a.Key] * fy[a.Key] / a.Value : 0) - 1;
                    double tr = (t1 / t2 + t1 / t3) * 0.5 * loc[l].AE * 2 * vmin / (vmin + vmax);
                    double tw = loc[l].AE;

                    if (!double.IsNaN(tr))
                    {
                        sr += tr;
                        sw += tw;
                    }
                    else tr = tw = 0;

                    if (RLoc != null) { RLoc[l] = tr; WLoc[l] = tw; }
                }
                return sr / sw;
            }

            public unsafe static double KinshipRitland1996(IND x, IND y, LOC[] loc, double* RLoc = null, double* WLoc = null)
            {
                double sw = 0, sr = 0;

                for (int l = 0; l < loc.Length; ++l)
                {
                    if (RLoc != null) { RLoc[l] = WLoc[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    var fx = x.g[l].freq; 
                    var fy = y.g[l].freq; 
                    var f = loc[l].freq;

                    double tr = x == y ? 
                        x.g[l].genotypes.Sum(g => g.poster * g.alleles.Sum(kv => kv.Value * kv.Value / (x.ploidy * x.ploidy * f[kv.Key]))) - 1 : 
                        f.Sum(a => fx.ContainsKey(a.Key) && fy.ContainsKey(a.Key) ? fx[a.Key] * fy[a.Key] / a.Value : 0) - 1;
                    double tw = f.Values.Count(p => p > MINALLELEFREQ) - 1;

                    if (!double.IsNaN(tr))
                    {
                        sr += tr;
                        sw += tw;
                    }
                    else tr = tw = 0;

                    if (RLoc != null) { RLoc[l] = tr; WLoc[l] = tw; }
                }

                return sr / sw;
            }

            public unsafe static double RelatednessLoiselle1995_homo(IND x, IND y, LOC[] loc, double* R1 = null, double* R2 = null, double* W1 = null, double* W2 = null)
            {
                double sw1 = 0, sr1 = 0, sw2 = 0, sr2 = 0;
                int vmin = Math.Min(x.ploidy, y.ploidy), vmax = Math.Max(x.ploidy, y.ploidy);

                for (int l = 0; l < loc.Length; ++l)
                {
                    if (R1 != null) { R1[l] = W1[l] = R2[l] = W2[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    var fx = x.g[l].freq; 
                    var fy = y.g[l].freq;
                    var f = loc[l].freq;

                    double t1 = f.Sum(a => (GetDictionaryValue(fx, a.Key) - a.Value) * (GetDictionaryValue(fy, a.Key) - a.Value));
                    double t2 = f.Sum(a => Math.Pow(GetDictionaryValue(fx, a.Key) - a.Value, 2));
                    double t3 = f.Sum(a => Math.Pow(GetDictionaryValue(fy, a.Key) - a.Value, 2));

                    if (!double.IsNaN(t1) && !double.IsNaN(t2) && !double.IsNaN(t3))
                    {
                        sr1 += t1;
                        sw1 += t2;
                        sr2 += t1;
                        sw2 += t3;
                    }
                    else t1 = t2 = t3 = 0;

                    if (R1 != null) { R1[l] = t1; W1[l] = t2; R2[l] = t1; W2[l] = t3; }
                }
                return (sr1 / sw1 + sr2 / sw2) * 0.5;
            }

            public unsafe static double RelatednessLoiselle1995(IND x, IND y, LOC[] loc, double* RLoc = null, double* WLoc = null)
            {
                double sr = 0, sw = 0;
                int vmin = Math.Min(x.ploidy, y.ploidy), vmax = Math.Max(x.ploidy, y.ploidy);

                for (int l = 0; l < loc.Length; ++l)
                {
                    if (RLoc != null) { RLoc[l] = WLoc[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    var fx = x.g[l].freq; 
                    var fy = y.g[l].freq;
                    var f = loc[l].freq;

                    double t1 = f.Sum(a => (GetDictionaryValue(fx, a.Key) - a.Value) * (GetDictionaryValue(fy, a.Key) - a.Value));
                    double t2 = f.Sum(a => Math.Pow(GetDictionaryValue(fx, a.Key) - a.Value, 2));
                    double t3 = f.Sum(a => Math.Pow(GetDictionaryValue(fy, a.Key) - a.Value, 2));
                    double tr = (t1 / t2 + t1 / t3) * 0.5 * loc[l].AE * 2 * vmin / (vmin + vmax);
                    double tw = loc[l].AE;
                    if (!double.IsNaN(tr))
                    {
                        sr += tr;
                        sw += tw;
                    }
                    else tr = tw = 0;

                    if (RLoc != null) { RLoc[l] = tr; WLoc[l] = tw; }
                }
                return sr / sw;
            }
            
            public unsafe static double KinshipLoiselle1995(IND x, IND y, LOC[] loc, double* RLoc = null, double* WLoc = null)
            {
                double sw = 0, sr = 0;
                for (int l = 0; l < loc.Length; ++l)
                {
                    if (RLoc != null) { RLoc[l] = WLoc[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    var fx = x.g[l].freq; 
                    var fy = y.g[l].freq;
                    var f = loc[l].freq;

                    double tr = x == y ?
                        x.g[l].genotypes.Sum(g => g.poster * 
                        f.Sum(a => Math.Pow(GetDictionaryValue(g.alleles, a.Key) / (double)x.ploidy - a.Value, 2))) : //f.Sum(a => Math.Pow(GetDictionaryValue(g.alleles, a.Key) / (double)x.ploidy - a.Value, 2)
                        f.Sum(a => (GetDictionaryValue(fx, a.Key) - a.Value) * (GetDictionaryValue(fy, a.Key) - a.Value));
                    double tw = f.Values.Sum(p => p * (1 - p));
                    if (!double.IsNaN(tr))
                    {
                        sr += tr;
                        sw += tw;
                    }
                    else tr = tw = 0;

                    if (RLoc != null) { RLoc[l] = tr; WLoc[l] = tw; }
                }
                return sr / sw;
            }

            public unsafe static double RelatednessHuangUnpub(IND x, IND y, LOC[] loc, double* RLoc = null, double* WLoc = null)
            {
                //RelatednessWeir1996
                double sr = 0, sw = 0;
                int vmin = Math.Min(x.ploidy, y.ploidy), vmax = Math.Max(x.ploidy, y.ploidy);

                for (int l = 0; l < loc.Length; ++l)
                {
                    if (RLoc != null) { RLoc[l] = WLoc[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    var fx = x.g[l].freq; 
                    var fy = y.g[l].freq;
                    var f = loc[l].freq;

                    double fs2 = f.Values.Sum(p => p * p);
                    double t1 = f.Sum(a => fx.ContainsKey(a.Key) && fy.ContainsKey(a.Key) ? fx[a.Key] * fy[a.Key] : 0) - fs2;
                    double t2 = f.Sum(a => fx.ContainsKey(a.Key) ? fx[a.Key] * fx[a.Key] : 0) - fs2;
                    double t3 = f.Sum(a => fy.ContainsKey(a.Key) ? fy[a.Key] * fy[a.Key] : 0) - fs2;
                    double tr = (t1 / t2 + t1 / t3) * 0.5 * loc[l].AE * 2 * vmin / (vmin + vmax);
                    double tw = loc[l].AE;
                    if (!double.IsNaN(tr))
                    {
                        sr += tr;
                        sw += tw;
                    }
                    else tr = tw = 0;

                    if (RLoc != null) { RLoc[l] = tr; WLoc[l] = tw; }
                }
                return sr / sw;
            }

            public unsafe static double KinshipWeir1996(IND x, IND y, LOC[] loc, double* RLoc = null, double* WLoc = null)
            {
                double sr = 0, sw = 0;

                for (int l = 0; l < loc.Length; ++l)
                {
                    if (RLoc != null) { RLoc[l] = WLoc[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    var fx = x.g[l].freq; 
                    var fy = y.g[l].freq;
                    var f = loc[l].freq;

                    double fs2 = f.Values.Sum(p => p * p);
                    double tr = x == y ?
                        x.g[l].genotypes.Sum(g => g.poster * g.alleles.Sum(kv => kv.Value * kv.Value / (double)(x.ploidy * x.ploidy))) - fs2 :
                        f.Sum(a => fx.ContainsKey(a.Key) && fy.ContainsKey(a.Key) ? fx[a.Key] * fy[a.Key] : 0) - fs2;
                    double tw = 1 - fs2;
                    if (!double.IsNaN(tr))
                    {
                        sr += tr;
                        sw += tw;
                    }
                    else tr = tw = 0;

                    if (RLoc != null) { RLoc[l] = tr; WLoc[l] = tw; }
                }
                return sr / sw;
            }

            /*
            public unsafe static double RelatednessHuang2014Moment(IND x, IND y, LOC[] loc, double[] M, double* R1 = null, double* R2 = null, double* W1 = null, double* W2 = null)
            {
                //RelatednessHuangUnpubLoiselle1995
                double sw1 = 0, sr1 = 0, sw2 = 0, sr2 = 0;
                int vmin = Math.Min(x.ploidy, y.ploidy), vmax = Math.Max(x.ploidy, y.ploidy);

                for (int l = 0; l < loc.Length; ++l)
                {
                    if (R1 != null) { R1[l] = W1[l] = R2[l] = W2[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    var fx = x.g[l].freq; 
                    var fy = y.g[l].freq;
                    var f = loc[l].freq;

                    double fs2 = M[l], t1 = fs2, t2 = fs2, t3 = fs2;
                    foreach (var kv in f)
                    {
                        double px = GetDictionaryValue(fx, kv.Key);
                        double py = GetDictionaryValue(fy, kv.Key);
                        t1 += px * py - (px + py) * kv.Value;
                        t2 += px * px - (px + px) * kv.Value;
                        t3 += py * py - (py + py) * kv.Value;
                    }

                    if (!double.IsNaN(t1) && !double.IsNaN(t2) && !double.IsNaN(t3))
                    {
                        sr1 += t1;
                        sw1 += t2;
                        sr2 += t1;
                        sw2 += t3;
                    }
                    else t1 = t2 = t3 = 0;

                    if (R1 != null) { R1[l] = t1; W1[l] = t2; R2[l] = t1; W2[l] = t3; }
                }
                return (sr1 / sw1 + sr2 / sw2) * 0.5;
            }
            */

            public unsafe static double RelatednessHuangUnpubx(IND x, IND y, LOC[] loc, double[] M, double* RLoc = null, double* WLoc = null)
            {
                //RelatednessHuangUnpub
                double sr = 0, sw = 0;
                int vmin = Math.Min(x.ploidy, y.ploidy), vmax = Math.Max(x.ploidy, y.ploidy);

                for (int l = 0; l < loc.Length; ++l)
                {
                    if (RLoc != null) { RLoc[l] = WLoc[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    var fx = x.g[l].freq; 
                    var fy = y.g[l].freq;
                    var f = loc[l].freq;

                    double fs2 = M[l];
                    double t1 = f.Sum(a => fx.ContainsKey(a.Key) && fy.ContainsKey(a.Key) ? fx[a.Key] * fy[a.Key] : 0) - fs2;
                    double t2 = f.Sum(a => fx.ContainsKey(a.Key) ? fx[a.Key] * fx[a.Key] : 0) - fs2;
                    double t3 = f.Sum(a => fy.ContainsKey(a.Key) ? fy[a.Key] * fy[a.Key] : 0) - fs2;
                    double tr = (t1 / t2 + t1 / t3) * 0.5 * loc[l].AE * 2 * vmin / (vmin + vmax);
                    double tw = loc[l].AE;
                    if (!double.IsNaN(tr))
                    {
                        sr += tr;
                        sw += tw;
                    }
                    else tr = tw = 0;

                    if (RLoc != null) { RLoc[l] = tr; WLoc[l] = tw; }
                }
                return sr / sw;
            }

            public unsafe static double KinshipHuangUnpub(IND x, IND y, LOC[] loc, double[] M, double* RLoc = null, double* WLoc = null)
            {
                double sr = 0, sw = 0;

                for (int l = 0; l < loc.Length; ++l)
                {
                    if (RLoc != null) { RLoc[l] = WLoc[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    var fx = x.g[l].freq; 
                    var fy = y.g[l].freq;
                    var f = loc[l].freq;

                    double fs2 = M[l];
                    double tr = x == y ?
                        x.g[l].genotypes.Sum(g => g.poster * g.alleles.Sum(kv => kv.Value * kv.Value / (double)(x.ploidy * x.ploidy))) - fs2 :
                        f.Sum(a => fx.ContainsKey(a.Key) && fy.ContainsKey(a.Key) ? fx[a.Key] * fy[a.Key] : 0) - fs2;
                    double tw = 1 - fs2;
                    if (!double.IsNaN(tr))
                    {
                        sr += tr;
                        sw += tw;
                    }
                    else tr = tw = 0;

                    if (RLoc != null) { RLoc[l] = tr; WLoc[l] = tw; }
                }
                return sr / sw;
            }

            public unsafe static double KinshipHuangUnpubLoiselle1995(IND x, IND y, LOC[] loc, double[] M, double* RLoc = null, double* WLoc = null)
            {
                double sw = 0, sr = 0;
                for (int l = 0; l < loc.Length; ++l)
                {
                    if (RLoc != null) { RLoc[l] = WLoc[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    var fx = x.g[l].freq; 
                    var fy = y.g[l].freq;
                    var f = loc[l].freq;

                    double fs2 = M[l];
                    double tr = fs2 + (x == y ?
                        x.g[l].genotypes.Sum(g => g.poster * f.Sum(a =>
                        {
                            double px = GetDictionaryValue(g.alleles, a.Key) / (double)x.ploidy;
                            return px * px - 2 * px * a.Value;
                        }))
                        :
                        f.Sum(a =>
                        {
                            double px = GetDictionaryValue(fx, a.Key);
                            double py = GetDictionaryValue(fy, a.Key);
                            return px * py - (px + py) * a.Value;
                        }));
                    double tw = 1 - fs2;
                    if (!double.IsNaN(tr))
                    {
                        sr += tr;
                        sw += tw;
                    }
                    else tr = tw = 0;

                    if (RLoc != null) { RLoc[l] = tr; WLoc[l] = tw; }
                }
                return sr / sw;
            }

            public unsafe static double RelatednessHardy1999(IND x, IND y, LOC[] loc, double* RLoc = null, double* WLoc = null)
            {
                double sw = 0, sr = 0;
                for (int l = 0; l < loc.Length; ++l)
                {
                    if (RLoc != null) { RLoc[l] = WLoc[l] = 0; }
                    if (x.g[l].hash == 0 || y.g[l].hash == 0 || loc[l].freq.Count == 1) continue;
                    Dictionary<int, double> f1 = loc[l].freq2[0], f2 = loc[l].freq2[1];
                    var fx = x.g[l].freq; 
                    var fy = y.g[l].freq;

                    double tw = f2.Values.Sum() - f1.Values.Sum(f => f * f);
                    double tr = f1.Sum(a => (GetDictionaryValue(fx, a.Key) - a.Value) * (GetDictionaryValue(fy, a.Key) - a.Value)) + (loc[l].nphenotypes > 1 ? tw / (loc[l].nphenotypes - 1) : 0);
                    if (!double.IsNaN(tr))
                    {
                        sr += tr;
                        sw += tw;
                    }
                    else tr = tw = 0;

                    if (RLoc != null) { RLoc[l] = tr; WLoc[l] = tw; }
                }
                return sr / sw;
            }

            public static double R_JackknifeSE(double r, double[] RLoc, double[] WLoc, JackknifeType type)
            {
                switch (type)
                {
                    case JackknifeType.WeightedAverage://tr, tw
                        {
                            double sw = WLoc.Sum(), sr = r * sw;
                            int L = RLoc.Length, nl = 0;
                            double ex = 0, ex2 = 0;
                            for (int l = 0; l < L; ++l)
                            {
                                if (WLoc[l] == 0) continue;
                                double rl = (sr - RLoc[l]) / (sw - WLoc[l]);
                                ex += rl;
                                ex2 += rl * rl;
                                nl++;
                            }
                            ex /= nl;
                            ex2 /= nl;
                            return Math.Sqrt((nl - 1) * (ex2 - ex * ex));
                        }
                    case JackknifeType.PairWeightedAverage: //tr1, tw1, tr2, tw2
                        {
                            double sr1 = 0, sw1 = 0, sr2 = 0, sw2 = 0;
                            int L = RLoc.Length / 2, nl = 0;
                            double ex = 0, ex2 = 0;
                            for (int l = 0; l < L; ++l)
                            {
                                sr1 += RLoc[l];
                                sr2 += RLoc[l + L];
                                sw1 += WLoc[l];
                                sw2 += WLoc[l + L];
                            }
                            for (int l = 0; l < L; ++l)
                            {
                                if (WLoc[l] == 0 && WLoc[l + L] == 0) continue;
                                double rl = ((sr1 - RLoc[l]) / (sw1 - WLoc[l]) + (sr2 - RLoc[l + L]) / (sw2 - WLoc[l + L])) * 0.5;
                                ex += rl;
                                ex2 += rl * rl;
                                nl++;
                            }
                            ex /= nl;
                            ex2 /= nl;
                            return Math.Sqrt((nl - 1) * (ex2 - ex * ex));
                        }
                    case JackknifeType.Likelihood: //tr only
                        {
                            int L = RLoc.Length, nl = 0;
                            double ex = 0, ex2 = 0;
                            for (int l = 0; l < L; ++l)
                            {
                                double rl = RLoc[l];
                                if (double.IsNaN(rl) || double.IsInfinity(rl)) continue;
                                ex += rl;
                                ex2 += rl * rl;
                                nl++;
                            }
                            ex /= nl;
                            ex2 /= nl;
                            return Math.Sqrt((nl - 1) * (ex2 - ex * ex));
                        }
                }
                return double.NaN;
            }

            public unsafe void CalcRelationshipThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                double[,] res = (double[,])((object[])obj)[2];
                IND[] inds = (IND[])((object[])obj)[3];
                RelationshipEstimator estimator = (RelationshipEstimator)((object[])obj)[4];
                SUBPOP pop = (SUBPOP)((object[])obj)[5];

                LOC[] loc = pop.loc;
                double[] M = pop.Msl;

                int[] bufa = null, bufb = null;
                int[,,] alleles = null;
                double[,,] coef = null;
                uint[,] IBS = null;
                if (estimator == RelationshipEstimator.RelatednessHuang2015)
                {
                    bufa = new int[16];
                    bufb = new int[16];
                    coef = new double[L, 1225, 9];
                    alleles = new int[L, 1225, 16];
                    IBS = new uint[L, 1225];
                }

                double[] RLoc = new double[L * 2], WLoc = new double[L * 2];
                fixed (double* R = &RLoc[0], W = &WLoc[0])
                    for (int i = 0, cp = 0; i < inds.Length; ++i)
                    {
                        IND x = inds[i];
                        for (int j = 0; j <= i; ++j)
                        {
                            if (cp++ % N_THREAD != id) continue;
                            IND y = inds[j];

                            if (RELATIONSHIP_JACKKNIFE)
                            {
                                switch (estimator)
                                {
                                    case RelationshipEstimator.RelatednessHuang2014:
                                        res[i, j] = RelatednessHuang2014Moment(x, y, loc, R, R + L, W, W + L);
                                        res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.PairWeightedAverage);
                                        break;
                                    case RelationshipEstimator.RelatednessHuang2015:
                                        res[i, j] = RelatednessHuang2015ML(x, y, loc, bufa, bufb, alleles, coef, IBS, R); 
                                        res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.Likelihood);
                                        break;
                                    case RelationshipEstimator.RelatednessRitland1996:
                                        res[i, j] = RelatednessRitland1996(x, y, loc, R, W); 
                                        res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                        break;
                                    case RelationshipEstimator.KinshipRitland1996:
                                        res[i, j] = KinshipRitland1996(x, y, loc, R, W);
                                        res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                        break;
                                    case RelationshipEstimator.RelatednessLoiselle1995:
                                        res[i, j] = RelatednessLoiselle1995(x, y, loc, R, W);
                                        res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                        break;
                                    case RelationshipEstimator.KinshipLoiselle1995:
                                        res[i, j] = KinshipLoiselle1995(x, y, loc, R, W);
                                        res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                        break;
                                    case RelationshipEstimator.RelatednessHardy1999:
                                        res[i, j] = RelatednessHardy1999(x, y, loc, R, W);
                                        res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                        break;
                                    case RelationshipEstimator.KinshipWeir1996:
                                        res[i, j] = KinshipWeir1996(x, y, loc, R, W);
                                        res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                        break;
                                    case RelationshipEstimator.RelatednessHuangUnpub:
                                        res[i, j] = RelatednessHuangUnpub(x, y, loc, R, W);
                                        res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                        break;
                                    case RelationshipEstimator.KinshipHuangUnpub:
                                        res[i, j] = KinshipHuangUnpub(x, y, loc, M, R, W);
                                        res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                        break;
                                }
                            }
                            else switch (estimator)
                            {
                                case RelationshipEstimator.RelatednessHuang2014:
                                    res[i, j] = RelatednessHuang2014Moment(x, y, loc);
                                    res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.PairWeightedAverage);
                                    break;
                                case RelationshipEstimator.RelatednessHuang2015:
                                    res[i, j] = RelatednessHuang2015ML(x, y, loc, bufa, bufb, alleles, coef, IBS);
                                    res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.Likelihood);
                                    break;
                                case RelationshipEstimator.RelatednessRitland1996:
                                    res[i, j] = RelatednessRitland1996(x, y, loc);
                                    res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.PairWeightedAverage);
                                    break;
                                case RelationshipEstimator.KinshipRitland1996:
                                    res[i, j] = KinshipRitland1996(x, y, loc);
                                    res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                    break;
                                case RelationshipEstimator.RelatednessLoiselle1995:
                                    res[i, j] = RelatednessLoiselle1995(x, y, loc);
                                    res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.PairWeightedAverage);
                                    break;
                                case RelationshipEstimator.KinshipLoiselle1995:
                                    res[i, j] = KinshipLoiselle1995(x, y, loc);
                                    res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                    break;
                                case RelationshipEstimator.RelatednessHardy1999:
                                    res[i, j] = RelatednessHardy1999(x, y, loc);
                                    res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                    break;
                                case RelationshipEstimator.KinshipWeir1996:
                                    res[i, j] = KinshipWeir1996(x, y, loc);
                                    res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                    break;
                                case RelationshipEstimator.RelatednessHuangUnpub:
                                    res[i, j] = RelatednessHuangUnpub(x, y, loc);
                                    res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                    break;
                                case RelationshipEstimator.KinshipHuangUnpub:
                                    res[i, j] = KinshipHuangUnpub(x, y, loc, M);
                                    res[j, i + 1] = R_JackknifeSE(res[i, j], RLoc, WLoc, JackknifeType.WeightedAverage);
                                    break;
                            }
                            Increment();
                        }
                    }
            }

            public void CalcRelationship()
            {
                //make weight sum to one
                Progress = "Estimating pairwise relationship";
                ProgressValue = 0;

                StreamWriter wt = new StreamWriter(new FileStream("o_relationship.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_RELATIONSHIP = wt;

                bool[] estimators = new bool[] { RELATIONSHIP_Huang2014, RELATIONSHIP_Huang2015, RELATIONSHIP_Ritland1996m, RELATIONSHIP_Ritland1996, RELATIONSHIP_Loiselle1995m, RELATIONSHIP_Loiselle1995, RELATIONSHIP_Hardy1999, RELATIONSHIP_Weir1996, RELATIONSHIP_HuangUnpubm, RELATIONSHIP_HuangUnpub };

                if (RELATIONSHIP_Huang2015)
                    Huang2015ML_Initialize();

                if (RELATIONSHIP_TOT)
                    ProgressMax += inds.Length * (inds.Length + 1) / 2;

                if (RELATIONSHIP_REG)
                    for (int rl = 0; rl < regions.Length - 1; ++rl)
                        foreach (SUBPOP tr in regions[rl])
                            ProgressMax += tr.inds.Length * (tr.inds.Length + 1) / 2;

                if (RELATIONSHIP_POP) foreach (SUBPOP tp in subpops)
                        ProgressMax += tp.inds.Length * (tp.inds.Length + 1) / 2;

                ProgressMax *= estimators.Count(e => e);
                SetProgress(ProgressValue, ProgressMax);

                for (int i = 0; i < estimators.Length; ++i)
                {
                    if (!estimators[i]) continue;

                    switch ((RelationshipEstimator)i)
                    {
                        case RelationshipEstimator.RelatednessHuang2014: wt.Write("Huang et al. 2014 moment relatedness estimator\r\n"); break;
                        case RelationshipEstimator.RelatednessHuang2015: wt.Write("Huang et al. 2015 likelihood relatedness estimator\r\n"); break;
                        case RelationshipEstimator.RelatednessRitland1996: wt.Write("Ritland 1996 relatedness estimator, using Eqn 8 in Huang et al. 2015 Heredity\r\n"); break;
                        case RelationshipEstimator.KinshipRitland1996: wt.Write("Ritland 1996 kinship estimator\r\n"); break;
                        case RelationshipEstimator.RelatednessLoiselle1995: wt.Write("Loiselle 1995 relatedness estimator, using Eqn 8 in Huang et al. 2015 Heredity\r\n"); break;
                        case RelationshipEstimator.KinshipLoiselle1995: wt.Write("Loiselle 1995 kinship estimator\r\n"); break;
                        case RelationshipEstimator.RelatednessHardy1999: wt.Write("Hardy & Vekemans relatedness 1999 estimator\r\n"); break;
                        case RelationshipEstimator.KinshipWeir1996: wt.Write("Weir 1996 kinship estimator\r\n"); break;
                        case RelationshipEstimator.RelatednessHuangUnpub: wt.Write("Huang Unpub relatedness estimator, with correction for correlated samples\r\n"); break;
                        case RelationshipEstimator.KinshipHuangUnpub: wt.Write("Huang Unpub kinship estimator, with correction for correlated samples\r\n"); break;
                    }

                    if (RELATIONSHIP_TOT) 
                        for (int jk = 0; jk < (RELATIONSHIP_JACKKNIFE ? 2 : 1); ++jk)
                        {
                            wt.Write("Total" + (jk == 1 ? "_SE" : ""));
                            foreach (IND ind in inds)
                                wt.Write("\t" + ind.name);
                            wt.Write("\r\n");

                            double[,] res = new double[inds.Length, inds.Length + 1];
                            CallThread(CalcRelationshipThread, N_THREAD, new object[] { res, inds, (RelationshipEstimator)i, total_pop },
                                ProgressValue + inds.Length * (inds.Length + 1) / 2, ref ProgressValue);
                            for (int j = 0; j < inds.Length; ++j)
                            {
                                wt.Write(inds[j].name);
                                for (int k = 0; k < inds.Length; ++k)
                                    wt.Write("\t" + (jk == 0 && k <= j || jk == 1 && j <= k ? res[j, k + jk] : res[k, j + jk]).ToString(DECIMAL));
                                wt.Write("\r\n");
                            }
                            wt.Write("\r\n");
                            wt.Write("\r\n");
                        }

                    if (RELATIONSHIP_REG) 
                        for (int rl = 0; rl < regions.Length - 1; ++rl)
                            foreach (SUBPOP tr in regions[rl]) for (int jk = 0; jk < (RELATIONSHIP_JACKKNIFE ? 2 : 1); ++jk)
                                {
                                    wt.Write(tr.name + (jk == 1 ? "_SE" : ""));
                                    foreach (IND ind in tr.inds)
                                        wt.Write("\t" + ind.name);
                                    wt.Write("\r\n");

                                    double[,] res = new double[tr.inds.Length, tr.inds.Length + 1];
                                    CallThread(CalcRelationshipThread, N_THREAD, new object[] { res, tr.inds, (RelationshipEstimator)i, tr },
                                        ProgressValue + tr.inds.Length * (tr.inds.Length + 1) / 2, ref ProgressValue);
                                    for (int j = 0; j < tr.inds.Length; ++j)
                                    {
                                        wt.Write(tr.inds[j].name);
                                        for (int k = 0; k < tr.inds.Length; ++k)
                                            wt.Write("\t" + (jk == 0 && k <= j || jk == 1 && j <= k ? res[j, k + jk] : res[k, j + jk]).ToString(DECIMAL));
                                        wt.Write("\r\n");
                                    }
                                    wt.Write("\r\n");
                                    wt.Write("\r\n");
                                }

                    if (RELATIONSHIP_POP) 
                        foreach (SUBPOP tp in subpops) 
                            for (int jk = 0; jk < (RELATIONSHIP_JACKKNIFE ? 2 : 1); ++jk)
                            {
                                wt.Write(tp.name + (jk == 1 ? "_SE" : ""));
                                for (int j = 0; j < tp.inds.Length; ++j)
                                    wt.Write("\t" + tp.inds[j].name);
                                wt.Write("\r\n");

                                double[,] res = new double[tp.inds.Length, tp.inds.Length + 1];
                                CallThread(CalcRelationshipThread, N_THREAD, new object[] { res, tp.inds, (RelationshipEstimator)i, tp },
                                    ProgressValue + tp.inds.Length * (tp.inds.Length + 1) / 2, ref ProgressValue);
                                for (int j = 0; j < tp.inds.Length; ++j)
                                {
                                    wt.Write(tp.inds[j].name);
                                    for (int k = 0; k < tp.inds.Length; ++k)
                                        wt.Write("\t" + (jk == 0 && k <= j || jk == 1 && j <= k ? res[j, k + jk] : res[k, j + jk]).ToString(DECIMAL));
                                    wt.Write("\r\n");
                                }
                                wt.Write("\r\n");
                                wt.Write("\r\n");
                            }
                }

                if (RELATIONSHIP_Huang2015)
                    Huang2015ML_Uninitialize();
                wt.Flush();
                wt.Close();
            }

            #endregion

            #region Heritability

            public unsafe void CalcHeritabilityThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                StringBuilder[] Sb = (StringBuilder[])((object[])obj)[2];
                SUBPOP[] subpops = (SUBPOP[])((object[])obj)[3];
                int nestimator = (int)((object[])obj)[4];
                string[] estimator_name = (string[])((object[])obj)[5];
                bool[] estimator = (bool[])((object[])obj)[6];

                for (int i = 0; i < subpops.Length; ++i)
                {
                    if (i % nthreads != id) continue;

                    SUBPOP s = subpops[i];
                    StringBuilder sr = new StringBuilder();

                    sr.Append("\t\t\t");
                    for (int j = 0; j < estimator.Length; ++j)
                        if (estimator[j])
                            sr.Append("\t" + estimator_name[j] + (HERITABILITY_Jackknife ? "\t" : ""));

                    sr.Append("\r\n" + s.name + "\tn\tMean\tSD");
                    for (int j = 0; j < estimator.Length; ++j)
                        if (estimator[j])
                            sr.Append("\th2" + (HERITABILITY_Jackknife ? "\tSE" : ""));

                    for (int q = 0; q < nquantitative; ++q)
                    {
                        sr.Append("\r\n");

                        double[] sample = (from ind in s.inds where !double.IsNaN(ind.quantitative[q]) select ind.quantitative[q]).ToArray();
                        int count = sample.Length;
                        double ex = sample.Average();
                        double ex2 = sample.Average(p => p * p);
                        double var = ex2 - ex * ex;

                        sr.Append(quantitative_name[q] + "\t" + count + "\t" + ex.ToString(DECIMAL) + "\t" + Math.Sqrt(var).ToString(DECIMAL));

                        IND[] vinds = (from ind in inds where !double.IsNaN(ind.quantitative[q]) select ind).ToArray();

                        double[] Pxlk2 = null, Pslk2 = null, M = null;

                        if (estimator[(int)HeritabilityEstimator.HuangML] || estimator[(int)HeritabilityEstimator.HuangRegress])
                        {
                            Pxlk2 = new double[L];
                            Pslk2 = new double[L];
                            for (int l = 0; l < L; ++l)
                            {
                                var phenos = vinds.Where(ind => ind.g[l].hash != 0);
                                //Eqn (21) in Fst paper
                                Pxlk2[l] = phenos.Average(ind => SumProd(ind.g[l].freq, ind.g[l].freq));//individual homozygosity
                                Pslk2[l] = 1 - phenos.Average(ind => ind.g[l].GetHIndex());//population homozygosity
                            }
                            M = M_Nomura2008(NRRATE, Pslk2, vinds, 1, null);//necessary
                        }

                        double h2 = 0, se = 0;
                        for (int j = 0; j < estimator.Length; ++j)
                            if (estimator[j])
                            {
                                switch((HeritabilityEstimator)j)
                                {
                                    default:
                                    case HeritabilityEstimator.Ritland1996:  s.HeritabilityRitland1996(q, vinds, out h2, out se); break;
                                    case HeritabilityEstimator.HuangRegress: s.HeritabilityHuangRegress(q, vinds, Pxlk2, Pslk2, M, out h2, out se); break;
                                    case HeritabilityEstimator.Mousseau1998: 
                                    case HeritabilityEstimator.Thomas2000:   
                                    case HeritabilityEstimator.HuangML:      s.HeritabilityML((HeritabilityEstimator)j, q, vinds, Pxlk2, Pslk2, M, out h2, out se); break;
                                }
                                sr.Append("\t" + h2.ToString(DECIMAL) + (HERITABILITY_Jackknife ? "\t" + se.ToString(DECIMAL) : ""));
                                Increment();
                            }
                    }

                    sr.Append("\r\n\r\n");

                    Sb[i] = sr;
                }
            }

            public void CalcHeritability()
            {
                GC.Collect();
                Progress = "Estimating heritability";

                string[] estimator_name = new string[] { "Ritland1996", "Mousseau1998", "Thomas2000", "HuangML", "HuangMOM" };
                bool[] estimator = new bool[] { HERITABILITY_Ritland1996, HERITABILITY_Mousseau1998, HERITABILITY_Thomas2000, HERITABILITY_HuangML, HERITABILITY_HuangMOM };
                int nestimator = estimator.Count(b => b);

                ProgressValue = 0;
                ProgressMax = subpops.Length * nestimator * nquantitative;
                SetProgress(ProgressValue, ProgressMax);

                StreamWriter wt = new StreamWriter(new FileStream("o_heritability.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_HERITABILITY = wt;

                StringBuilder[] Sb = new StringBuilder[subpops.Length];
                CallThread(CalcHeritabilityThread, N_THREAD, new object[] { Sb, subpops, nestimator, estimator_name, estimator }, ProgressMax, ref ProgressValue);

                foreach (StringBuilder s in Sb)
                    wt.Write(s);
                wt.Flush();
                wt.Close();
            }
            #endregion

            #region Qst

            public unsafe void CalcQstThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
            }

            public void CalcQst()
            {
                GC.Collect();
                Progress = "Estimating Qst";

                ProgressValue = 0;
                ProgressMax = 0;
                SetProgress(ProgressValue, ProgressMax);

                StreamWriter wt = new StreamWriter(new FileStream("o_qst.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_QST = wt;

                //CallThread(CalcQstThread, N_THREAD, new object[] { wt }, ProgressMax, ref ProgressValue);

                wt.Flush();
                wt.Close();
            }

            #endregion

            #region Parentage

            public class ParentageAnalysisResultEntry
            {
                //Offspring ID	
                // Loci typed	Mother ID	Loci typed	Pair loci compared	Pair loci mismatching Pair LOD score
                // Candidate father ID	Loci typed	Pair loci compared	Pair loci mismatching	 Pair LOD score Pair Delta Pair confidence
                //	Trio loci compared	Trio loci mismatching	Trio LOD score	Trio Delta	Trio confidence
                public string oid;
                public int olocityped;

                public string mid;
                public int mlocityped;
                public int molocityped;
                public int molocimismatch;
                public double molod;
                public double modelta;
                public string mop;

                public string fid;
                public int flocityped;
                public int folocityped;
                public int folocimismatch;
                public double folod;
                public double fodelta;
                public string fop;

                public int fmolocityped;
                public int fmolocimismatch;
                public double fmolod;
                public double fmodelta;
                public string fmop;

                public void WritePA(StreamWriter wt)
                {
                    if (fmolocityped == -1)
                        wt.WriteLine(oid + "\t" + olocityped + "\t\t\t\t\t\t" + fid + "\t" + flocityped + "\t" + folocityped + "\t" + folocimismatch + "\t" + folod.ToString(DECIMAL) + "\t" + fodelta.ToString(DECIMAL)
                                     + "\t" + fop + "\t\t\t\t\t");
                    else
                        wt.WriteLine(oid + "\t" + olocityped + "\t" + mid + "\t" + mlocityped + "\t" + molocityped + "\t" + molocimismatch + "\t" + molod.ToString(DECIMAL)
                                     + "\t" + fid + "\t" + flocityped + "\t" + folocityped + "\t" + folocimismatch + "\t" + folod.ToString(DECIMAL) + "\t" + fodelta.ToString(DECIMAL)
                                     + "\t" + fop + "\t" + fmolocityped + "\t" + fmolocimismatch + "\t" + fmolod.ToString(DECIMAL) + "\t" + fmodelta.ToString(DECIMAL) + "\t" + fmop);
                }

                public void WritePP(StreamWriter wt)
                {
                    wt.WriteLine(oid + "\t" + olocityped + "\t" + mid + "\t" + mlocityped + "\t" + molocityped + "\t" + molocimismatch + "\t" + molod.ToString(DECIMAL) + "\t" + modelta.ToString(DECIMAL) + "\t" + mop +
                                 "\t" + fid + "\t" + flocityped + "\t" + folocityped + "\t" + folocimismatch + "\t" + folod.ToString(DECIMAL) + "\t" + fodelta.ToString(DECIMAL) + "\t" + fop +
                                 "\t" + fmolocityped + "\t" + fmolocimismatch + "\t" + fmolod.ToString(DECIMAL) + "\t" + fmodelta.ToString(DECIMAL) + "\t" + fmop);
                }

                public void WriteUS(StreamWriter wt)
                {
                    wt.WriteLine(oid + "\t" + olocityped +
                                 "\t" + mid + "\t" + mlocityped + "\t" + molocityped + "\t" + molocimismatch + "\t" + molod.ToString(DECIMAL) +
                                 "\t" + fid + "\t" + flocityped + "\t" + folocityped + "\t" + folocimismatch + "\t" + folod.ToString(DECIMAL) +
                                 "\t" + fmolocityped + "\t" + fmolocimismatch + "\t" + fmolod.ToString(DECIMAL) + "\t" + fmodelta.ToString(DECIMAL) + "\t" + fmop);
                }
            }

            public struct ParentageSimResultEntry
            {
                public double delta;
                public ParentageSimResult state;

                public ParentageSimResultEntry(ParentageSimResult a1, double a2)
                {
                    state = a1;
                    delta = a2;
                }
            }

            public class ParentageLodPercentileEntry
            {
                public double[] T;
                public double[] T2;
                public int[] nT;

                public double[] F;
                public double[] F2;
                public int[] nF;

                public double[] Fm;
                public double[] Fm2;
                public int[] nFm;

                public ParentageLodPercentileEntry(int n)
                {
                    T = new double[n];
                    T2 = new double[n];
                    nT = new int[n];

                    F = new double[n];
                    F2 = new double[n];
                    nF = new int[n];

                    Fm = new double[n];
                    Fm2 = new double[n];
                    nFm = new int[n];
                }

                public void PushTrue(double lod, int id)
                {
                    if (double.IsInfinity(lod) || double.IsNaN(lod)) return;
                    T[id] += lod;
                    T2[id] += lod * lod;
                    nT[id]++;
                }

                public void PushFalse(double lod, int id)
                {
                    if (double.IsInfinity(lod) || double.IsNaN(lod)) return;
                    F[id] += lod;
                    F2[id] += lod * lod;
                    nF[id]++;
                }

                public void PushFalseMax(double lod, int id)
                {
                    if (double.IsInfinity(lod) || double.IsNaN(lod)) return;
                    Fm[id] += lod;
                    Fm2[id] += lod * lod;
                    nFm[id]++;
                }

                public void Summary()
                {
                    T[0] = T.Sum();
                    T2[0] = T2.Sum();
                    nT[0] = nT.Sum();
                    T[0] /= nT[0];
                    T2[0] /= nT[0];
                    T2[0] -= T[0] * T[0];

                    F[0] = F.Sum();
                    F2[0] = F2.Sum();
                    nF[0] = nF.Sum();
                    F[0] /= nF[0];
                    F2[0] /= nF[0];
                    F2[0] -= F[0] * F[0];

                    Fm[0] = Fm.Sum();
                    Fm2[0] = Fm2.Sum();
                    nFm[0] = nFm.Sum();
                    Fm[0] /= nFm[0];
                    Fm2[0] /= nFm[0];
                    Fm2[0] -= Fm[0] * Fm[0];
                }
            }

            public class ParentageLodStructEntry
            {
                public double mT = 0, sdT = 0, nT = 0, sT = 0, sT2 = 0;
                public double mF = 0, sdF = 0, nF = 0, sF = 0, sF2 = 0;
                public double mA = 0, sdA = 0, nA = 0, sA = 0, sA2 = 0;

                public void PushT(double lod)
                {
                    nT++;
                    sT += lod;
                    sT2 += lod * lod;
                }

                public void PushF(double lod)
                {
                    nF++;
                    sF += lod;
                    sF2 += lod * lod;
                }

                public void PushA(double lod)
                {
                    nA++;
                    sA += lod;
                    sA2 += lod * lod;
                }

                public void Summary()
                {
                    mT = sT / nT;
                    sdT = Math.Sqrt(sT2 / nT - mT * mT);

                    mF = sF / nF;
                    sdF = Math.Sqrt(sF2 / nF - mF * mF);

                    mA = sA / nA;
                    sdA = Math.Sqrt(sA2 / nA - mA * mA);
                }

                public double fT(double x)
                {
                    return NormalDistPDF(x, mT, sdT);
                }

                public double fF(double x)
                {
                    return NormalDistPDF(x, mF, sdF);
                }

                public double FA(double x)
                {
                    return NormalDistCDF(x, mA, sdA);
                }

                public double FT(double x)
                {
                    return NormalDistCDF(x, mT, sdT);
                }

                public double FF(double x)
                {
                    return NormalDistCDF(x, mF, sdF);
                }

                public double fA(double x)
                {
                    return NormalDistPDF(x, mA, sdA);
                }

                private void PrCorrectPaternity(Point4 x4, object[] par)
                {
                    int n = (int)par[0], k = n - 1;
                    int nn = (int)par[1];
                    double target = (double)par[2];

                    double x = x4.real[0] = Math.Exp(x4.image[0]);
                    double s1 = 0, s2 = 0, s3 = 0, s4 = 0;

                    //mean:https://stats.stackexchange.com/questions/343914/expected-value-of-maximum-of-samples-from-normal-distribution
                    //var: https://stats.stackexchange.com/questions/394960/variance-of-normal-order-statistics?noredirect=1&lq=1
                    
                    //double mkF = mF + sdF * NormalDistCDF((k - Math.PI / 8.0) / (n - Math.PI / 4.0 + 1.0));
                    //double sdkF = sdF * Math.Sqrt(k * (n - k + 1.0) / (n + 2.0)) / ((n + 1.0) * NormalDistCDF(NormalDistICDF(k / (n + 1.0))));
                    //double st = mkF - 4 * sdkF, ed = mkF + 8 * sdkF, eps = (ed - st) / nn;
                    double st = -100, ed = 100, eps = (ed - st) / nn;
                    for (double u = st; u <= ed; u += eps)
                    {
                        double fFx = fF(u + x), fTx = fT(u + x);
                        double fFu = fF(u), fTu = fT(u);
                        double FFu = FF(u), FTu = FT(u);
                        double FFu1 = Math.Pow(FFu, n - 3);

                        double v1 = fFx * fFu *       FFu1 * FFu;
                        double v2 = fTx * fFu *       FFu1 * FFu;
                        double v3 = fFx * fTu *       FFu1 * FFu;
                        double v4 = fFx * fFu * FTu * FFu1;

                        /*
                        double v1 = fFx * fFu * Math.Pow(FFu, n - 2);
                        double v2 = fTx * fFu * Math.Pow(FFu, n - 2);
                        double v3 = fFx * fTu * Math.Pow(FFu, n - 2);
                        double v4 = fFx * fFu * FTu * Math.Pow(FFu, n - 3);
                        */
                        s1 += v1; s2 += v2; s3 += v3; s4 += v4;
                    }

                    double ps = PARENTAGE_SAMPLING_RATE;
                    s1 *= (1 - ps) * n * (n - 1);
                    s2 *= ps * (n - 1);
                    s3 *= ps * (n - 1);
                    s4 *= ps * (n - 1) * (n - 2);
                    double pc = s2 / (s1 + s2 + s3 + s4);
                    x4.li = -(pc - target) * (pc - target);
                }

                public void Paternity(int n, ref double d80, ref double d95, ref double d99, ref double d999)
                {
                    d80 = Point4.DownHillSimplex(1, 1, PrCorrectPaternity, new object[] { n, 1000, 0.8 }, p => p.image[0] = 1).real[0];
                    d95 = Point4.DownHillSimplex(1, 1, PrCorrectPaternity, new object[] { n, 1000, 0.95 }, p => p.image[0] = 1).real[0];
                    d99 = Point4.DownHillSimplex(1, 1, PrCorrectPaternity, new object[] { n, 1000, 0.99 }, p => p.image[0] = 1).real[0];
                    d999 = Point4.DownHillSimplex(1, 1, PrCorrectPaternity, new object[] { n, 1000, 0.999 }, p => p.image[0] = 1).real[0];
                }

                private void PrCorrectParentPair(Point4 x4, object[] par)
                {
                    int m = (int)par[0], n = (int)par[1], k = m * n - 1, mn = m * n;
                    int nn = (int)par[2];
                    double target = (double)par[3];

                    double x = x4.real[0] = Math.Exp(x4.image[0]);
                    double s1 = 0, s2 = 0, s3 = 0, s4 = 0, s5 = 0, s6 = 0, s7 = 0, s8 = 0, s9 = 0;
                    double s10 = 0, s11 = 0, s12 = 0, s13 = 0, s14 = 0, s15 = 0, s16 = 0, s17 = 0;

                    //mean:https://stats.stackexchange.com/questions/343914/expected-value-of-maximum-of-samples-from-normal-distribution
                    //var: https://stats.stackexchange.com/questions/394960/variance-of-normal-order-statistics?noredirect=1&lq=1

                    //double mkF = mF + sdF * NormalDistCDF((k - Math.PI / 8.0) / (mn - Math.PI / 4.0 + 1.0));
                    //double sdkF = sdF * Math.Sqrt(k * (mn - k + 1.0) / (mn + 2.0)) / ((mn + 1.0) * NormalDistCDF(NormalDistICDF(k / (mn + 1.0))));
                    //double st = mkF - 4 * sdkF, ed = mkF + 8 * sdkF, eps = (ed - st) / nn;
                    double st = -100, ed = 100, eps = (ed - st) / nn;

                    for (double u = st; u <= ed; u += eps)
                    {
                        double fFx = fF(u + x), fTx = fT(u + x), fAx = fA(u + x);
                        double fFu = fF(u), fTu = fT(u), fAu = fA(u);
                        double FFu = FF(u), FTu = FT(u), FAu = FA(u);
                        double FAu1 = Math.Pow(FFu, n - 2), FFu1 = Math.Pow(FFu, m * n - n - 2);
                        double FAu2 = Math.Pow(FFu, m - 2), FFu2 = Math.Pow(FFu, m * n - m - 2);
                        double FAu3 = Math.Pow(FFu, m + n - 4), FFu3 = Math.Pow(FFu, m * n - m - n - 1);

                        double v1 = fFx * fFu * Math.Pow(FFu, m * n - 2);

                        double v2 = fAx * fAu * FAu1 *             FFu1 * FFu * FFu;
                        double v3 = fAx * fFu * FAu1 * FAu *       FFu1 * FFu;
                        double v4 = fFx * fAu * FAu1 * FAu *       FFu1 * FFu;
                        double v5 = fFx * fFu * FAu1 * FAu * FAu * FFu1;

                        double v6 = fAx * fAu * FAu2 *             FFu2 * FFu * FFu;
                        double v7 = fAx * fFu * FAu2 * FAu *       FFu2 * FFu;
                        double v8 = fFx * fAu * FAu2 * FAu *       FFu2 * FFu;
                        double v9 = fFx * fFu * FAu2 * FAu * FAu * FFu2;

                        double v10 = fTx * fAu *       FAu3 * FAu       * FFu3 * FFu * FFu;
                        double v11 = fTx * fFu *       FAu3 * FAu * FAu * FFu3 * FFu;
                        double v12 = fAx * fTu *       FAu3 * FAu *       FFu3 * FFu * FFu;
                        double v13 = fFx * fTu *       FAu3 * FAu * FAu * FFu3 * FFu;
                        double v14 = fAx * fAu * FTu * FAu3 *             FFu3 * FFu * FFu;
                        double v15 = fFx * fFu * FTu * FAu3 * FAu * FAu * FFu3;
                        double v16 = fAx * fFu * FTu * FAu3 * FAu *       FFu3 * FFu;
                        double v17 = fFx * fAu * FTu * FAu3 * FAu *       FFu3 * FFu;

                        /*
                        double v1 = fFx * fFu * Math.Pow(FFu, m * n - 2);
                        double v2 = fAx * fAu * Math.Pow(FAu, n - 2) * Math.Pow(FFu, m * n - n);
                        double v3 = fAx * fFu * Math.Pow(FAu, n - 1) * Math.Pow(FFu, m * n - n - 1);
                        double v4 = fFx * fAu * Math.Pow(FAu, n - 1) * Math.Pow(FFu, m * n - n - 1);
                        double v5 = fFx * fFu * Math.Pow(FAu, n)     * Math.Pow(FFu, m * n - n - 2);

                        double v6 = fAx * fAu * Math.Pow(FAu, m - 2) * Math.Pow(FFu, m * n - m);
                        double v7 = fAx * fFu * Math.Pow(FAu, m - 1) * Math.Pow(FFu, m * n - m - 1);
                        double v8 = fFx * fAu * Math.Pow(FAu, m - 1) * Math.Pow(FFu, m * n - m - 1);
                        double v9 = fFx * fFu * Math.Pow(FAu, m)     * Math.Pow(FFu, m * n - m - 2);
                        double v10 = fTx * fAu * Math.Pow(FAu, m + n - 3) * Math.Pow(FFu, m * n - m - n + 1);
                        double v11 = fTx * fFu * Math.Pow(FAu, m + n - 2) * Math.Pow(FFu, m * n - m - n);
                        double v12 = fAx * fTu * Math.Pow(FAu, m + n - 3) * Math.Pow(FFu, m * n - m - n + 1);
                        double v13 = fFx * fTu * Math.Pow(FAu, m + n - 2) * Math.Pow(FFu, m * n - m - n);
                        double v14 = fAx * fAu * FTu * Math.Pow(FAu, m + n - 4) * Math.Pow(FFu, m * n - m - n + 1);
                        double v15 = fFx * fFu * FTu * Math.Pow(FAu, m + n - 2) * Math.Pow(FFu, m * n - m - n - 1);
                        double v16 = fAx * fFu * FTu * Math.Pow(FAu, m + n - 3) * Math.Pow(FFu, m * n - m - n);
                        double v17 = fFx * fAu * FTu * Math.Pow(FAu, m + n - 3) * Math.Pow(FFu, m * n - m - n);
                        */

                        s1 += v1; s2 += v2; s3 += v3; s4 += v4;
                        s5 += v5; s6 += v6; s7 += v7; s8 += v8;
                        s9 += v9; s10 += v10; s11 += v11; s12 += v12;
                        s13 += v13; s14 += v14; s15 += v15; s16 += v16; 
                        s17 += v17;
                    }

                    double ps = PARENTAGE_SAMPLING_RATE;
                    s1 *= (1 - ps) * (1 - ps) * mn * (mn - 1);
                    s2 *= (1 - ps) * ps * n * (n - 1);
                    s3 *= (1 - ps) * ps * n * (mn - n);
                    s4 *= (1 - ps) * ps * n * (mn - n);
                    s5 *= (1 - ps) * ps * (mn - n) * (mn - n - 1);

                    s6 *= (1 - ps) * ps * m * (m - 1);
                    s7 *= (1 - ps) * ps * m * (mn - m);
                    s8 *= (1 - ps) * ps * m * (mn - m);
                    s9 *= (1 - ps) * ps * (mn - m) * (mn - m - 1);

                    s10 *= ps * ps * (m + n - 2);
                    s11 *= ps * ps * (mn - m - n + 1);
                    s12 *= ps * ps * (m + n - 2);
                    s13 *= ps * ps * (mn - m - n + 1);
                    s14 *= ps * ps * (m + n - 2) * (m + n - 3);
                    s15 *= ps * ps * (mn - m - n + 1) * (mn - m - n);
                    s16 *= ps * ps * (m + n - 2) * (mn - m - n + 1);
                    s17 *= ps * ps * (m + n - 2) * (mn - m - n + 1);

                    double pc = (s10 + s11) / (s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8 + s9 + s10 + s11 + s12 + s13 + s14 + s15 + s16 + s17);
                    x4.li = -(pc - target) * (pc - target);
                }

                public void ParentPair(int m, int n, ref double d80, ref double d95, ref double d99, ref double d999)
                {
                    d80 = Point4.DownHillSimplex(1, 1, PrCorrectParentPair, new object[] { m, n, 1000, 0.8 }, p => p.image[0] = 1).real[0];
                    d95 = Point4.DownHillSimplex(1, 1, PrCorrectParentPair, new object[] { m, n, 1000, 0.95 }, p => p.image[0] = 1).real[0];
                    d99 = Point4.DownHillSimplex(1, 1, PrCorrectParentPair, new object[] { m, n, 1000, 0.99 }, p => p.image[0] = 1).real[0];
                    d999 = Point4.DownHillSimplex(1, 1, PrCorrectParentPair, new object[] { m, n, 1000, 0.999 }, p => p.image[0] = 1).real[0];
                }

                private void PrCorrectUnknown(Point4 x4, object[] par)
                {
                    int n = (int)par[0], l = n * (n - 1) / 2, k = (n - 2) * (n - 3) / 2;
                    int nn = (int)par[1];
                    double target = (double)par[2];

                    double x = x4.real[0] = Math.Exp(x4.image[0]);
                    double s1 = 0, s2 = 0, s3 = 0, s4 = 0, s5 = 0, s6 = 0, s7 = 0;
                    double s8 = 0, s9 = 0, s10 = 0, s11 = 0, s12 = 0, s13 = 0;

                    double st = -100, ed = 100, eps = (ed - st) / nn;

                    for (double u = st; u <= ed; u += eps)
                    {
                        double fFx = fF(u + x), fTx = fT(u + x), fAx = fA(u + x);
                        double fFu = fF(u), fTu = fT(u), fAu = fA(u);
                        double FFu = FF(u), FTu = FT(u), FAu = FA(u);
                        double FFu1 = Math.Pow(FFu, l - n - 1), FAu1 = Math.Pow(FAu, n - 3);
                        double FFu2 = Math.Pow(FFu, k - 2), FAu2 = Math.Pow(FAu, 2 * n - 6);

                        double v1 = fFx * fFu * Math.Pow(FFu, l - 2);

                        double v2 = fAx * fAu * FAu1 *             FFu1 * FFu * FFu;
                        double v3 = fAx * fFu * FAu1 * FAu *       FFu1 * FFu;
                        double v4 = fFx * fAu * FAu1 * FAu *       FFu1 * FFu;
                        double v5 = fFx * fFu * FAu1 * FAu * FAu * FFu1;

                        double v6 = fTx * fAu * FAu2 * FAu *       FFu2 * FFu * FFu;
                        double v7 = fTx * fFu * FAu2 * FAu * FAu * FFu2 * FFu;
                        double v8 = fAx * fTu * FAu2 * FAu *       FFu2 * FFu * FFu;
                        double v9 = fFx * fTu * FAu2 * FAu * FAu * FFu2 * FFu;

                        double v10 = fAx * fAu * FTu * FAu2 *             FFu2 * FFu * FFu;
                        double v11 = fFx * fFu * FTu * FAu2 * FAu * FAu * FFu2;
                        double v12 = fAx * fFu * FTu * FAu2 * FAu *       FFu2 * FFu;
                        double v13 = fFx * fAu * FTu * FAu2 * FAu *       FFu2 * FFu;

                        /*
                        double v1 = fFx * fFu * Math.Pow(FFu, l - 2);

                        double v2 = fAx * fAu * Math.Pow(FAu, n - 3) * Math.Pow(FFu, l - n + 1);
                        double v3 = fAx * fFu * Math.Pow(FAu, n - 2) * Math.Pow(FFu, l - n); 
                        double v4 = fFx * fAu * Math.Pow(FAu, n - 2) * Math.Pow(FFu, l - n);
                        double v5 = fFx * fFu * Math.Pow(FAu, n - 1) * Math.Pow(FFu, l - n - 1);

                        double v6 = fTx * fAu * Math.Pow(FAu, 2 * n - 5) * Math.Pow(FFu, k);
                        double v7 = fTx * fFu * Math.Pow(FAu, 2 * n - 4) * Math.Pow(FFu, k - 1);
                        double v8 = fAx * fTu * Math.Pow(FAu, 2 * n - 5) * Math.Pow(FFu, k);
                        double v9 = fFx * fTu * Math.Pow(FAu, 2 * n - 4) * Math.Pow(FFu, k - 1);

                        double v10 = fAx * fAu * FTu * Math.Pow(FAu, 2 * n - 6) * Math.Pow(FFu, k);
                        double v11 = fFx * fFu * FTu * Math.Pow(FAu, 2 * n - 4) * Math.Pow(FFu, k - 2);
                        double v12 = fAx * fFu * FTu * Math.Pow(FAu, 2 * n - 5) * Math.Pow(FFu, k - 1);
                        double v13 = fFx * fAu * FTu * Math.Pow(FAu, 2 * n - 5) * Math.Pow(FFu, k - 1);
                         */

                        s1 += v1; s2 += v2; s3 += v3; s4 += v4;
                        s5 += v5; s6 += v6; s7 += v7; s8 += v8;
                        s9 += v9; s10 += v10; s11 += v11; s12 += v12; s13 += v13; 
                    }

                    double ps = PARENTAGE_SAMPLING_RATE;
                    s1 *= (1 - ps) * (1 - ps) * l * (l - 1);

                    s2 *= 2 * (1 - ps) * ps * (n - 1) * (n - 2);
                    s3 *= 2 * (1 - ps) * ps * (n - 1) * (l - n + 1);
                    s4 *= 2 * (1 - ps) * ps * (n - 1) * (l - n + 1);
                    s5 *= 2 * (1 - ps) * ps * (l - n + 1) * (l - n);

                    s6 *= ps * ps * (2 * n - 4);
                    s7 *= ps * ps * k;
                    s8 *= ps * ps * (2 * n - 4);
                    s9 *= ps * ps * k;

                    s10 *= ps * ps * (2 * n - 4) * (2 * n - 5);
                    s11 *= ps * ps * k * (k - 1);
                    s12 *= ps * ps * k * (2 * n - 4);
                    s13 *= ps * ps * k * (2 * n - 4);

                    double pc = (s6 + s7) / (s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8 + s9 + s10 + s11 + s12 + s13);
                    x4.li = -(pc - target) * (pc - target);
                }

                public void Unknown(int n, ref double d80, ref double d95, ref double d99, ref double d999)
                {
                    d80 = Point4.DownHillSimplex(1, 1, PrCorrectUnknown, new object[] { n, 1000, 0.8 }, p => p.image[0] = 1).real[0];
                    d95 = Point4.DownHillSimplex(1, 1, PrCorrectUnknown, new object[] { n, 1000, 0.95 }, p => p.image[0] = 1).real[0];
                    d99 = Point4.DownHillSimplex(1, 1, PrCorrectUnknown, new object[] { n, 1000, 0.99 }, p => p.image[0] = 1).real[0];
                    d999 = Point4.DownHillSimplex(1, 1, PrCorrectUnknown, new object[] { n, 1000, 0.999 }, p => p.image[0] = 1).real[0];
                }
            }

            public ConcurrentDictionary<ulong, double>[] LOD2, LOD3, LOD4, T1D, T2D;

            public double T1(Dictionary<int, double> fre, double[] alpha, GENOTYPE o, GENOTYPE a)
            {
                //from G to g
                double re = 0;
                foreach (GENOBODY ga in a.gametes.Values) //enumerate gamete in father
                {
                    if (o.IsSemiGenotype(ga)) //the gamete can produce offspring
                    {
                        GENOBODY gb = o.GetSecondSemiGenotype(ga); //get another gamete
                        re += a.TransitionalGameteFrequency(alpha, ga) * gb.GFG(fre, alpha);
                    }
                }
                return re;
            }

            public double T2(Dictionary<int, double> fre, double[] alpha, GENOTYPE o, GENOTYPE a, GENOTYPE m)
            {
                //from G to g
                double re = 0;
                foreach (GENOBODY ga in m.gametes.Values) //enumerate gamete in mother
                {
                    if (o.IsSemiGenotype(ga)) //the gamete can produce offspring
                    {
                        GENOBODY gb = o.GetSecondSemiGenotype(ga); //get another gamete
                        if (a.gametes.ContainsKey(gb.hash)) //can father produce another gamete
                            re += m.TransitionalGameteFrequency(alpha, ga) * a.TransitionalGameteFrequency(alpha, gb);
                    }
                }
                return re;
            }

            bool parentage_correction = false;

            private double LH12oV1(Dictionary<int, double> fre, double[] alpha, GENOTYPE o, GENOTYPE a)
            {
                double T1oa = T1(fre, alpha, o, a);
                double Pro = o.prior;
                double Pra = a.prior;
                double e = PARENTAGE_MISTYPE_RATE;
                return (Pra * ((1 - e) * (1 - e) * T1oa
                               + 2 * e * (1 - e) * Pro
                               + e * e * Pro)) /
                       (Pra * Pro);
            }

            private double LH12oV1(Dictionary<int, double> fre, double[] alpha, GENOTYPE o, GENOTYPE a, GENOTYPE m)
            {
                double T2oam = T2(fre, alpha, o, a, m);
                double T1oa = T1(fre, alpha, o, a);
                double T1om = T1(fre, alpha, o, m);
                double Pro = o.prior;
                double Pra = a.prior;
                double Prm = m.prior;
                double e = PARENTAGE_MISTYPE_RATE;
                return (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T2oam
                                     + e * (1 - e) * (1 - e) * (T1oa + T1om + Pro)
                                     + 3 * e * e * (1 - e) * Pro
                                     + e * e * e * Pro)) /
                       (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T1om
                                  + e * (1 - e) * (1 - e) * (T1om + 2 * Pro)
                                  + 3 * e * e * (1 - e) * Pro
                                  + e * e * e * Pro));
            }

            private double LH12oV1(Dictionary<int, double> fre, double[] alpha, GENOTYPE o, GENOTYPE a, GENOTYPE m, GENOTYPE am)
            {
                double T2oam = T2(fre, alpha, o, a, m);
                double T1oa = T1(fre, alpha, o, a);
                double T1om = T1(fre, alpha, o, m);
                double Pro = o.prior;
                double Pra = a.prior;
                double Prm = m.prior;
                double e = PARENTAGE_MISTYPE_RATE;
                return parentage_correction ?
                    (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T2oam
                                  + e * (1 - e) * (1 - e) * (T1oa + T1om + Pro)
                                  + 3 * e * e * (1 - e) * Pro
                                  + e * e * e * Pro)) /
                    Math.Pow(Pra * Prm * Pro *
                             Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T1om
                                 + e * (1 - e) * (1 - e) * (T1om + 2 * Pro)
                                 + 3 * e * e * (1 - e) * Pro
                                 + e * e * e * Pro) *
                             Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T1oa
                                 + e * (1 - e) * (1 - e) * (T1oa + 2 * Pro)
                                 + 3 * e * e * (1 - e) * Pro
                                 + e * e * e * Pro), 1.0 / 3)
                                 :
                        (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T2oam
                                      + e * (1 - e) * (1 - e) * (T1oa + T1om + Pro)
                                      + 3 * e * e * (1 - e) * Pro
                                      + e * e * e * Pro)) /
                        (Pra * Prm * Pro);
            }

            private double LH12sV1(double s, Dictionary<int, double> fre, double[] alpha, GENOTYPE o, GENOTYPE a)
            {
                double T1oa = T1(fre, alpha, o, a);
                double T2oaa = T2(fre, alpha, o, a, a);
                double Pro = o.prior;
                double Pra = a.prior;
                double e = PARENTAGE_MISTYPE_RATE;
                return (Pra * ((1 - e) * (1 - e) * ((1 - s) * T1oa + s * T2oaa)
                               + 2 * e * (1 - e) * Pro
                               + e * e * Pro)) /
                       (Pra * Pro);
            }

            private double LH12sV1(double s, bool issame, Dictionary<int, double> fre, double[] alpha, GENOTYPE o, GENOTYPE a, GENOTYPE m)
            {
                if (issame)
                {
                    double T2oaa = T2(fre, alpha, o, a, a);
                    double T1oa = T1(fre, alpha, o, a);
                    double Pro = o.prior;
                    double Pra = a.prior;
                    double e = PARENTAGE_MISTYPE_RATE;
                    return (Pra * ((1 - e) * (1 - e) * T2oaa
                                   + 2 * e * (1 - e) * Pro
                                   + e * e * Pro)) /
                           (Pra * ((1 - e) * (1 - e) * T1oa
                                + 2 * e * (1 - e) * Pro
                                + e * e * Pro));
                }
                else
                {
                    double T2oam = T2(fre, alpha, o, a, m);
                    double T2omm = T2(fre, alpha, o, m, m);
                    double T1oa = T1(fre, alpha, o, a);
                    double T1om = T1(fre, alpha, o, m);
                    double Pro = o.prior;
                    double Pra = a.prior;
                    double Prm = m.prior;
                    double e = PARENTAGE_MISTYPE_RATE;
                    return (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T2oam
                                         + e * (1 - e) * (1 - e) * (T1oa + T1om + Pro)
                                         + 3 * e * e * (1 - e) * Pro
                                         + e * e * e * Pro)) /
                        (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * ((1 - s) * T1om + s * T2omm)
                                      + e * (1 - e) * (1 - e) * ((1 - s) * T1om + s * T2omm + 2 * Pro)
                                      + 3 * e * e * (1 - e) * Pro
                                      + e * e * e * Pro));
                }
            }

            private double LH12sV1(double s, bool issame, Dictionary<int, double> fre, double[] alpha, GENOTYPE o, GENOTYPE a, GENOTYPE m, GENOTYPE am)
            {
                if (issame)
                {
                    double T2oaa = T2(fre, alpha, o, a, a);
                    double T1oa = T1(fre, alpha, o, a);
                    double Pro = o.prior;
                    double Pra = a.prior;
                    double e = PARENTAGE_MISTYPE_RATE;
                    return parentage_correction ?
                        (Pra * ((1 - e) * (1 - e) * T2oaa
                                + 2 * e * (1 - e) * Pro
                                + e * e * Pro)) /
                            Math.Pow(Pra * Pro *
                                     Pra * ((1 - e) * (1 - e) * T1oa
                                   + 2 * e * (1 - e) * Pro
                                   + e * e * Pro) *
                                     Pra * ((1 - e) * (1 - e) * T1oa
                                   + 2 * e * (1 - e) * Pro
                                   + e * e * Pro), 1.0 / 3)
                            :
                            (Pra * ((1 - e) * (1 - e) * T2oaa
                                    + 2 * e * (1 - e) * Pro
                                    + e * e * Pro)) /
                            (Pra * Pro);

                }
                else
                {
                    double T2oam = T2(fre, alpha, o, a, m);
                    double T2oaa = T2(fre, alpha, o, a, a);
                    double T2omm = T2(fre, alpha, o, m, m);
                    double T1oa = T1(fre, alpha, o, a);
                    double T1om = T1(fre, alpha, o, m);
                    double Pro = o.prior;
                    double Pra = a.prior;
                    double Prm = m.prior;
                    double e = PARENTAGE_MISTYPE_RATE;
                    return parentage_correction ?
                        (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T2oam
                                      + e * (1 - e) * (1 - e) * (T1oa + T1om + Pro)
                                      + 3 * e * e * (1 - e) * Pro
                                      + e * e * e * Pro)) /
                            Math.Pow(Pra * Prm * Pro *
                                     Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * ((1 - s) * T1om + s * T2omm)
                                         + e * (1 - e) * (1 - e) * ((1 - s) * T1om + s * T2omm + 2 * Pro)
                                         + 3 * e * e * (1 - e) * Pro
                                         + e * e * e * Pro) *
                                     Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * ((1 - s) * T1oa + s * T2oaa)
                                         + e * (1 - e) * (1 - e) * ((1 - s) * T1oa + s * T2oaa + 2 * Pro)
                                         + 3 * e * e * (1 - e) * Pro
                                         + e * e * e * Pro), 1.0 / 3)
                            :
                            (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T2oam
                                          + e * (1 - e) * (1 - e) * (T1oa + T1om + Pro)
                                          + 3 * e * e * (1 - e) * Pro
                                          + e * e * e * Pro)) /
                            (Pra * Prm * Pro);
                }
            }

            private double LODV1(IND o, IND a, IND m, IND am)
            {
                double re = 0;
                double s = total_pop.loc[0].s;
                bool issame = a == m;

                for (int l = 0; l < L; ++l)
                {
                    if (o.g[l].hash == 0) continue;
                    if (a.g[l].hash == 0 && m.g[l].hash == 0) continue;
                    ulong key = a.g[l].hash > m.g[l].hash ?
                        ((ulong)o.g[l].hash << 32) ^ ((ulong)a.g[l].hash << 16) ^ (ulong)m.g[l].hash :
                        ((ulong)o.g[l].hash << 32) ^ ((ulong)m.g[l].hash << 16) ^ (ulong)a.g[l].hash;
                    key = issame ? key ^ 0x1234567812345678 : key;
                    double lod1 = 0;

                    if (!LOD4[l].ContainsKey(key))
                    {
                        if (CONSIDER_SELFING)
                        {
                            if (m.g[l].hash == 0)
                            {
                                foreach (GENOTYPE go in o.g[l].genotypes)
                                    foreach (GENOTYPE ga in a.g[l].genotypes)
                                        lod1 += LH12sV1(s, total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga) * (go.poster * ga.poster);
                            }
                            else if (a.g[l].hash == 0)
                            {
                                foreach (GENOTYPE go in o.g[l].genotypes)
                                    foreach (GENOTYPE gm in m.g[l].genotypes)
                                        lod1 += LH12sV1(s, total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, gm) * (go.poster * gm.poster);
                            }
                            else
                            {
                                if (issame)
                                    foreach (GENOTYPE go in o.g[l].genotypes)
                                        foreach (GENOTYPE ga in a.g[l].genotypes)
                                            lod1 += LH12sV1(s, issame, total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga, ga, ga) * (go.poster * ga.poster);
                                else
                                    foreach (GENOTYPE go in o.g[l].genotypes)
                                        foreach (GENOTYPE ga in a.g[l].genotypes)
                                            foreach (GENOTYPE gm in m.g[l].genotypes)
                                                lod1 += LH12sV1(s, issame, total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga, gm, gm) * (go.poster * ga.poster * gm.poster);
                            }
                        }
                        else
                        {
                            if (m.g[l].hash == 0)
                            {
                                foreach (GENOTYPE go in o.g[l].genotypes)
                                    foreach (GENOTYPE ga in a.g[l].genotypes)
                                        lod1 += LH12oV1(total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga) * (go.poster * ga.poster);
                            }
                            else if (a.g[l].hash == 0)
                            {
                                foreach (GENOTYPE go in o.g[l].genotypes)
                                    foreach (GENOTYPE gm in m.g[l].genotypes)
                                        lod1 += LH12oV1(total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, gm) * (go.poster * gm.poster);
                            }
                            else
                            {
                                if (issame)
                                    foreach (GENOTYPE go in o.g[l].genotypes)
                                        foreach (GENOTYPE ga in a.g[l].genotypes)
                                            lod1 += LH12oV1(total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga, ga, ga) * (go.poster * ga.poster);
                                else
                                    foreach (GENOTYPE go in o.g[l].genotypes)
                                        foreach (GENOTYPE ga in a.g[l].genotypes)
                                            foreach (GENOTYPE gm in m.g[l].genotypes)
                                                lod1 += LH12oV1(total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga, gm, gm) * (go.poster * ga.poster * gm.poster);
                            }
                        }
                        LOD4[l][key] = Math.Log(lod1);
                    }
                    re += LOD4[l][key];
                }
                return re;
            }

            private double LODV1(IND o, IND a, IND m)
            {
                if (m == null) return LODV1(o, a);
                double re = 0;
                double s = total_pop.loc[0].s;
                bool issame = a == m;

                for (int l = 0; l < L; ++l)
                {
                    if (o.g[l].hash == 0 || a.g[l].hash == 0) continue;
                    ulong key = ((ulong)o.g[l].hash << 32) ^ ((ulong)a.g[l].hash << 16) ^ (ulong)m.g[l].hash;
                    key = issame ? key ^ 0x1234567812345678 : key;

                    if (!LOD3[l].ContainsKey(key))
                    {
                        double lod1 = 0;

                        if (CONSIDER_SELFING)
                        {
                            if (m.g[l].hash == 0)
                            {
                                foreach (GENOTYPE go in o.g[l].genotypes)
                                    foreach (GENOTYPE ga in a.g[l].genotypes)
                                        lod1 += LH12sV1(s, total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga) * (go.poster * ga.poster);
                            }
                            else
                            {
                                if (issame)
                                    foreach (GENOTYPE go in o.g[l].genotypes)
                                        foreach (GENOTYPE ga in a.g[l].genotypes)
                                            lod1 += LH12sV1(s, issame, total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga, ga) * (go.poster * ga.poster);
                                else
                                    foreach (GENOTYPE go in o.g[l].genotypes)
                                        foreach (GENOTYPE ga in a.g[l].genotypes)
                                            foreach (GENOTYPE gm in m.g[l].genotypes)
                                                lod1 += LH12sV1(s, issame, total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga, gm) * (go.poster * ga.poster * gm.poster);
                            }
                        }
                        else
                        {
                            if (m.g[l].hash == 0)
                            {
                                foreach (GENOTYPE go in o.g[l].genotypes)
                                    foreach (GENOTYPE ga in a.g[l].genotypes)
                                        lod1 += LH12oV1(total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga) * (go.poster * ga.poster);
                            }
                            else
                            {
                                if (issame)
                                    foreach (GENOTYPE go in o.g[l].genotypes)
                                        foreach (GENOTYPE ga in a.g[l].genotypes)
                                            lod1 += LH12oV1(total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga, ga) * (go.poster * ga.poster);
                                else
                                    foreach (GENOTYPE go in o.g[l].genotypes)
                                        foreach (GENOTYPE ga in a.g[l].genotypes)
                                            foreach (GENOTYPE gm in m.g[l].genotypes)
                                                lod1 += LH12oV1(total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga, gm) * (go.poster * ga.poster * gm.poster);
                            }
                        }
                        LOD3[l][key] = Math.Log(lod1);
                    }
                    re += LOD3[l][key];
                }
                return re;
            }

            private double LODV1(IND o, IND a)
            {
                //Weight Genotype
                double re = 0;
                double s = total_pop.loc[0].s;

                for (int l = 0; l < L; ++l)
                {
                    if (o.g[l].hash == 0 || a.g[l].hash == 0) continue;
                    ulong key = ((ulong)o.g[l].hash << 32) ^ (ulong)a.g[l].hash;
                    if (!LOD2[l].ContainsKey(key))
                    {
                        double lod1 = 0;

                        if (CONSIDER_SELFING)
                        {
                            foreach (GENOTYPE go in o.g[l].genotypes)
                                foreach (GENOTYPE ga in a.g[l].genotypes)
                                    lod1 += LH12sV1(s, total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga) * (go.poster * ga.poster);
                        }
                        else
                        {
                            foreach (GENOTYPE go in o.g[l].genotypes)
                                foreach (GENOTYPE ga in a.g[l].genotypes)
                                    lod1 += LH12oV1(total_pop.loc[l].freq, ALPHA[l, o.ploidy], go, ga) * (go.poster * ga.poster);
                        }
                        LOD2[l][key] = Math.Log(lod1);
                    }
                    re += LOD2[l][key];
                }
                return re;
            }

            public double T1(int l, Dictionary<int, double> fre, double[] alpha, PHENOTYPE po, PHENOTYPE pa)
            {
                //from G to g
                ulong key = ((ulong)po.hash << 32) ^ ((ulong)pa.hash);
                if (!T2D[l].ContainsKey(key))
                {
                    double re = 0;
                    foreach (GENOTYPE a in pa.genotypes)
                    {
                        double ap = a.poster, re1 = 0;
                        foreach (GENOTYPE o in po.genotypes)
                            re1 += T1(fre, alpha, o, a);
                        re += re1 * ap; // * T(Po|Go)
                    }
                    T1D[l][key] = re * (1 - total_pop.loc[l].beta);
                }
                return T1D[l][key];
            }

            public double T2(int l, Dictionary<int, double> fre, double[] alpha, PHENOTYPE po, PHENOTYPE pa, PHENOTYPE pm)
            {
                //from G to g
                ulong key = ((ulong)po.hash << 32) ^ ((ulong)pa.hash << 16) ^ (ulong)pm.hash;
                if (!T2D[l].ContainsKey(key))
                {
                    double re = 0;
                    foreach (GENOTYPE a in pa.genotypes)
                        foreach (GENOTYPE m in pm.genotypes)
                        {
                            double ap = a.poster * m.poster, re1 = 0;
                            foreach (GENOTYPE o in po.genotypes)
                                re1 += T2(fre, alpha, o, a, m);
                            re += re1 * ap; // * T(Po|Go)
                        }
                    T2D[l][key] = re * (1 - total_pop.loc[l].beta);
                }
                return T2D[l][key];
            }

            private double LH12oV2(int l, Dictionary<int, double> fre, double[] alpha, PHENOTYPE o, PHENOTYPE a)
            {
                double T1oa = T1(l, fre, alpha, o, a);
                double Pro = o.prob;
                double Pra = a.prob;
                double e = PARENTAGE_MISTYPE_RATE;
                return (Pra * ((1 - e) * (1 - e) * T1oa
                               + 2 * e * (1 - e) * Pro
                               + e * e * Pro)) /
                    (Pra * Pro);

            }

            private double LH12oV2(int l, Dictionary<int, double> fre, double[] alpha, PHENOTYPE o, PHENOTYPE a, PHENOTYPE m)
            {
                double T2oam = T2(l, fre, alpha, o, a, m);
                double T1oa = T1(l, fre, alpha, o, a);
                double T1om = T1(l, fre, alpha, o, m);
                double Pro = o.prob;
                double Pra = a.prob;
                double Prm = m.prob;
                double e = PARENTAGE_MISTYPE_RATE;
                return (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T2oam
                                     + e * (1 - e) * (1 - e) * (T1oa + T1om + Pro)
                                     + 3 * e * e * (1 - e) * Pro
                                     + e * e * e * Pro)) /
                    (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T1om
                                  + e * (1 - e) * (1 - e) * (T1om + 2 * Pro)
                                  + 3 * e * e * (1 - e) * Pro
                                  + e * e * e * Pro));
            }

            private double LH12oV2(int l, Dictionary<int, double> fre, double[] alpha, PHENOTYPE o, PHENOTYPE a, PHENOTYPE m, PHENOTYPE am)
            {
                double T2oam = T2(l, fre, alpha, o, a, m);
                double T1oa = T1(l, fre, alpha, o, a);
                double T1om = T1(l, fre, alpha, o, m);
                double Pro = o.prob;
                double Pra = a.prob;
                double Prm = m.prob;
                double e = PARENTAGE_MISTYPE_RATE;
                return parentage_correction ?
                    (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T2oam
                                  + e * (1 - e) * (1 - e) * (T1oa + T1om + Pro)
                                  + 3 * e * e * (1 - e) * Pro
                                  + e * e * e * Pro)) /
                        Math.Pow(Pra * Prm * Pro *
                                 Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T1om
                                     + e * (1 - e) * (1 - e) * (T1om + 2 * Pro)
                                     + 3 * e * e * (1 - e) * Pro
                                     + e * e * e * Pro) *
                                 Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T1oa
                                     + e * (1 - e) * (1 - e) * (T1oa + 2 * Pro)
                                     + 3 * e * e * (1 - e) * Pro
                                     + e * e * e * Pro), 1.0 / 3)
                        :
                        (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T2oam
                                      + e * (1 - e) * (1 - e) * (T1oa + T1om + Pro)
                                      + 3 * e * e * (1 - e) * Pro
                                      + e * e * e * Pro)) /
                        (Pra * Prm * Pro);
            }

            private double LH12sV2(int l, double s, Dictionary<int, double> fre, double[] alpha, PHENOTYPE o, PHENOTYPE a)
            {
                double T1oa = T1(l, fre, alpha, o, a);
                double T2oaa = T2(l, fre, alpha, o, a, a);
                double Pro = o.prob;
                double Pra = a.prob;
                double e = PARENTAGE_MISTYPE_RATE;
                return (Pra * ((1 - e) * (1 - e) * ((1 - s) * T1oa + s * T2oaa)
                               + 2 * e * (1 - e) * Pro
                               + e * e * Pro)) /
                        (Pra * Pro);
            }

            private double LH12sV2(int l, double s, bool issame, Dictionary<int, double> fre, double[] alpha, PHENOTYPE o, PHENOTYPE a, PHENOTYPE m)
            {
                if (issame)
                {
                    double T2oaa = T2(l, fre, alpha, o, a, a);
                    double T1oa = T1(l, fre, alpha, o, a);
                    double Pro = o.prob;
                    double Pra = a.prob;
                    double e = PARENTAGE_MISTYPE_RATE;
                    return (Pra * ((1 - e) * (1 - e) * T2oaa
                                   + 2 * e * (1 - e) * Pro
                                   + e * e * Pro)) /
                        (Pra * ((1 - e) * (1 - e) * T1oa
                                + 2 * e * (1 - e) * Pro
                                + e * e * Pro));
                }
                else
                {
                    double T2oam = T2(l, fre, alpha, o, a, m);
                    double T2omm = T2(l, fre, alpha, o, m, m);
                    double T1oa = T1(l, fre, alpha, o, a);
                    double T1om = T1(l, fre, alpha, o, m);
                    double Pro = o.prob;
                    double Pra = a.prob;
                    double Prm = m.prob;
                    double e = PARENTAGE_MISTYPE_RATE;
                    return (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T2oam
                                         + e * (1 - e) * (1 - e) * (T1oa + T1om + Pro)
                                         + 3 * e * e * (1 - e) * Pro
                                         + e * e * e * Pro)) /
                        (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * ((1 - s) * T1om + s * T2omm)
                                      + e * (1 - e) * (1 - e) * ((1 - s) * T1om + s * T2omm + 2 * Pro)
                                      + 3 * e * e * (1 - e) * Pro
                                      + e * e * e * Pro));
                }
            }

            private double LH12sV2(int l, double s, bool issame, Dictionary<int, double> fre, double[] alpha, PHENOTYPE o, PHENOTYPE a, PHENOTYPE m, PHENOTYPE am)
            {
                if (issame)
                {
                    double T2oaa = T2(l, fre, alpha, o, a, a);
                    double T1oa = T1(l, fre, alpha, o, a);
                    double Pro = o.prob;
                    double Pra = a.prob;
                    double e = PARENTAGE_MISTYPE_RATE;
                    return parentage_correction ?
                        (Pra * ((1 - e) * (1 - e) * T2oaa
                                + 2 * e * (1 - e) * Pro
                                + e * e * Pro)) /
                            Math.Pow(Pra * Pro *
                                     Pra * ((1 - e) * (1 - e) * T1oa
                                   + 2 * e * (1 - e) * Pro
                                   + e * e * Pro) *
                                     Pra * ((1 - e) * (1 - e) * T1oa
                                   + 2 * e * (1 - e) * Pro
                                   + e * e * Pro), 1.0 / 3)
                            :
                            (Pra * ((1 - e) * (1 - e) * T2oaa
                                    + 2 * e * (1 - e) * Pro
                                    + e * e * Pro)) /
                            (Pra * Pro);
                }
                else
                {
                    double T2oam = T2(l, fre, alpha, o, a, m);
                    double T2oaa = T2(l, fre, alpha, o, a, a);
                    double T2omm = T2(l, fre, alpha, o, m, m);
                    double T1oa = T1(l, fre, alpha, o, a);
                    double T1om = T1(l, fre, alpha, o, m);
                    double Pro = o.prob;
                    double Pra = a.prob;
                    double Prm = m.prob;
                    double e = PARENTAGE_MISTYPE_RATE;
                    return parentage_correction ?
                        (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T2oam
                                      + e * (1 - e) * (1 - e) * (T1oa + T1om + Pro)
                                      + 3 * e * e * (1 - e) * Pro
                                      + e * e * e * Pro)) /
                            Math.Pow(Pra * Prm * Pro *
                                     Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * ((1 - s) * T1om + s * T2omm)
                                         + e * (1 - e) * (1 - e) * ((1 - s) * T1om + s * T2omm + 2 * Pro)
                                         + 3 * e * e * (1 - e) * Pro
                                         + e * e * e * Pro) *
                                     Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * ((1 - s) * T1oa + s * T2oaa)
                                         + e * (1 - e) * (1 - e) * ((1 - s) * T1oa + s * T2oaa + 2 * Pro)
                                         + 3 * e * e * (1 - e) * Pro
                                         + e * e * e * Pro), 1.0 / 3)
                            :
                            (Pra * Prm * ((1 - e) * (1 - e) * (1 - e) * T2oam
                                          + e * (1 - e) * (1 - e) * (T1oa + T1om + Pro)
                                          + 3 * e * e * (1 - e) * Pro
                                          + e * e * e * Pro)) /
                            (Pra * Prm * Pro);
                }
            }

            private double LODV2(IND o, IND a, IND m, IND am)
            {
                double re = 0;
                double s = total_pop.loc[0].s;
                bool issame = a == m;

                for (int l = 0; l < L; ++l)
                {
                    if (o.g[l].hash == 0) continue;
                    if (a.g[l].hash == 0 && m.g[l].hash == 0) continue;
                    ulong key = a.g[l].hash > m.g[l].hash ?
                        ((ulong)o.g[l].hash << 32) ^ ((ulong)a.g[l].hash << 16) ^ (ulong)m.g[l].hash :
                        ((ulong)o.g[l].hash << 32) ^ ((ulong)m.g[l].hash << 16) ^ (ulong)a.g[l].hash;
                    key = issame ? key ^ 0x1234567812345678 : key;
                    double lod1 = 0;

                    if (!LOD4[l].ContainsKey(key))
                    {
                        if (CONSIDER_SELFING)
                        {
                            if (m.g[l].hash == 0)
                                lod1 += LH12sV2(l, s, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l]);
                            else if (a.g[l].hash == 0)
                                lod1 += LH12sV2(l, s, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], m.g[l]);
                            else if (issame)
                                lod1 += LH12sV2(l, s, issame, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l], a.g[l], a.g[l]);
                            else
                                lod1 += LH12sV2(l, s, issame, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l], m.g[l], m.g[l]);
                        }
                        else
                        {
                            if (m.g[l].hash == 0)
                                lod1 += LH12oV2(l, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l]);
                            else if (a.g[l].hash == 0)
                                lod1 += LH12oV2(l, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], m.g[l]);
                            else if (issame)
                                lod1 += LH12oV2(l, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l], a.g[l], a.g[l]);
                            else
                                lod1 += LH12oV2(l, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l], m.g[l], m.g[l]);
                        }
                        LOD4[l][key] = Math.Log(lod1);
                    }
                    re += LOD4[l][key];
                }
                return re;
            }

            private double LODV2(IND o, IND a, IND m)
            {
                if (m == null) return LODV2(o, a);
                double re = 0;
                double s = total_pop.loc[0].s;
                bool issame = a == m;

                for (int l = 0; l < L; ++l)
                {
                    if (o.g[l].hash == 0 || a.g[l].hash == 0) continue;
                    ulong key = ((ulong)o.g[l].hash << 32) ^ ((ulong)a.g[l].hash << 16) ^ (ulong)m.g[l].hash;
                    key = issame ? key ^ 0x1234567812345678 : key;

                    if (!LOD3[l].ContainsKey(key))
                    {
                        double lod1 = 0;

                        if (CONSIDER_SELFING)
                        {
                            if (m.g[l].hash == 0)
                                lod1 += LH12sV2(l, s, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l]);
                            else if (issame)
                                lod1 += LH12sV2(l, s, issame, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l], a.g[l]);
                            else
                                lod1 += LH12sV2(l, s, issame, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l], m.g[l]);
                        }
                        else
                        {
                            if (m.g[l].hash == 0)
                                lod1 += LH12oV2(l, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l]);
                            else if (issame)
                                lod1 += LH12oV2(l, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l], a.g[l]);
                            else
                                lod1 += LH12oV2(l, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l], m.g[l]);
                        }
                        LOD3[l][key] = Math.Log(lod1);
                    }
                    re += LOD3[l][key];
                }
                return re;
            }

            private double LODV2(IND o, IND a)
            {
                //Phenotypic
                double re = 0;
                double s = total_pop.loc[0].s;

                for (int l = 0; l < L; ++l)
                {
                    if (o.g[l].hash == 0 || a.g[l].hash == 0) continue;
                    ulong key = ((ulong)o.g[l].hash << 32) ^ (ulong)a.g[l].hash;
                    if (!LOD2[l].ContainsKey(key))
                    {
                        double lod1 = 0;

                        if (CONSIDER_SELFING)
                            lod1 += LH12sV2(l, s, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l]);
                        else
                            lod1 += LH12oV2(l, total_pop.loc[l].freq, ALPHA[l, o.ploidy], o.g[l], a.g[l]);
                        LOD2[l][key] = Math.Log(lod1);
                    }
                    re += LOD2[l][key];
                }
                return re;
            }

            public Dictionary<int, double>[] freq_dominant = null;

            private double T2V4(double p, bool o, bool a, bool m)
            {
                //Gerber et al. 2000 Table 2
                double q = 1 - p;
                if (o && a && m)
                    return (p * p + 3 * q * q + 4 * p * q) / ((2 - p) * (2 - p));
                if (o && a && !m || o && !a && m)
                    return 1 / (2 - p);
                if (!o && a && m)
                    return q * q / ((2 - p) * (2 - p));
                if (!o && a && !m || !o && !a && m)
                    return q / (2 - p);
                if (!o && !a && !m)
                    return 1;
                return 0;
            }

            private double T1V4(double p, bool o, bool a)
            {
                //Gerber et al. 2000 Table 1
                double q = 1 - p;
                if (o && a)
                    return (p + (1 + p) * q) / (2 - p);
                if (o && !a)
                    return p;
                if (!o && a)
                    return q * q / (2 - p);
                if (!o && !a)
                    return q;
                return 0;
            }

            private double PrGV4(double p, bool o)
            {
                double q = 1 - p;
                return o ? 1 - q * q : q * q;
            }

            private double LH12V4(double p, bool o, bool a)
            {
                double T1oa = T1V4(p, o, a);
                double Pro = PrGV4(p, o);
                double Pra = PrGV4(p, a);
                double e = PARENTAGE_MISTYPE_RATE;
                return ((1 - e) * (1 - e) * T1oa * Pra
                            + e * (1 - e) * (Pra + Pro)
                            + e * e) /
                       ((1 - e) * (1 - e) * Pro * Pra
                            + e * (1 - e) * (Pra + Pro)
                            + e * e);
            }

            private double LH12V4(double p, bool o, bool a, bool m)
            {
                double T2oam = T2V4(p, o, a, m);
                double T1oa = T1V4(p, o, a);
                double T1om = T1V4(p, o, m);
                double Pro = PrGV4(p, o);
                double Pra = PrGV4(p, a);
                double Prm = PrGV4(p, m);
                double e = PARENTAGE_MISTYPE_RATE;
                return ((1 - e) * (1 - e) * (1 - e) * T2oam * Pra * Prm
                            + e * (1 - e) * (1 - e) * (T1oa * Pra + T1om * Prm + Pra * Prm)
                            + e * e * (1 - e) * (Pro + Pra + Prm)
                            + e * e * e) /
                       ((1 - e) * (1 - e) * (1 - e) * T1om * Pra * Prm
                            + e * (1 - e) * (1 - e) * (Pro * Pra + T1om * Prm + Pra * Prm)
                            + e * e * (1 - e) * (Pro + Pra + Prm)
                            + e * e * e);
            }

            private double LH12V4(double p, bool o, bool a, bool m, bool am)
            {
                double T2oam = T2V4(p, o, a, m);
                double T1oa = T1V4(p, o, a);
                double T1om = T1V4(p, o, m);
                double Pro = PrGV4(p, o);
                double Pra = PrGV4(p, a);
                double Prm = PrGV4(p, m);
                double e = PARENTAGE_MISTYPE_RATE;
                return ((1 - e) * (1 - e) * (1 - e) * T2oam * Pra * Prm
                            + e * (1 - e) * (1 - e) * (T1oa * Pra + T1om * Prm + Pra * Prm)
                            + e * e * (1 - e) * (Pro + Pra + Prm)
                            + e * e * e) /
                       ((1 - e) * (1 - e) * (1 - e) * Pro * Pra * Prm
                            + e * (1 - e) * (1 - e) * (Pro * Pra + Pro * Prm + Pra * Prm)
                            + e * e * (1 - e) * (Pro + Pra + Prm)
                            + e * e * e);
            }

            private double LODV4(IND o, IND a, IND m, IND am)
            {
                double re = 0;
                double s = total_pop.loc[0].s;
                bool issame = a == m;

                for (int l = 0; l < L; ++l)
                {
                    if (o.g[l].hash == 0) continue;
                    if (a.g[l].hash == 0 && m.g[l].hash == 0) continue;
                    ulong key = a.g[l].hash > m.g[l].hash ?
                        ((ulong)o.g[l].hash << 32) ^ ((ulong)a.g[l].hash << 16) ^ (ulong)m.g[l].hash :
                        ((ulong)o.g[l].hash << 32) ^ ((ulong)m.g[l].hash << 16) ^ (ulong)a.g[l].hash;
                    key = issame ? key ^ 0x1234567812345678 : key;
                    double lod1 = 0;

                    if (!LOD4[l].ContainsKey(key))
                    {
                        if (m.g[l].hash == 0)
                            foreach (int k in freq_dominant[l].Keys)
                                lod1 += LH12V4(freq_dominant[l][k], o.g[l].alleles.Contains(k), a.g[l].alleles.Contains(k));
                        else if (a.g[l].hash == 0)
                            foreach (int k in freq_dominant[l].Keys)
                                lod1 += LH12V4(freq_dominant[l][k], o.g[l].alleles.Contains(k), m.g[l].alleles.Contains(k));
                        else
                            foreach (int k in freq_dominant[l].Keys)
                                lod1 += LH12V4(freq_dominant[l][k], o.g[l].alleles.Contains(k), a.g[l].alleles.Contains(k), m.g[l].alleles.Contains(k), false);
                        LOD4[l][key] = Math.Log(lod1);
                    }
                    re += LOD4[l][key];
                }
                return re;
            }

            private double LODV4(IND o, IND a, IND m)
            {
                if (m == null) return LODV4(o, a);
                double re = 0;
                double s = total_pop.loc[0].s;
                bool issame = a == m;

                for (int l = 0; l < L; ++l)
                {
                    if (o.g[l].hash == 0 || a.g[l].hash == 0) continue;
                    ulong key = ((ulong)o.g[l].hash << 32) ^ ((ulong)a.g[l].hash << 16) ^ (ulong)m.g[l].hash;
                    key = issame ? key ^ 0x1234567812345678 : key;

                    if (!LOD3[l].ContainsKey(key))
                    {
                        double lod1 = 0;

                        if (m.g[l].hash == 0)
                            foreach (int k in freq_dominant[l].Keys)
                                lod1 += LH12V4(freq_dominant[l][k], o.g[l].alleles.Contains(k), a.g[l].alleles.Contains(k));
                        else
                            foreach (int k in freq_dominant[l].Keys)
                                lod1 += LH12V4(freq_dominant[l][k], o.g[l].alleles.Contains(k), a.g[l].alleles.Contains(k), m.g[l].alleles.Contains(k));

                        LOD3[l][key] = Math.Log(lod1);
                    }
                    re += LOD3[l][key];
                }
                return re;
            }

            private double LODV4(IND o, IND a)
            {
                //Phenotypic
                double re = 0;
                double s = total_pop.loc[0].s;

                for (int l = 0; l < L; ++l)
                {
                    if (o.g[l].hash == 0 || a.g[l].hash == 0) continue;
                    ulong key = ((ulong)o.g[l].hash << 32) ^ (ulong)a.g[l].hash;
                    if (!LOD2[l].ContainsKey(key))
                    {
                        double lod1 = 0;
                        foreach (int k in freq_dominant[l].Keys)
                            lod1 += LH12V4(freq_dominant[l][k], o.g[l].alleles.Contains(k), a.g[l].alleles.Contains(k));
                        LOD2[l][key] = Math.Log(lod1);
                    }
                    re += LOD2[l][key];
                }
                return re;
            }

            private double LODV3(IND o, IND a, IND m, IND am)
            {
                return -o.Mismatch(a, m);
            }

            private double LODV3(IND o, IND a, IND m)
            {
                if (m == null) return LODV3(o, a);
                return -o.Mismatch(a, m);
            }

            private double LODV3(IND o, IND a)
            {
                return -o.Mismatch(a);
            }

            private double LOD(IND o, IND a, IND m, IND am)
            {
                if (ISGENOTYPE) return LODV1(o, a, m, am);//OK
                switch (PARENTAGE_METHOD)
                {
                    case ParentageMethod.Geno: return LODV1(o, a, m, am);//Genotype
                    case ParentageMethod.Pheno: return LODV2(o, a, m, am);//Phenotype
                    case ParentageMethod.Exclusion: return LODV3(o, a, m, am);//Exclusion
                    case ParentageMethod.Dominant: return LODV4(o, a, m, am);//Dominant
                    default: return 0;
                }
            }

            private double LOD(IND o, IND a, IND m)
            {
                if (ISGENOTYPE) return LODV1(o, a, m);//OK
                switch (PARENTAGE_METHOD)
                {
                    case ParentageMethod.Geno: return LODV1(o, a, m);
                    case ParentageMethod.Pheno: return LODV2(o, a, m);
                    case ParentageMethod.Exclusion: return LODV3(o, a, m);
                    case ParentageMethod.Dominant: return LODV4(o, a, m);
                    default: return 0;
                }
            }

            private double LOD(IND o, IND a)
            {
                if (ISGENOTYPE) return LODV1(o, a);
                switch (PARENTAGE_METHOD)
                {
                    case ParentageMethod.Geno: return LODV1(o, a);
                    case ParentageMethod.Pheno: return LODV2(o, a);
                    case ParentageMethod.Exclusion: return LODV3(o, a);
                    case ParentageMethod.Dominant: return LODV4(o, a);
                    default: return 0;
                }
            }

            private void SimulatePaternityThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                int ploidy = (int)((object[])obj)[2];
                ParentageSimResultEntry[] res1 = (ParentageSimResultEntry[])((object[])obj)[3];
                ParentageSimResultEntry[] res2 = (ParentageSimResultEntry[])((object[])obj)[4];
                ParentageLodStructEntry lod1 = (ParentageLodStructEntry)((object[])obj)[5];
                ParentageLodStructEntry lod2 = (ParentageLodStructEntry)((object[])obj)[6];
                ParentageLodPercentileEntry dist1 = (ParentageLodPercentileEntry)((object[])obj)[7];
                ParentageLodPercentileEntry dist2 = (ParentageLodPercentileEntry)((object[])obj)[8];

                double s = total_pop.loc[0].s;
                double tin = (double)PARENTAGE_NSIM / N_THREAD;
                int nst = (int)(tin * id), ned = (int)(tin * (id + 1));
                double flod1 = -1e100, lodmax11 = -1e100, lodmax12 = -1e100, flod2 = -1e100, lodmax21 = -1e100, lodmax22 = -1e100;

                IND o = null, f1 = null, f2 = null, m = null, tf = null;
                for (int i = nst; i < ned; ++i)
                {
                    Random rnd = new Random(SEED ^ (i + 0x4E1E23F9));//bug fixed on 20220324

                    //APP1&2
                    flod2 = flod1 = lodmax21 = lodmax22 = lodmax11 = lodmax12 = -1e100;
                    double maxlod1 = -1e100, maxlod2 = -1e100;

                    //1. Generate father-offspring genotypes
                    bool isself = CONSIDER_SELFING && rnd.NextDouble() < s;
                    f2 = CreateInd(rnd, ploidy);
                    m = isself ? f2 : CreateInd(rnd, ploidy);
                    o = ReproduceSub(f2, m, rnd);

                    //2. Generate observed genotypes, FORMAT
                    GetObsPheno(rnd, f2, true);
                    if (isself) m = f2;
                    else GetObsPheno(rnd, m, true);
                    GetObsPheno(rnd, o, true);

                    //3. Calculate LOD for true parents
                    dist1.PushTrue(flod1 = LOD(o, f2), id);
                    dist2.PushTrue(flod2 = LOD(o, f2, m), id);
                    lod1.PushT(flod1);
                    lod2.PushT(flod2);

                    if (rnd.NextDouble() < PARENTAGE_SAMPLING_RATE)
                    {
                        //father sampled
                        f1 = f2;
                        lodmax11 = flod1;
                        lodmax21 = flod2;
                    }
                    else
                    {
                        //father not sampled in APP1 (mother unknown)
                        f1 = null;
                        flod1 = -1e100;

                        //father is the same as mother if selfing in APP2 (mother known)
                        if (isself)
                            lodmax21 = flod2;
                        else
                        {
                            f2 = null;
                            flod2 = -1e100;
                        }
                    }

                    //4. Calculate LOD for false parents
                    for (int j = 0; j < PARENTAGE_PATERNITY_NFATHER - 1; ++j)
                    {
                        tf = CreateInd(rnd, ploidy);
                        GetObsPheno(rnd, tf, false);

                        double tlod1 = LOD(o, tf); maxlod1 = Math.Max(maxlod1, tlod1);
                        if (tlod1 >= lodmax11)
                        {
                            lodmax12 = lodmax11;
                            lodmax11 = tlod1;
                        }
                        else if (tlod1 >= lodmax12)
                            lodmax12 = tlod1;

                        double tlod2 = LOD(o, tf, m); maxlod2 = Math.Max(maxlod2, tlod2);
                        if (tlod2 >= lodmax21)
                        {
                            lodmax22 = lodmax21;
                            lodmax21 = tlod2;
                        }
                        else if (tlod2 >= lodmax22)
                            lodmax22 = tlod2;

                        dist1.PushFalse(tlod1, id);
                        dist2.PushFalse(tlod2, id);
                        lod1.PushF(tlod1);
                        lod2.PushF(tlod2);
                    }
                    dist1.PushFalseMax(maxlod1, id);
                    dist2.PushFalseMax(maxlod2, id);

                    //3. Calculate Delta
                    double d1 = 0, d2 = 0;

                    d1 = lodmax11 - lodmax12;
                    res1[i] = (new ParentageSimResultEntry(
                        (f1 != null && flod1 == lodmax11 && d1 > 0) ? ParentageSimResult.S1_Success :
                        ((f1 != null) ? ParentageSimResult.S1_Fail_ParentSampled :
                     (d1 > 0 ? ParentageSimResult.S1_Fail_ParentUnsampled : ParentageSimResult.S1_Fail_None))
                        , d1));

                    d2 = lodmax21 - lodmax22;
                    res2[i] = (new ParentageSimResultEntry(
                        (f2 != null && flod2 == lodmax21 && d2 > 0) ? ParentageSimResult.S2_Success :
                        ((f2 != null) ? ParentageSimResult.S2_Fail_ParentSampled :
                     (d2 > 0 ? ParentageSimResult.S2_Fail_ParentUnsampled : ParentageSimResult.S2_Fail_None))
                        , d2));
                    Increment();
                }
            }

            private void SimulateParentPairThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                int ploidy = (int)((object[])obj)[2];
                ParentageSimResultEntry[] res3 = (ParentageSimResultEntry[])((object[])obj)[3];
                ParentageSimResultEntry[] res3f = (ParentageSimResultEntry[])((object[])obj)[4];
                ParentageSimResultEntry[] res3m = (ParentageSimResultEntry[])((object[])obj)[5];
                ParentageLodStructEntry lod3 = (ParentageLodStructEntry)((object[])obj)[6];
                ParentageLodStructEntry lod3f = (ParentageLodStructEntry)((object[])obj)[7];
                ParentageLodStructEntry lod3m = (ParentageLodStructEntry)((object[])obj)[8];
                ParentageLodPercentileEntry dist3 = (ParentageLodPercentileEntry)((object[])obj)[9];
                ParentageLodPercentileEntry dist3f = (ParentageLodPercentileEntry)((object[])obj)[10];
                ParentageLodPercentileEntry dist3m = (ParentageLodPercentileEntry)((object[])obj)[11];

                double s = total_pop.loc[0].s;

                double tin = (double)PARENTAGE_NSIM / N_THREAD;
                int nst = (int)(tin * id), ned = (int)(tin * (id + 1));

                IND o = null, f = null, m = null, tf = null, tm = null;

                double floda = -1e100, lodmaxa1 = -1e100, lodmaxa2 = -1e100;
                double flodb = -1e100, lodmaxb1 = -1e100, lodmaxb2 = -1e100;
                double flodc = -1e100, lodmaxc1 = -1e100, lodmaxc2 = -1e100;

                double da = 0, db = 0, dc = 0;
                for (int i = nst; i < ned; ++i)
                {
                    //APP3
                    Random rnd = new Random(SEED ^ (i + 0x4C975347));//bug fixed on 20220324
                    List<IND> ppm = new List<IND>(), ppf = new List<IND>();

                    floda = lodmaxa1 = lodmaxa2 = flodb = lodmaxb1 = lodmaxb2 = flodc = lodmaxc1 = lodmaxc2 = -1e100;
                    double maxlod = -1e100, maxlodf = -1e100, maxlodm = -1e100;

                    //1. Generate Father-Offspring Genotypes
                    bool isself = CONSIDER_SELFING && rnd.NextDouble() < s;

                    f = CreateInd(rnd, ploidy);
                    m = isself ? f : CreateInd(rnd, ploidy);
                    o = ReproduceSub(f, m, rnd);

                    GetObsPheno(rnd, f, true);
                    if (isself) m = f;
                    else GetObsPheno(rnd, m, true);
                    GetObsPheno(rnd, o, true);

                    dist3.PushTrue(floda = LOD(o, f, m, m), id);
                    dist3f.PushTrue(flodb = LOD(o, f), id);
                    dist3m.PushTrue(flodc = LOD(o, m), id);
                    lod3.PushT(floda);
                    lod3f.PushT(flodb);
                    lod3m.PushT(flodc);

                    if (rnd.NextDouble() > PARENTAGE_SAMPLING_RATE) f = null;

                    if (isself) m = f;
                    else if (rnd.NextDouble() > PARENTAGE_SAMPLING_RATE) m = null;

                    if (f != null && m != null) lodmaxa1 = floda;
                    else floda = -1e100;

                    //2. Insert Candidate Father Genotypes
                    if (f != null)
                    {
                        ppf.Add(f);
                        lodmaxb1 = flodb;
                    }
                    else flodb = -1e100;

                    for (int k = 0; k < PARENTAGE_PARENTPAIR_NFATHER - 1; ++k)
                    {
                        tf = CreateInd(rnd, ploidy);
                        GetObsPheno(rnd, tf, false);
                        ppf.Add(tf);

                        double tlodb = LOD(o, tf); 
                        maxlodf = Math.Max(maxlodf, tlodb); 
                        dist3f.PushFalse(tlodb, id);
                        lod3f.PushF(tlodb);

                        if (tlodb >= lodmaxb1)
                        {
                            lodmaxb2 = lodmaxb1;
                            lodmaxb1 = tlodb;
                        }
                        else if (tlodb >= lodmaxb2)
                            lodmaxb2 = tlodb;
                    }

                    if (m != null)
                    {
                        ppm.Add(m);
                        lodmaxc1 = flodc;
                    }
                    else flodc = -1e100;

                    for (int j = 0; j < PARENTAGE_PARENTPAIR_NMOTHER - 1; ++j)
                    {
                        tm = CreateInd(rnd, ploidy);
                        GetObsPheno(rnd, tm, false);
                        ppm.Add(tm);

                        double tlodc = LOD(o, tm); 
                        maxlodm = Math.Max(maxlodm, tlodc); 
                        dist3m.PushFalse(tlodc, id);
                        lod3m.PushF(tlodc);

                        if (tlodc >= lodmaxc1)
                        {
                            lodmaxc2 = lodmaxc1;
                            lodmaxc1 = tlodc;
                        }
                        else if (tlodc >= lodmaxc2)
                            lodmaxc2 = tlodc;
                    }

                    foreach (IND tf2 in ppf)
                    {
                        foreach (IND tm2 in ppm)
                        {
                            if (tf2 == f && tm2 == m) continue;
                            double tlod = LOD(o, tf2, tm2, tm2); 
                            dist3.PushFalse(tlod, id);
                            if (tf2 == f || tm2 == m) lod3.PushA(tlod);
                            else lod3.PushF(tlod);

                            maxlod = Math.Max(maxlod, tlod);
                            if (tlod >= lodmaxa1)
                            {
                                lodmaxa2 = lodmaxa1;
                                lodmaxa1 = tlod;
                            }
                            else if (tlod >= lodmaxa2)
                                lodmaxa2 = tlod;
                        }
                    }
                    dist3.PushFalseMax(maxlod, id);
                    dist3f.PushFalseMax(maxlodf, id);
                    dist3m.PushFalseMax(maxlodm, id);

                    //3. Calculate Delta
                    da = lodmaxa1 - lodmaxa2;
                    res3[i] = (new ParentageSimResultEntry(
                        (f != null && m != null && floda == lodmaxa1 && da > 0) ? ParentageSimResult.S3_Success :
                        ((f != null && m != null) ? ParentageSimResult.S3_Fail_PairSampled :
                     ((f != null && m == null) ? ParentageSimResult.S3_Fail_FatherUnsampled :
                     ((f == null && m != null) ? ParentageSimResult.S3_Fail_MotherUnsampled :
                     (da > 0 ? ParentageSimResult.S3_Fail_PairUnsampled : ParentageSimResult.S3_Fail_None))))
                        , da));

                    db = lodmaxb1 - lodmaxb2;
                    res3f[i] = (new ParentageSimResultEntry(
                        (f != null && flodb == lodmaxb1 && db > 0) ? ParentageSimResult.S3_Success :
                        (f != null ? ParentageSimResult.S3_Fail_PairSampled :
                     (db > 0 ? ParentageSimResult.S3_Fail_PairUnsampled : ParentageSimResult.S3_Fail_None))
                        , db));

                    dc = lodmaxc1 - lodmaxc2;
                    res3m[i] = (new ParentageSimResultEntry(
                        (m != null && flodc == lodmaxc1 && dc > 0) ? ParentageSimResult.S3_Success :
                        (m != null ? ParentageSimResult.S3_Fail_PairSampled :
                     (dc > 0 ? ParentageSimResult.S3_Fail_PairUnsampled : ParentageSimResult.S3_Fail_None))
                        , dc));

                    Increment();
                }
            }

            private void SimulateUnknownThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                int ploidy = (int)((object[])obj)[2];
                ParentageSimResultEntry[] res4 = (ParentageSimResultEntry[])((object[])obj)[3];
                ParentageLodStructEntry lod4 = (ParentageLodStructEntry)((object[])obj)[4];
                ParentageLodPercentileEntry dist4 = (ParentageLodPercentileEntry)((object[])obj)[5];

                double s = total_pop.loc[0].s;

                double tin = (double)PARENTAGE_NSIM / N_THREAD;
                int nst = (int)(tin * id), ned = (int)(tin * (id + 1));

                IND o = null, f = null, m = null, tf = null;

                double floda = -1e100, lodmaxa1 = -1e100, lodmaxa2 = -1e100, da = 0;
                int count = 0;
                for (int i = nst; i < ned; ++i)
                {
                    Random rnd = new Random(SEED ^ (i + 0x517F336));//bug fixed on 20220324

                    floda = -1e100;
                    lodmaxa1 = lodmaxa2 = -1e100;
                    double maxlod = -1e100;

                    List<IND> tps = new List<IND>();

                    //1. Generate Father-Offspring Genotypes
                    bool isself = CONSIDER_SELFING && rnd.NextDouble() < s;

                    f = CreateInd(rnd, ploidy);
                    m = isself ? f : CreateInd(rnd, ploidy);
                    o = ReproduceSub(f, m, rnd);

                    GetObsPheno(rnd, f, true);
                    if (isself) m = f;
                    else GetObsPheno(rnd, m, true);
                    GetObsPheno(rnd, o, true);
                    dist4.PushTrue(floda = LOD(o, f, m, m), id);
                    lod4.PushT(floda);

                    if (rnd.NextDouble() > PARENTAGE_SAMPLING_RATE) f = null;
                    else tps.Add(f);

                    if (isself) m = f;
                    else if (rnd.NextDouble() > PARENTAGE_SAMPLING_RATE) m = null;
                    if (m != null) tps.Add(m);

                    if (f != null && m != null) lodmaxa1 = floda;
                    else floda = -1e100;

                    //2. Insert Candidate Parent Genotypes
                    for (int j = 0; j < PARENTAGE_UNKNOWN_NCANDIDATE - 2; ++j)
                    {
                        tf = CreateInd(rnd, ploidy);
                        GetObsPheno(rnd, tf, false);
                        tps.Add(tf);
                    }

                    for (int j = 0; j < tps.Count; ++j)
                        for (int k = j + 1; k < tps.Count; ++k)
                        {
                            if (tps[j] == f && tps[k] == m) continue;
                            double tlod = LOD(o, tps[j], tps[k], tps[k]); 
                            maxlod = Math.Max(maxlod, tlod); 
                            dist4.PushFalse(tlod, id);
                            if (tps[j] == f || tps[k] == m) lod4.PushA(tlod);
                            else lod4.PushF(tlod);
                            if (tlod >= lodmaxa1)
                            {
                                lodmaxa2 = lodmaxa1;
                                lodmaxa1 = tlod;
                            }
                            else if (tlod >= lodmaxa2)
                                lodmaxa2 = tlod;
                        }
                    dist4.PushFalseMax(maxlod, id);

                    //3. Calculate Delta
                    da = lodmaxa1 - lodmaxa2;
                    res4[i] = (new ParentageSimResultEntry(
                         (f != null && m != null && floda == lodmaxa1 && da > 0) ? ParentageSimResult.S4_Success :
                         ((f != null && m != null) ? ParentageSimResult.S4_Fail_PairSampled :
                         ((f != null || m != null) ? ParentageSimResult.S4_Fail_OneSampled :
                         (da > 0 ? ParentageSimResult.S4_Fail_PairUnsampled : ParentageSimResult.S4_Fail_None)))
                        , da));

                    Increment();
                    count++;
                }
            }

            private void SimulateEnd(
                ParentageSimResultEntry[] res1, ParentageSimResultEntry[] res2, ParentageSimResultEntry[] res3, ParentageSimResultEntry[] res3f, ParentageSimResultEntry[] res3m, ParentageSimResultEntry[] res4,
                ParentageLodStructEntry lod1, ParentageLodStructEntry lod2, ParentageLodStructEntry lod3, ParentageLodStructEntry lod3f, ParentageLodStructEntry lod3m, ParentageLodStructEntry lod4,
                ParentageLodPercentileEntry dist1, ParentageLodPercentileEntry dist2, ParentageLodPercentileEntry dist3, ParentageLodPercentileEntry dist3f, ParentageLodPercentileEntry dist3m, ParentageLodPercentileEntry dist4)
            {
                StreamWriter wt = new StreamWriter(new FileStream("o_parentage_simulation.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_PARENTAGE_SIMULATION = wt;

                wt.WriteLine("Tab 1: Summary statistics\r\n	Confidence (%)	Critical Delta	Assignments	Assignment Rate");

                if (PARENTAGE_PATERNITY)
                {
                    d1_999 = d1_99 = d1_95 = d1_80 = d2_999 = d2_99 = d2_95 = d2_80 = -1;
                    res1 = res1.OrderByDescending(r => r.delta).ToArray();
                    res2 = res2.OrderByDescending(r => r.delta).ToArray();
                    dist1.Summary();
                    dist2.Summary();
                    lod1.Summary();
                    lod2.Summary();
                }

                if (PARENTAGE_PARENTPAIR)
                {
                    dP_999 = dP_99 = dP_95 = dP_80 = dPF_999 = dPF_99 = dPF_95 = dPF_80 = dPM_999 = dPM_99 = dPM_95 = dPM_80 = -1;
                    res3 = res3.OrderByDescending(r => r.delta).ToArray();
                    res3f = res3f.OrderByDescending(r => r.delta).ToArray();
                    res3m = res3m.OrderByDescending(r => r.delta).ToArray();
                    dist3.Summary();
                    dist3f.Summary();
                    dist3m.Summary();
                    lod3.Summary();
                    lod3f.Summary();
                    lod3m.Summary();
                }

                if (PARENTAGE_UNKNOWN)
                {
                    dPU_999 = dPU_99 = dPU_95 = dPU_80 = -1;
                    res4 = res4.OrderByDescending(r => r.delta).ToArray();
                    dist4.Summary();
                    lod4.Summary();
                }

                int ncorrect = 0, n80 = 0, n95 = 0, n99 = 0, n999 = 0;

                if (PARENTAGE_PATERNITY)
                {
                    ncorrect = res1.Count(r => r.state == ParentageSimResult.S1_Success);
                    n80 = n95 = n99 = n999 = 0;

                    for (int i = res1.Length - 1; i >= 0; --i)
                    {
                        if (res1[i].state == ParentageSimResult.S1_Success)
                            ncorrect--;

                        if (d1_80 == -1 && ncorrect * 1.0 / i > 0.80)
                        {
                            n80 = i + 1;
                            d1_80 = res1[i].delta;
                        }

                        if (d1_95 == -1 && ncorrect * 1.0 / i > 0.95)
                        {
                            n95 = i + 1;
                            d1_95 = res1[i].delta;
                        }

                        if (d1_99 == -1 && ncorrect * 1.0 / i > 0.99)
                        {
                            n99 = i + 1;
                            d1_99 = res1[i].delta;
                        }

                        if (d1_999 == -1 && ncorrect * 1.0 / i > 0.999)
                        {
                            n999 = i + 1;
                            d1_999 = res1[i].delta;
                        }
                    }

                    d1_999 = d1_999 == -1 ? 999 : d1_999;
                    d1_99 = d1_99 == -1 ? 999 : d1_99;
                    d1_95 = d1_95 == -1 ? 999 : d1_95;
                    d1_80 = d1_80 == -1 ? 999 : d1_80;

                    d1_999 = Math.Max(0, d1_999);
                    d1_99 = Math.Max(0, d1_99);
                    d1_95 = Math.Max(0, d1_95);
                    d1_80 = Math.Max(0, d1_80);
                    d1_999 = Math.Min(999, d1_999);
                    d1_99 = Math.Min(999, d1_99);
                    d1_95 = Math.Min(999, d1_95);
                    d1_80 = Math.Min(999, d1_80);

                    wt.WriteLine("Paternity, father alone");
                    ncorrect = res1.Count(r => r.state == ParentageSimResult.S1_Success);
                    if (ncorrect / (double)res1.Length > 0.95 || d1_999 == 999 || d1_999 == 0 || d1_80 == 999 || d1_80 == 0)
                    {
                        lod1.Paternity(PARENTAGE_PATERNITY_NFATHER, ref d1_80, ref d1_95, ref d1_99, ref d1_999);
                        n80 = res1.Count(r => r.delta > d1_80);
                        n95 = res1.Count(r => r.delta > d1_95);
                        n99 = res1.Count(r => r.delta > d1_99);
                        n999 = res1.Count(r => r.delta > d1_999);
                        wt.WriteLine("Thresholds of Delta are obtained by an alternative method.");
                    }

                    SetDecimal(form1.D1_999, d1_999);
                    SetDecimal(form1.D1_99, d1_99);
                    SetDecimal(form1.D1_95, d1_95);
                    SetDecimal(form1.D1_80, d1_80);

                    wt.WriteLine(string.Format("\t99.9%\t{0}\t{1}\t{2:0.0}%", d1_999.ToString(DECIMAL), n999, n999 * 100.0 / res1.Length));
                    wt.WriteLine(string.Format("\t99%\t{0}\t{1}\t{2:0.0}%", d1_99.ToString(DECIMAL), n99, n99 * 100.0 / res1.Length));
                    wt.WriteLine(string.Format("\t95%\t{0}\t{1}\t{2:0.0}%", d1_95.ToString(DECIMAL), n95, n95 * 100.0 / res1.Length));
                    wt.WriteLine(string.Format("\t80%\t{0}\t{1}\t{2:0.0}%", d1_80.ToString(DECIMAL), n80, n80 * 100.0 / res1.Length));
                    wt.WriteLine(string.Format("\tUnassigned\t\t{0}\t{1:0.0}%", res1.Length - n80, (res1.Length - n80) * 100.0 / res1.Length));
                    wt.WriteLine(string.Format("\tTotal\t\t{0}\t100%", res1.Length));

                    //APP2
                    ncorrect = res2.Count(r => r.state == ParentageSimResult.S2_Success);
                    n80 = n95 = n99 = n999 = 0;

                    for (int i = res2.Length - 1; i >= 0; --i)
                    {
                        if (res2[i].state == ParentageSimResult.S2_Success)
                            ncorrect--;

                        if (d2_80 == -1 && ncorrect * 1.0 / i > 0.80)
                        {
                            n80 = i + 1;
                            d2_80 = res2[i].delta;
                        }

                        if (d2_95 == -1 && ncorrect * 1.0 / i > 0.95)
                        {
                            n95 = i + 1;
                            d2_95 = res2[i].delta;
                        }

                        if (d2_99 == -1 && ncorrect * 1.0 / i > 0.99)
                        {
                            n99 = i + 1;
                            d2_99 = res2[i].delta;
                        }

                        if (d2_999 == -1 && ncorrect * 1.0 / i > 0.999)
                        {
                            n999 = i + 1;
                            d2_999 = res2[i].delta;
                        }
                    }

                    d2_999 = d2_999 == -1 ? 999 : d2_999;
                    d2_99 = d2_99 == -1 ? 999 : d2_99;
                    d2_95 = d2_95 == -1 ? 999 : d2_95;
                    d2_80 = d2_80 == -1 ? 999 : d2_80;

                    d2_999 = Math.Max(0, d2_999);
                    d2_99 = Math.Max(0, d2_99);
                    d2_95 = Math.Max(0, d2_95);
                    d2_80 = Math.Max(0, d2_80);
                    d2_999 = Math.Min(999, d2_999);
                    d2_99 = Math.Min(999, d2_99);
                    d2_95 = Math.Min(999, d2_95);
                    d2_80 = Math.Min(999, d2_80);

                    wt.WriteLine("Paternity, father given known mother");
                    ncorrect = res2.Count(r => r.state == ParentageSimResult.S2_Success);
                    if (ncorrect / (double)res2.Length > 0.95 || d2_999 == 999 || d2_999 == 0 || d2_80 == 999 || d2_80 == 0)
                    {
                        lod2.Paternity(PARENTAGE_PATERNITY_NFATHER, ref d2_80, ref d2_95, ref d2_99, ref d2_999);
                        n80 = res2.Count(r => r.delta > d2_80);
                        n95 = res2.Count(r => r.delta > d2_95);
                        n99 = res2.Count(r => r.delta > d2_99);
                        n999 = res2.Count(r => r.delta > d2_999);
                        wt.WriteLine("Thresholds of Delta are obtained by an alternative method.");
                    }

                    SetDecimal(form1.D2_999, d2_999);
                    SetDecimal(form1.D2_99, d2_99);
                    SetDecimal(form1.D2_95, d2_95);
                    SetDecimal(form1.D2_80, d2_80);

                    wt.WriteLine(string.Format("\t99.9%\t{0}\t{1}\t{2:0.0}%", d2_999.ToString(DECIMAL), n999, n999 * 100.0 / res2.Length));
                    wt.WriteLine(string.Format("\t99%\t{0}\t{1}\t{2:0.0}%", d2_99.ToString(DECIMAL), n99, n99 * 100.0 / res2.Length));
                    wt.WriteLine(string.Format("\t95%\t{0}\t{1}\t{2:0.0}%", d2_95.ToString(DECIMAL), n95, n95 * 100.0 / res2.Length));
                    wt.WriteLine(string.Format("\t80%\t{0}\t{1}\t{2:0.0}%", d2_80.ToString(DECIMAL), n80, n80 * 100.0 / res2.Length));
                    wt.WriteLine(string.Format("\tUnassigned\t\t{0}\t{1:0.0}%", res2.Length - n80, (res2.Length - n80) * 100.0 / res2.Length));
                    wt.WriteLine(string.Format("\tTotal\t\t{0}\t100%", res2.Length));
                }

                if (PARENTAGE_PARENTPAIR)
                {
                    //APP3F
                    ncorrect = res3f.Count(r => r.state == ParentageSimResult.S3_Success);
                    n80 = n95 = n99 = n999 = 0;

                    for (int i = res3f.Length - 1; i >= 0; --i)
                    {
                        if (res3f[i].state == ParentageSimResult.S3_Success)
                            ncorrect--;

                        if (dPF_80 == -1 && ncorrect * 1.0 / i > 0.80)
                        {
                            n80 = i + 1;
                            dPF_80 = res3f[i].delta;
                        }

                        if (dPF_95 == -1 && ncorrect * 1.0 / i > 0.95)
                        {
                            n95 = i + 1;
                            dPF_95 = res3f[i].delta;
                        }

                        if (dPF_99 == -1 && ncorrect * 1.0 / i > 0.99)
                        {
                            n99 = i + 1;
                            dPF_99 = res3f[i].delta;
                        }

                        if (dPF_999 == -1 && ncorrect * 1.0 / i > 0.999)
                        {
                            n999 = i + 1;
                            dPF_999 = res3f[i].delta;
                        }
                    }

                    dPF_999 = dPF_999 == -1 ? 999 : dPF_999;
                    dPF_99 = dPF_99 == -1 ? 999 : dPF_99;
                    dPF_95 = dPF_95 == -1 ? 999 : dPF_95;
                    dPF_80 = dPF_80 == -1 ? 999 : dPF_80;

                    dPF_999 = Math.Max(0, dPF_999);
                    dPF_99 = Math.Max(0, dPF_99);
                    dPF_95 = Math.Max(0, dPF_95);
                    dPF_80 = Math.Max(0, dPF_80);
                    dPF_999 = Math.Min(999, dPF_999);
                    dPF_99 = Math.Min(999, dPF_99);
                    dPF_95 = Math.Min(999, dPF_95);
                    dPF_80 = Math.Min(999, dPF_80);

                    wt.WriteLine("Parent pair (sexes known), father alone");
                    ncorrect = res3f.Count(r => r.state == ParentageSimResult.S3_Success);
                    if (ncorrect / (double)res3f.Length > 0.95 || dPF_999 == 999 || dPF_999 == 0 || dPF_80 == 999 || dPF_80 == 0)
                    {
                        lod3f.Paternity(PARENTAGE_PARENTPAIR_NFATHER, ref dPF_80, ref dPF_95, ref dPF_99, ref dPF_999);
                        n80 = res3f.Count(r => r.delta > dPF_80);
                        n95 = res3f.Count(r => r.delta > dPF_95);
                        n99 = res3f.Count(r => r.delta > dPF_99);
                        n999 = res3f.Count(r => r.delta > dPF_999);
                        wt.WriteLine("Thresholds of Delta are obtained by an alternative method.");
                    }

                    SetDecimal(form1.DPF_999, dPF_999);
                    SetDecimal(form1.DPF_99, dPF_99);
                    SetDecimal(form1.DPF_95, dPF_95);
                    SetDecimal(form1.DPF_80, dPF_80);

                    wt.WriteLine(string.Format("\t99.9%\t{0}\t{1}\t{2:0.0}%", dPF_999.ToString(DECIMAL), n999, n999 * 100.0 / res3f.Length));
                    wt.WriteLine(string.Format("\t99%\t{0}\t{1}\t{2:0.0}%", dPF_99.ToString(DECIMAL), n99, n99 * 100.0 / res3f.Length));
                    wt.WriteLine(string.Format("\t95%\t{0}\t{1}\t{2:0.0}%", dPF_95.ToString(DECIMAL), n95, n95 * 100.0 / res3f.Length));
                    wt.WriteLine(string.Format("\t80%\t{0}\t{1}\t{2:0.0}%", dPF_80.ToString(DECIMAL), n80, n80 * 100.0 / res3f.Length));
                    wt.WriteLine(string.Format("\tUnassigned\t\t{0}\t{1:0.0}%", res3f.Length - n80, (res3f.Length - n80) * 100.0 / res3f.Length));
                    wt.WriteLine(string.Format("\tTotal\t\t{0}\t100%", res3f.Length));


                    //APP3m
                    ncorrect = res3m.Count(r => r.state == ParentageSimResult.S3_Success);
                    n80 = n95 = n99 = n999 = 0;

                    for (int i = res3m.Length - 1; i >= 0; --i)
                    {
                        if (res3m[i].state == ParentageSimResult.S3_Success)
                            ncorrect--;

                        if (dPM_80 == -1 && ncorrect * 1.0 / i > 0.80)
                        {
                            n80 = i + 1;
                            dPM_80 = res3m[i].delta;
                        }

                        if (dPM_95 == -1 && ncorrect * 1.0 / i > 0.95)
                        {
                            n95 = i + 1;
                            dPM_95 = res3m[i].delta;
                        }

                        if (dPM_99 == -1 && ncorrect * 1.0 / i > 0.99)
                        {
                            n99 = i + 1;
                            dPM_99 = res3m[i].delta;
                        }

                        if (dPM_999 == -1 && ncorrect * 1.0 / i > 0.999)
                        {
                            n999 = i + 1;
                            dPM_999 = res3m[i].delta;
                        }
                    }

                    dPM_999 = dPM_999 == -1 ? 999 : dPM_999;
                    dPM_99 = dPM_99 == -1 ? 999 : dPM_99;
                    dPM_95 = dPM_95 == -1 ? 999 : dPM_95;
                    dPM_80 = dPM_80 == -1 ? 999 : dPM_80;

                    dPM_999 = Math.Max(0, dPM_999);
                    dPM_99 = Math.Max(0, dPM_99);
                    dPM_95 = Math.Max(0, dPM_95);
                    dPM_80 = Math.Max(0, dPM_80);
                    dPM_999 = Math.Min(999, dPM_999);
                    dPM_99 = Math.Min(999, dPM_99);
                    dPM_95 = Math.Min(999, dPM_95);
                    dPM_80 = Math.Min(999, dPM_80);

                    wt.WriteLine("Parent pair (sexes known), mother alone");
                    ncorrect = res3m.Count(r => r.state == ParentageSimResult.S3_Success);
                    if (ncorrect / (double)res3m.Length > 0.95 || dPM_999 == 999 || dPM_999 == 0 || dPM_80 == 999 || dPM_80 == 0)
                    {
                        lod3m.Paternity(PARENTAGE_PARENTPAIR_NMOTHER, ref dPM_80, ref dPM_95, ref dPM_99, ref dPM_999);
                        n80 = res3m.Count(r => r.delta > dPM_80);
                        n95 = res3m.Count(r => r.delta > dPM_95);
                        n99 = res3m.Count(r => r.delta > dPM_99);
                        n999 = res3m.Count(r => r.delta > dPM_999);
                        wt.WriteLine("Thresholds of Delta are obtained by an alternative method.");
                    }

                    SetDecimal(form1.DPM_999, dPM_999);
                    SetDecimal(form1.DPM_99, dPM_99);
                    SetDecimal(form1.DPM_95, dPM_95);
                    SetDecimal(form1.DPM_80, dPM_80);

                    wt.WriteLine(string.Format("\t99.9%\t{0}\t{1}\t{2:0.0}%", dPM_999.ToString(DECIMAL), n999, n999 * 100.0 / res3m.Length));
                    wt.WriteLine(string.Format("\t99%\t{0}\t{1}\t{2:0.0}%", dPM_99.ToString(DECIMAL), n99, n99 * 100.0 / res3m.Length));
                    wt.WriteLine(string.Format("\t95%\t{0}\t{1}\t{2:0.0}%", dPM_95.ToString(DECIMAL), n95, n95 * 100.0 / res3m.Length));
                    wt.WriteLine(string.Format("\t80%\t{0}\t{1}\t{2:0.0}%", dPM_80.ToString(DECIMAL), n80, n80 * 100.0 / res3m.Length));
                    wt.WriteLine(string.Format("\tUnassigned\t\t{0}\t{1:0.0}%", res3m.Length - n80, (res3m.Length - n80) * 100.0 / res3m.Length));
                    wt.WriteLine(string.Format("\tTotal\t\t{0}\t100%", res3m.Length));


                    //APP3
                    ncorrect = res3.Count(r => r.state == ParentageSimResult.S3_Success);
                    n80 = n95 = n99 = n999 = 0;

                    for (int i = res3.Length - 1; i >= 0; --i)
                    {
                        if (res3[i].state == ParentageSimResult.S3_Success)
                            ncorrect--;

                        if (dP_80 == -1 && ncorrect * 1.0 / i > 0.80)
                        {
                            n80 = i + 1;
                            dP_80 = res3[i].delta;
                        }

                        if (dP_95 == -1 && ncorrect * 1.0 / i > 0.95)
                        {
                            n95 = i + 1;
                            dP_95 = res3[i].delta;
                        }

                        if (dP_99 == -1 && ncorrect * 1.0 / i > 0.99)
                        {
                            n99 = i + 1;
                            dP_99 = res3[i].delta;
                        }

                        if (dP_999 == -1 && ncorrect * 1.0 / i > 0.999)
                        {
                            n999 = i + 1;
                            dP_999 = res3[i].delta;
                        }
                    }

                    dP_999 = dP_999 == -1 ? 999 : dP_999;
                    dP_99 = dP_99 == -1 ? 999 : dP_99;
                    dP_95 = dP_95 == -1 ? 999 : dP_95;
                    dP_80 = dP_80 == -1 ? 999 : dP_80;

                    dP_999 = Math.Max(0, dP_999);
                    dP_99 = Math.Max(0, dP_99);
                    dP_95 = Math.Max(0, dP_95);
                    dP_80 = Math.Max(0, dP_80);
                    dP_999 = Math.Min(999, dP_999);
                    dP_99 = Math.Min(999, dP_99);
                    dP_95 = Math.Min(999, dP_95);
                    dP_80 = Math.Min(999, dP_80);

                    wt.WriteLine("Parent pair (sexes known)");
                    ncorrect = res3.Count(r => r.state == ParentageSimResult.S3_Success);
                    if (ncorrect / (double)res3.Length > 0.95 || dP_999 == 999 || dP_999 == 0 || dP_80 == 999 || dP_80 == 0)
                    {
                        lod3.ParentPair(PARENTAGE_PARENTPAIR_NFATHER, PARENTAGE_PARENTPAIR_NMOTHER, ref dP_80, ref dP_95, ref dP_99, ref dP_999);
                        n80 = res3.Count(r => r.delta > dP_80);
                        n95 = res3.Count(r => r.delta > dP_95);
                        n99 = res3.Count(r => r.delta > dP_99);
                        n999 = res3.Count(r => r.delta > dP_999);
                        wt.WriteLine("Thresholds of Delta are obtained by an alternative method.");
                    }

                    SetDecimal(form1.DP_999, dP_999);
                    SetDecimal(form1.DP_99, dP_99);
                    SetDecimal(form1.DP_95, dP_95);
                    SetDecimal(form1.DP_80, dP_80);

                    wt.WriteLine(string.Format("\t99.9%\t{0}\t{1}\t{2:0.0}%", dP_999.ToString(DECIMAL), n999, n999 * 100.0 / res3.Length));
                    wt.WriteLine(string.Format("\t99%\t{0}\t{1}\t{2:0.0}%", dP_99.ToString(DECIMAL), n99, n99 * 100.0 / res3.Length));
                    wt.WriteLine(string.Format("\t95%\t{0}\t{1}\t{2:0.0}%", dP_95.ToString(DECIMAL), n95, n95 * 100.0 / res3.Length));
                    wt.WriteLine(string.Format("\t80%\t{0}\t{1}\t{2:0.0}%", dP_80.ToString(DECIMAL), n80, n80 * 100.0 / res3.Length));
                    wt.WriteLine(string.Format("\tUnassigned\t\t{0}\t{1:0.0}%", res3.Length - n80, (res3.Length - n80) * 100.0 / res3.Length));
                    wt.WriteLine(string.Format("\tTotal\t\t{0}\t100%", res3.Length));
                }

                if (PARENTAGE_UNKNOWN)
                {
                    ncorrect = res4.Count(r => r.state == ParentageSimResult.S4_Success);
                    n80 = n95 = n99 = n999 = 0;

                    for (int i = res4.Length - 1; i >= 0; --i)
                    {
                        if (res4[i].state == ParentageSimResult.S4_Success)
                            ncorrect--;

                        if (dPU_80 == -1 && ncorrect * 1.0 / i > 0.80)
                        {
                            n80 = i + 1;
                            dPU_80 = res4[i].delta;
                        }

                        if (dPU_95 == -1 && ncorrect * 1.0 / i > 0.95)
                        {
                            n95 = i + 1;
                            dPU_95 = res4[i].delta;
                        }

                        if (dPU_99 == -1 && ncorrect * 1.0 / i > 0.99)
                        {
                            n99 = i + 1;
                            dPU_99 = res4[i].delta;
                        }

                        if (dPU_999 == -1 && ncorrect * 1.0 / i > 0.999)
                        {
                            n999 = i + 1;
                            dPU_999 = res4[i].delta;
                        }
                    }

                    dPU_999 = dPU_999 == -1 ? 999 : dPU_999;
                    dPU_99 = dPU_99 == -1 ? 999 : dPU_99;
                    dPU_95 = dPU_95 == -1 ? 999 : dPU_95;
                    dPU_80 = dPU_80 == -1 ? 999 : dPU_80;

                    dPU_999 = Math.Max(0, dPU_999);
                    dPU_99 = Math.Max(0, dPU_99);
                    dPU_95 = Math.Max(0, dPU_95);
                    dPU_80 = Math.Max(0, dPU_80);
                    dPU_999 = Math.Min(999, dPU_999);
                    dPU_99 = Math.Min(999, dPU_99);
                    dPU_95 = Math.Min(999, dPU_95);
                    dPU_80 = Math.Min(999, dPU_80);

                    wt.WriteLine("Parent pair (sexes unknown)");
                    ncorrect = res4.Count(r => r.state == ParentageSimResult.S4_Success);
                    if (ncorrect / (double)res4.Length > 0.95 || dPU_999 == 999 || dPU_999 == 0 || dPU_80 == 999 || dPU_80 == 0)
                    {
                        lod4.Unknown(PARENTAGE_UNKNOWN_NCANDIDATE, ref dPU_80, ref dPU_95, ref dPU_99, ref dPU_999);
                        n80 = res4.Count(r => r.delta > dPU_80);
                        n95 = res4.Count(r => r.delta > dPU_95);
                        n99 = res4.Count(r => r.delta > dPU_99);
                        n999 = res4.Count(r => r.delta > dPU_999);
                        wt.WriteLine("Thresholds of Delta are obtained by an alternative method.");
                    }

                    SetDecimal(form1.DPU_999, dPU_999);
                    SetDecimal(form1.DPU_99, dPU_99);
                    SetDecimal(form1.DPU_95, dPU_95);
                    SetDecimal(form1.DPU_80, dPU_80);

                    wt.WriteLine(string.Format("\t99.9%\t{0}\t{1}\t{2:0.0}%", dPU_999.ToString(DECIMAL), n999, n999 * 100.0 / res4.Length));
                    wt.WriteLine(string.Format("\t99%\t{0}\t{1}\t{2:0.0}%", dPU_99.ToString(DECIMAL), n99, n99 * 100.0 / res4.Length));
                    wt.WriteLine(string.Format("\t95%\t{0}\t{1}\t{2:0.0}%", dPU_95.ToString(DECIMAL), n95, n95 * 100.0 / res4.Length));
                    wt.WriteLine(string.Format("\t80%\t{0}\t{1}\t{2:0.0}%", dPU_80.ToString(DECIMAL), n80, n80 * 100.0 / res4.Length));
                    wt.WriteLine(string.Format("\tUnassigned\t\t{0}\t{1:0.0}%", res4.Length - n80, (res4.Length - n80) * 100.0 / res4.Length));
                    wt.WriteLine(string.Format("\tTotal\t\t{0}\t100%", res4.Length));
                }

                wt.WriteLine("\r\nTab 2: Delta distributions");
                wt.WriteLine("\tIdentity of most likely candidate	N	Mean Delta	Standard Deviation");

                if (PARENTAGE_PATERNITY)
                {
                    wt.WriteLine("Paternity, father alone");
                    wt.WriteLine("\tTrue father\t" + Statistics(ParentageSimResult.S1_Success, res1));
                    wt.WriteLine("\tNon-father (true father sampled)\t" + Statistics(ParentageSimResult.S1_Fail_ParentSampled, res1));
                    wt.WriteLine("\tNon-father (true father unsampled)\t" + Statistics(ParentageSimResult.S1_Fail_ParentUnsampled, res1));
                    wt.WriteLine("\tNone\t" + Statistics(ParentageSimResult.S1_Fail_None, res1, false));
                    wt.WriteLine("\tTotal\t" + res1.Length);

                    wt.WriteLine("Paternity, father given known mother");
                    wt.WriteLine("\tTrue father\t" + Statistics(ParentageSimResult.S2_Success, res2));
                    wt.WriteLine("\tNon-father (true father sampled)\t" + Statistics(ParentageSimResult.S2_Fail_ParentSampled, res2));
                    wt.WriteLine("\tNon-father (true father unsampled)\t" + Statistics(ParentageSimResult.S2_Fail_ParentUnsampled, res2));
                    wt.WriteLine("\tNone\t" + Statistics(ParentageSimResult.S2_Fail_None, res2, false));
                    wt.WriteLine("\tTotal\t" + res2.Length);
                }

                if (PARENTAGE_PARENTPAIR)
                {
                    wt.WriteLine("Parent pair (sexes known), mother alone");
                    wt.WriteLine("\tTrue mother\t" + Statistics(ParentageSimResult.S3_Success, res3m));
                    wt.WriteLine("\tNon-mother (true mother sampled)\t" + Statistics(ParentageSimResult.S3_Fail_PairSampled, res3m));
                    wt.WriteLine("\tNon-mother (true mother unsampled)\t" + Statistics(ParentageSimResult.S3_Fail_PairUnsampled, res3m));
                    wt.WriteLine("\tNone\t" + Statistics(ParentageSimResult.S3_Fail_None, res3m, false));
                    wt.WriteLine("\tTotal\t" + res3m.Length);

                    wt.WriteLine("Parent pair (sexes known), father alone");
                    wt.WriteLine("\tTrue father\t" + Statistics(ParentageSimResult.S3_Success, res3f));
                    wt.WriteLine("\tNon-father (true father sampled)\t" + Statistics(ParentageSimResult.S3_Fail_PairSampled, res3f));
                    wt.WriteLine("\tNon-father (true father unsampled)\t" + Statistics(ParentageSimResult.S3_Fail_PairUnsampled, res3f));
                    wt.WriteLine("\tNone\t" + Statistics(ParentageSimResult.S3_Fail_None, res3f, false));
                    wt.WriteLine("\tTotal\t" + res3f.Length);

                    wt.WriteLine("Parent pair (sexes known)");
                    wt.WriteLine("\tTrue parent pair \t" + Statistics(ParentageSimResult.S3_Success, res3));
                    wt.WriteLine("\tNon-parent pair (true parent pair sampled)\t" + Statistics(ParentageSimResult.S3_Fail_PairSampled, res3));
                    wt.WriteLine("\tNon-parent pair (true mother unsampled)\t" + Statistics(ParentageSimResult.S3_Fail_MotherUnsampled, res3));
                    wt.WriteLine("\tNon-parent pair (true father unsampled)\t" + Statistics(ParentageSimResult.S3_Fail_FatherUnsampled, res3));
                    wt.WriteLine("\tNon-parent pair (neither true parent sampled)\t" + Statistics(ParentageSimResult.S3_Fail_PairUnsampled, res3));
                    wt.WriteLine("\tNone\t" + Statistics(ParentageSimResult.S3_Fail_None, res3, false));
                    wt.WriteLine("\tTotal\t" + res3.Length);
                }

                if (PARENTAGE_UNKNOWN)
                {
                    wt.WriteLine("Parent pair (sexes unknown)");
                    wt.WriteLine("\tTrue parent pair \t" + Statistics(ParentageSimResult.S4_Success, res4));
                    wt.WriteLine("\tNon-parent pair (true parent pair sampled)\t" + Statistics(ParentageSimResult.S4_Fail_PairSampled, res4));
                    wt.WriteLine("\tNon-parent pair (one true parent sampled)\t" + Statistics(ParentageSimResult.S4_Fail_OneSampled, res4));
                    wt.WriteLine("\tNon-parent pair (neither true parent sampled)\t" + Statistics(ParentageSimResult.S4_Fail_PairUnsampled, res4));
                    wt.WriteLine("\tNone\t" + Statistics(ParentageSimResult.S4_Fail_None, res4, false));
                    wt.WriteLine("\tTotal\t" + res4.Length);
                }

                wt.WriteLine("\r\nTab 3: Breakdown of parentage assignments\r\n\t\tConfidence level\t\t\t\t\tNone");
                wt.WriteLine("\tIdentity of most likely candidate	99.9%	99%	95%	80%\tMost likely");

                if (PARENTAGE_PATERNITY)
                {
                    wt.WriteLine("Paternity, father alone");
                    wt.WriteLine("\tTrue father\t" + Statistics2(ParentageSimResult.S1_Success, res1, d1_999, d1_99, d1_95, d1_80));
                    wt.WriteLine("\tNon-father (true father sampled)\t" + Statistics2(ParentageSimResult.S1_Fail_ParentSampled, res1, d1_999, d1_99, d1_95, d1_80));
                    wt.WriteLine("\tNon-father (true father unsampled)\t" + Statistics2(ParentageSimResult.S1_Fail_ParentUnsampled, res1, d1_999, d1_99, d1_95, d1_80));
                    wt.WriteLine("\tTotal\t" + Statistics2(ParentageSimResult.S1_Fail_None, res1, d1_999, d1_99, d1_95, d1_80, false));

                    wt.WriteLine("Paternity, father given known mother");
                    wt.WriteLine("\tTrue father\t" + Statistics2(ParentageSimResult.S2_Success, res2, d2_999, d2_99, d2_95, d2_80));
                    wt.WriteLine("\tNon-father (true father sampled)\t" + Statistics2(ParentageSimResult.S2_Fail_ParentSampled, res2, d2_999, d2_99, d2_95, d2_80));
                    wt.WriteLine("\tNon-father (true father unsampled)\t" + Statistics2(ParentageSimResult.S2_Fail_ParentUnsampled, res2, d2_999, d2_99, d2_95, d2_80));
                    wt.WriteLine("\tTotal\t" + Statistics2(ParentageSimResult.S2_Fail_None, res2, d2_999, d2_99, d2_95, d2_80, false));
                }

                if (PARENTAGE_PARENTPAIR)
                {
                    wt.WriteLine("Parent pair (sexes known), mother alone");
                    wt.WriteLine("\tTrue mother\t" + Statistics2(ParentageSimResult.S3_Success, res3m, dPM_999, dPM_99, dPM_95, dPM_80));
                    wt.WriteLine("\tNon-mother (true mother sampled)\t" + Statistics2(ParentageSimResult.S3_Fail_PairSampled, res3m, dPM_999, dPM_99, dPM_95, dPM_80));
                    wt.WriteLine("\tNon-mother (true mother unsampled)\t" + Statistics2(ParentageSimResult.S3_Fail_PairUnsampled, res3m, dPM_999, dPM_99, dPM_95, dPM_80));
                    wt.WriteLine("\tTotal\t" + Statistics2(ParentageSimResult.S3_Fail_None, res3m, dPM_999, dPM_99, dPM_95, dPM_80, false));

                    wt.WriteLine("Parent pair (sexes known), father alone");
                    wt.WriteLine("\tTrue father\t" + Statistics2(ParentageSimResult.S3_Success, res3f, dPF_999, dPF_99, dPF_95, dPF_80));
                    wt.WriteLine("\tNon-father (true father sampled)\t" + Statistics2(ParentageSimResult.S3_Fail_PairSampled, res3f, dPF_999, dPF_99, dPF_95, dPF_80));
                    wt.WriteLine("\tNon-father (true father unsampled)\t" + Statistics2(ParentageSimResult.S3_Fail_PairUnsampled, res3f, dPF_999, dPF_99, dPF_95, dPF_80));
                    wt.WriteLine("\tTotal\t" + Statistics2(ParentageSimResult.S3_Fail_None, res3f, dPF_999, dPF_99, dPF_95, dPF_80, false));

                    wt.WriteLine("Parent pair (sexes known)");
                    wt.WriteLine("\tTrue parent pair \t" + Statistics2(ParentageSimResult.S3_Success, res3, dP_999, dP_99, dP_95, dP_80));
                    wt.WriteLine("\tNon-parent pair (true parent pair sampled)\t" + Statistics2(ParentageSimResult.S3_Fail_PairSampled, res3, dP_999, dP_99, dP_95, dP_80));
                    wt.WriteLine("\tNon-parent pair (true mother unsampled)\t" + Statistics2(ParentageSimResult.S3_Fail_MotherUnsampled, res3, dP_999, dP_99, dP_95, dP_80));
                    wt.WriteLine("\tNon-parent pair (true father unsampled)\t" + Statistics2(ParentageSimResult.S3_Fail_FatherUnsampled, res3, dP_999, dP_99, dP_95, dP_80));
                    wt.WriteLine("\tNon-parent pair (neither true parent sampled)\t" + Statistics2(ParentageSimResult.S3_Fail_PairUnsampled, res3, dP_999, dP_99, dP_95, dP_80));
                    wt.WriteLine("\tTotal\t" + Statistics2(ParentageSimResult.S3_Fail_None, res3, dP_999, dP_99, dP_95, dP_80, false));
                }

                if (PARENTAGE_UNKNOWN)
                {
                    wt.WriteLine("Parent pair (sexes unknown)");
                    wt.WriteLine("\tTrue parent pair \t" + Statistics2(ParentageSimResult.S4_Success, res4, dPU_999, dPU_99, dPU_95, dPU_80));
                    wt.WriteLine("\tNon-parent pair (true parent pair sampled)\t" + Statistics2(ParentageSimResult.S4_Fail_PairSampled, res4, dPU_999, dPU_99, dPU_95, dPU_80));
                    wt.WriteLine("\tNon-parent pair (one true parent sampled)\t" + Statistics2(ParentageSimResult.S4_Fail_OneSampled, res4, dPU_999, dPU_99, dPU_95, dPU_80));
                    wt.WriteLine("\tNon-parent pair (neither true parent sampled)\t" + Statistics2(ParentageSimResult.S4_Fail_PairUnsampled, res4, dPU_999, dPU_99, dPU_95, dPU_80));
                    wt.WriteLine("\tTotal\t" + Statistics2(ParentageSimResult.S4_Fail_None, res4, dPU_999, dPU_99, dPU_95, dPU_80, false));
                }

                wt.WriteLine("\r\nTab 4: LOD distributions");
                wt.WriteLine("\t\tn\tMean LOD\tStandard Deviation");

                if (PARENTAGE_PATERNITY)
                {
                    wt.WriteLine("Paternity, father alone");
                    wt.WriteLine(string.Format("\tTrue father\t{0}\t{1}\t{2}", dist1.nT[0], dist1.T[0].ToString(DECIMAL), Math.Sqrt(dist1.T2[0]).ToString(DECIMAL)));
                    wt.WriteLine(string.Format("\tFalse fathers\t{0}\t{1}\t{2}", dist1.nF[0], dist1.F[0].ToString(DECIMAL), Math.Sqrt(dist1.F2[0]).ToString(DECIMAL)));
                    wt.WriteLine(string.Format("\tMax LOD of false fathers\t{0}\t{1}\t{2}", dist1.nFm[0], dist1.Fm[0].ToString(DECIMAL), Math.Sqrt(dist1.Fm2[0]).ToString(DECIMAL)));

                    wt.WriteLine("Paternity, father given known mother");
                    wt.WriteLine(string.Format("\tTrue father\t{0}\t{1}\t{2}", dist2.nT[0], dist2.T[0].ToString(DECIMAL), Math.Sqrt(dist2.T2[0]).ToString(DECIMAL)));
                    wt.WriteLine(string.Format("\tFalse fathers\t{0}\t{1}\t{2}", dist2.nF[0], dist2.F[0].ToString(DECIMAL), Math.Sqrt(dist2.F2[0]).ToString(DECIMAL)));
                    wt.WriteLine(string.Format("\tMax LOD of false fathers\t{0}\t{1}\t{2}", dist2.nFm[0], dist2.Fm[0].ToString(DECIMAL), Math.Sqrt(dist2.Fm2[0]).ToString(DECIMAL)));
                }

                if (PARENTAGE_PARENTPAIR)
                {
                    wt.WriteLine("Parent pair (sexes known), mother alone");
                    wt.WriteLine(string.Format("\tTrue mother\t{0}\t{1}\t{2}", dist3m.nT[0], dist3m.T[0].ToString(DECIMAL), Math.Sqrt(dist3m.T2[0]).ToString(DECIMAL)));
                    wt.WriteLine(string.Format("\tFalse mothers\t{0}\t{1}\t{2}", dist3m.nF[0], dist3m.F[0].ToString(DECIMAL), Math.Sqrt(dist3m.F2[0]).ToString(DECIMAL)));
                    wt.WriteLine(string.Format("\tMax LOD of false mothers\t{0}\t{1}\t{2}", dist3m.nFm[0], dist3m.Fm[0].ToString(DECIMAL), Math.Sqrt(dist3m.Fm2[0]).ToString(DECIMAL)));

                    wt.WriteLine("Parent pair (sexes known), father alone");
                    wt.WriteLine(string.Format("\tTrue father\t{0}\t{1}\t{2}", dist3f.nT[0], dist3f.T[0].ToString(DECIMAL), Math.Sqrt(dist3f.T2[0]).ToString(DECIMAL)));
                    wt.WriteLine(string.Format("\tFalse fathers\t{0}\t{1}\t{2}", dist3f.nF[0], dist3f.F[0].ToString(DECIMAL), Math.Sqrt(dist3f.F2[0]).ToString(DECIMAL)));
                    wt.WriteLine(string.Format("\tMax LOD of false fathers\t{0}\t{1}\t{2}", dist3f.nFm[0], dist3f.Fm[0].ToString(DECIMAL), Math.Sqrt(dist3f.Fm2[0]).ToString(DECIMAL)));

                    wt.WriteLine("Parent pair (sexes known)");
                    wt.WriteLine(string.Format("\tTrue parent pair\t{0}\t{1}\t{2}", dist3.nT[0], dist3.T[0].ToString(DECIMAL), Math.Sqrt(dist3.T2[0]).ToString(DECIMAL)));
                    wt.WriteLine(string.Format("\tFalse parent pairs\t{0}\t{1}\t{2}", dist3.nF[0], dist3.F[0].ToString(DECIMAL), Math.Sqrt(dist3.F2[0]).ToString(DECIMAL)));
                    wt.WriteLine(string.Format("\tMax LOD of false parent pairs\t{0}\t{1}\t{2}", dist3.nFm[0], dist3.Fm[0].ToString(DECIMAL), Math.Sqrt(dist3.Fm2[0]).ToString(DECIMAL)));
                }

                if (PARENTAGE_UNKNOWN)
                {
                    wt.WriteLine("Parent pair (sexes unknown)");
                    wt.WriteLine(string.Format("\tTrue parent pair\t{0}\t{1}\t{2}", dist4.nT[0], dist4.T[0].ToString(DECIMAL), Math.Sqrt(dist4.T2[0]).ToString(DECIMAL)));
                    wt.WriteLine(string.Format("\tFalse parent pairs\t{0}\t{1}\t{2}", dist4.nF[0], dist4.F[0].ToString(DECIMAL), Math.Sqrt(dist4.F2[0]).ToString(DECIMAL)));
                    wt.WriteLine(string.Format("\tMax LOD of false parent pairs\t{0}\t{1}\t{2}", dist4.nFm[0], dist4.Fm[0].ToString(DECIMAL), Math.Sqrt(dist4.Fm2[0]).ToString(DECIMAL)));
                }

                wt.WriteLine("\r\nTab 5: Assignment rates");
                wt.WriteLine("\t\t\tConfidence");
                wt.WriteLine("\t\tn\t99.9%\t99%\t95%\t80%");

                double n5 = 0;

                if (PARENTAGE_PATERNITY)
                {
                    wt.WriteLine("Paternity, father alone");
                    n5 = res1.Count(r => r.state == ParentageSimResult.S1_Success || r.state == ParentageSimResult.S1_Fail_ParentSampled);
                    wt.WriteLine(string.Format("\tTrue father sampled\t{0}\t{1}\t{2}\t{3}\t{4}", n5,
                        (res1.Count(r => (r.state == ParentageSimResult.S1_Success || r.state == ParentageSimResult.S1_Fail_ParentSampled) && r.delta > d1_999) / n5).ToString(DECIMAL),
                        (res1.Count(r => (r.state == ParentageSimResult.S1_Success || r.state == ParentageSimResult.S1_Fail_ParentSampled) && r.delta > d1_99) / n5).ToString(DECIMAL),
                        (res1.Count(r => (r.state == ParentageSimResult.S1_Success || r.state == ParentageSimResult.S1_Fail_ParentSampled) && r.delta > d1_95) / n5).ToString(DECIMAL),
                        (res1.Count(r => (r.state == ParentageSimResult.S1_Success || r.state == ParentageSimResult.S1_Fail_ParentSampled) && r.delta > d1_80) / n5).ToString(DECIMAL)
                    ));

                    n5 = res1.Count(r => r.state == ParentageSimResult.S1_Fail_ParentUnsampled);
                    wt.WriteLine(string.Format("\tTrue father unsampled\t{0}\t{1}\t{2}\t{3}\t{4}", n5,
                        (res1.Count(r => r.state == ParentageSimResult.S1_Fail_ParentUnsampled && r.delta > d1_999) / n5).ToString(DECIMAL),
                        (res1.Count(r => r.state == ParentageSimResult.S1_Fail_ParentUnsampled && r.delta > d1_99) / n5).ToString(DECIMAL),
                        (res1.Count(r => r.state == ParentageSimResult.S1_Fail_ParentUnsampled && r.delta > d1_95) / n5).ToString(DECIMAL),
                        (res1.Count(r => r.state == ParentageSimResult.S1_Fail_ParentUnsampled && r.delta > d1_80) / n5).ToString(DECIMAL)
                    ));

                    wt.WriteLine("Paternity, father given known mother");
                    n5 = res2.Count(r => r.state == ParentageSimResult.S2_Success || r.state == ParentageSimResult.S2_Fail_ParentSampled);
                    wt.WriteLine(string.Format("\tTrue father sampled\t{0}\t{1}\t{2}\t{3}\t{4}", n5,
                        (res2.Count(r => (r.state == ParentageSimResult.S2_Success || r.state == ParentageSimResult.S2_Fail_ParentSampled) && r.delta > d2_999) / n5).ToString(DECIMAL),
                        (res2.Count(r => (r.state == ParentageSimResult.S2_Success || r.state == ParentageSimResult.S2_Fail_ParentSampled) && r.delta > d2_99) / n5).ToString(DECIMAL),
                        (res2.Count(r => (r.state == ParentageSimResult.S2_Success || r.state == ParentageSimResult.S2_Fail_ParentSampled) && r.delta > d2_95) / n5).ToString(DECIMAL),
                        (res2.Count(r => (r.state == ParentageSimResult.S2_Success || r.state == ParentageSimResult.S2_Fail_ParentSampled) && r.delta > d2_80) / n5).ToString(DECIMAL)
                    ));

                    n5 = res2.Count(r => r.state == ParentageSimResult.S2_Fail_ParentUnsampled);
                    wt.WriteLine(string.Format("\tTrue father unsampled\t{0}\t{1}\t{2}\t{3}\t{4}", n5,
                        (res2.Count(r => r.state == ParentageSimResult.S2_Fail_ParentUnsampled && r.delta > d2_999) / n5).ToString(DECIMAL),
                        (res2.Count(r => r.state == ParentageSimResult.S2_Fail_ParentUnsampled && r.delta > d2_99) / n5).ToString(DECIMAL),
                        (res2.Count(r => r.state == ParentageSimResult.S2_Fail_ParentUnsampled && r.delta > d2_95) / n5).ToString(DECIMAL),
                        (res2.Count(r => r.state == ParentageSimResult.S2_Fail_ParentUnsampled && r.delta > d2_80) / n5).ToString(DECIMAL)
                    ));
                }

                if (PARENTAGE_PARENTPAIR)
                {
                    wt.WriteLine("Parent pair (sexes known), mother alone");
                    n5 = res3m.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled));
                    wt.WriteLine(string.Format("\tTrue mother sampled\t{0}\t{1}\t{2}\t{3}\t{4}", n5,
                        (res3m.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled) && r.delta > dPM_999) / n5).ToString(DECIMAL),
                        (res3m.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled) && r.delta > dPM_99) / n5).ToString(DECIMAL),
                        (res3m.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled) && r.delta > dPM_95) / n5).ToString(DECIMAL),
                        (res3m.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled) && r.delta > dPM_80) / n5).ToString(DECIMAL)
                    ));

                    n5 = res3m.Count(r => (r.state == ParentageSimResult.S3_Fail_MotherUnsampled || r.state == ParentageSimResult.S3_Fail_PairUnsampled));
                    wt.WriteLine(string.Format("\tTrue mother unsampled\t{0}\t{1}\t{2}\t{3}\t{4}", n5,
                        (res3m.Count(r => (r.state == ParentageSimResult.S3_Fail_MotherUnsampled || r.state == ParentageSimResult.S3_Fail_PairUnsampled) && r.delta > dPM_999) / n5).ToString(DECIMAL),
                        (res3m.Count(r => (r.state == ParentageSimResult.S3_Fail_MotherUnsampled || r.state == ParentageSimResult.S3_Fail_PairUnsampled) && r.delta > dPM_99) / n5).ToString(DECIMAL),
                        (res3m.Count(r => (r.state == ParentageSimResult.S3_Fail_MotherUnsampled || r.state == ParentageSimResult.S3_Fail_PairUnsampled) && r.delta > dPM_95) / n5).ToString(DECIMAL),
                        (res3m.Count(r => (r.state == ParentageSimResult.S3_Fail_MotherUnsampled || r.state == ParentageSimResult.S3_Fail_PairUnsampled) && r.delta > dPM_80) / n5).ToString(DECIMAL)
                    ));


                    wt.WriteLine("Parent pair (sexes known), father alone");
                    n5 = res3f.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled));
                    wt.WriteLine(string.Format("\tTrue father sampled\t{0}\t{1}\t{2}\t{3}\t{4}", n5,
                        (res3f.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled) && r.delta > dPF_999) / n5).ToString(DECIMAL),
                        (res3f.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled) && r.delta > dPF_99) / n5).ToString(DECIMAL),
                        (res3f.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled) && r.delta > dPF_95) / n5).ToString(DECIMAL),
                        (res3f.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled) && r.delta > dPF_80) / n5).ToString(DECIMAL)
                    ));

                    n5 = res3f.Count(r => (r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_PairUnsampled));
                    wt.WriteLine(string.Format("\tTrue father unsampled\t{0}\t{1}\t{2}\t{3}\t{4}", n5,
                        (res3f.Count(r => (r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_PairUnsampled) && r.delta > dPF_999) / n5).ToString(DECIMAL),
                        (res3f.Count(r => (r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_PairUnsampled) && r.delta > dPF_99) / n5).ToString(DECIMAL),
                        (res3f.Count(r => (r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_PairUnsampled) && r.delta > dPF_95) / n5).ToString(DECIMAL),
                        (res3f.Count(r => (r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_PairUnsampled) && r.delta > dPF_80) / n5).ToString(DECIMAL)
                    ));


                    wt.WriteLine("Parent pair (sexes known)");
                    n5 = res3.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled));
                    wt.WriteLine(string.Format("\tTrue parent pair sampled\t{0}\t{1}\t{2}\t{3}\t{4}", n5,
                        (res3.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled) && r.delta > dP_999) / n5).ToString(DECIMAL),
                        (res3.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled) && r.delta > dP_99) / n5).ToString(DECIMAL),
                        (res3.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled) && r.delta > dP_95) / n5).ToString(DECIMAL),
                        (res3.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled) && r.delta > dP_80) / n5).ToString(DECIMAL)
                    ));

                    n5 = res3.Count(r => (r.state == ParentageSimResult.S3_Fail_PairUnsampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled));
                    wt.WriteLine(string.Format("\tTrue parent pair unsampled\t{0}\t{1}\t{2}\t{3}\t{4}", n5,
                        (res3.Count(r => (r.state == ParentageSimResult.S3_Fail_PairUnsampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled) && r.delta > dP_999) / n5).ToString(DECIMAL),
                        (res3.Count(r => (r.state == ParentageSimResult.S3_Fail_PairUnsampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled) && r.delta > dP_99) / n5).ToString(DECIMAL),
                        (res3.Count(r => (r.state == ParentageSimResult.S3_Fail_PairUnsampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled) && r.delta > dP_95) / n5).ToString(DECIMAL),
                        (res3.Count(r => (r.state == ParentageSimResult.S3_Fail_PairUnsampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled) && r.delta > dP_80) / n5).ToString(DECIMAL)
                    ));
                }

                if (PARENTAGE_UNKNOWN)
                {
                    wt.WriteLine("Parent pair (sexes unknown)");
                    n5 = res4.Count(r => (r.state == ParentageSimResult.S4_Success || r.state == ParentageSimResult.S4_Fail_PairSampled));
                    wt.WriteLine(string.Format("\tTrue parent pair sampled\t{0}\t{1}\t{2}\t{3}\t{4}", n5,
                        (res4.Count(r => (r.state == ParentageSimResult.S4_Success || r.state == ParentageSimResult.S4_Fail_PairSampled) && r.delta > dPU_999) / n5).ToString(DECIMAL),
                        (res4.Count(r => (r.state == ParentageSimResult.S4_Success || r.state == ParentageSimResult.S4_Fail_PairSampled) && r.delta > dPU_99) / n5).ToString(DECIMAL),
                        (res4.Count(r => (r.state == ParentageSimResult.S4_Success || r.state == ParentageSimResult.S4_Fail_PairSampled) && r.delta > dPU_95) / n5).ToString(DECIMAL),
                        (res4.Count(r => (r.state == ParentageSimResult.S4_Success || r.state == ParentageSimResult.S4_Fail_PairSampled) && r.delta > dPU_80) / n5).ToString(DECIMAL)
                    ));

                    n5 = res4.Count(r => (r.state == ParentageSimResult.S4_Fail_PairUnsampled || r.state == ParentageSimResult.S4_Fail_OneSampled));
                    wt.WriteLine(string.Format("\tTrue parent pair unsampled\t{0}\t{1}\t{2}\t{3}\t{4}", n5,
                        (res4.Count(r => (r.state == ParentageSimResult.S4_Fail_PairUnsampled || r.state == ParentageSimResult.S4_Fail_OneSampled) && r.delta > dPU_999) / n5).ToString(DECIMAL),
                        (res4.Count(r => (r.state == ParentageSimResult.S4_Fail_PairUnsampled || r.state == ParentageSimResult.S4_Fail_OneSampled) && r.delta > dPU_99) / n5).ToString(DECIMAL),
                        (res4.Count(r => (r.state == ParentageSimResult.S4_Fail_PairUnsampled || r.state == ParentageSimResult.S4_Fail_OneSampled) && r.delta > dPU_95) / n5).ToString(DECIMAL),
                        (res4.Count(r => (r.state == ParentageSimResult.S4_Fail_PairUnsampled || r.state == ParentageSimResult.S4_Fail_OneSampled) && r.delta > dPU_80) / n5).ToString(DECIMAL)
                    ));
                }

                wt.Flush();
                wt.Close();
            }

            public List<IND> oinds = null, minds = null, finds = null;

            public void AnalysisStartPaternity()
            {

            }

            public void AnalysisStartParentPair()
            {
                oinds = new List<IND>();
                minds = new List<IND>();
                finds = new List<IND>();

                foreach (var a in PARENTPAIR_OFFSPRING)
                    oinds.Add(indsdict[a]);
                foreach (var a in PARENTPAIR_FATHER)
                    finds.Add(indsdict[a]);
                foreach (var a in PARENTPAIR_MOTHER)
                    minds.Add(indsdict[a]);
            }

            public void AnalysisStartUnknown()
            {
                if (ARGS != null && ARGS.Length > 0 && ARGS[0] == "PARENT2") return;
                oinds = new List<IND>();
                minds = null;
                finds = new List<IND>();

                foreach (var a in UNKNOWN_OFFSPRING)
                    oinds.Add(indsdict[a]);
                foreach (var a in UNKNOWN_PARENT)
                    finds.Add(indsdict[a]);
            }

            public void AnalysisPaternityThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                int ploidy = (int)((object[])obj)[2];
                int noffspring = (int)((object[])obj)[3];
                List<ParentageAnalysisResultEntry>[] ana_resPA = (List<ParentageAnalysisResultEntry>[])((object[])obj)[4];

                double tin = (double)noffspring / N_THREAD;
                int nst = (int)(tin * id), ned = (int)(tin * (id + 1));
                bool estsr = PARENTAGE_ESTSR;

                //StringBuilder sb = new StringBuilder();
                for (int ii = nst; ii < ned; ++ii)
                {
                    //1. Read Individual
                    string[] cells = PATERNITY_OFFSPRING[ii].Split(new char[] { '\t', ',' }, StringSplitOptions.None);

                    IND o = indsdict[cells[0]], m = null;

                    if (cells[1] != "" && indsdict.ContainsKey(cells[1]))
                        m = indsdict[cells[1]];

                    List<IND> candidate = new List<IND>();
                    Dictionary<string, int> rep = new Dictionary<string, int>();
                    for (int i = cells.Length - 1; i >= 2; --i)
                        if (cells[i] != "" && indsdict.ContainsKey(cells[i]) && cells[i] != cells[0] && !rep.ContainsKey(cells[i]))
                        {
                            candidate.Add(indsdict[cells[i]]);
                            rep[cells[i]] = 0;
                        }

                    double[] lod1pair = estsr ? new double[candidate.Count] : null;
                    double[] lod2pair = estsr ? new double[candidate.Count] : null;
                    double[] lod2trio = estsr ? new double[candidate.Count] : null;

                    //2. Calculate LOD
                    List<ParentageAnalysisResultEntry> res2 = new List<ParentageAnalysisResultEntry>();//known mother
                    List<ParentageAnalysisResultEntry> res1 = new List<ParentageAnalysisResultEntry>();//father only
                    for (int ai = 0; ai < candidate.Count; ++ai)
                    {
                        IND a = candidate[ai];
                        ParentageAnalysisResultEntry tres = new ParentageAnalysisResultEntry();
                        tres.oid = o.name;
                        tres.olocityped = o.LociTyped();
                        tres.fid = a.name;
                        tres.flocityped = a.LociTyped();
                        tres.fmodelta = 0;
                        tres.fmolocimismatch = o.Mismatch(a, m);
                        tres.fmolocityped = o.LociTyped(a, m);
                        tres.fmolod = LOD(o, a, m);
                        tres.fmop = "";
                        tres.fodelta = 0;
                        tres.folocimismatch = o.Mismatch(a);
                        tres.folocityped = o.LociTyped(a);
                        tres.folod = LOD(o, a);
                        tres.fop = "";

                        /*
                         * Display mismatch
                        for(int l = 0; l < L; ++l)
                            if (PHENOTYPE.IsMismatch(o.g[l], a.g[l]))
                            {
                                sb.Append(o.name + "\t" + a.name + "\t" + total_pop.loc[l].name + "\t");
                                foreach (int aa in o.g[l].genotypes[0].alleles2)
                                    sb.Append(aa + ",");
                                sb.Append("\t");
                                foreach (int aa in a.g[l].genotypes[0].alleles2)
                                    sb.Append(aa + ",");
                                sb.Append("\r\n");
                            }
                        */

                        if (estsr)
                        {
                            if (m == null)
                                lod1pair[ai] = tres.folod;
                            else
                            {
                                lod2pair[ai] = tres.folod;
                                lod2trio[ai] = tres.fmolod;
                            }
                        }

                        tres.mid = "";
                        if (m != null)
                        {
                            tres.mid = m.name;
                            tres.mlocityped = m.LociTyped();
                            tres.molocimismatch = o.Mismatch(m);
                            tres.molocityped = o.LociTyped(m);
                            tres.molod = LOD(o, m);
                        }

                        switch (PARENTAGE_OUTPUT)
                        {
                            default:
                            case ParentageOutputStyle.Top1:
                            case ParentageOutputStyle.Top2:
                                if (res2.Count < 2 || tres.fmolod > res2[2 - 1].fmolod)
                                {
                                    int kk = 0;
                                    for (; kk < res2.Count; ++kk)
                                        if (tres.fmolod > res2[kk].fmolod)
                                            break;
                                    res2.Insert(kk, tres);
                                    if (res2.Count > 2) res2.RemoveAt(2);
                                }
                                break;
                            case ParentageOutputStyle.Top5:
                                if (res2.Count < 5 || tres.fmolod > res2[5 - 1].fmolod)
                                {
                                    int kk = 0;
                                    for (; kk < res2.Count; ++kk)
                                        if (tres.fmolod > res2[kk].fmolod)
                                            break;
                                    res2.Insert(kk, tres);
                                    if (res2.Count > 5) res2.RemoveAt(5);
                                }
                                break;
                            case ParentageOutputStyle.Positive:
                                if (tres.fmolod > 0) res2.Add(tres);
                                break;
                            case ParentageOutputStyle.All:
                                res2.Add(tres);
                                break;
                        }

                        if (res1.Count <= 1 || tres.folod > res1[1].folod)
                        {
                            int kk = 0;
                            for (; kk < res1.Count; ++kk)
                                if (tres.folod > res1[kk].folod)
                                    break;
                            res1.Insert(kk, tres);
                            if (res1.Count > 2) res1.RemoveAt(2);
                        }
                    }

                    res2.Sort((x, y) => y.fmolod.CompareTo(x.fmolod));
                    res2[0].fmodelta = (res2.Count > 0 ? res2[0].fmolod : 0) - (res2.Count > 1 ? res2[1].fmolod : 0);

                    if (m == null)
                        res2.ForEach(r => r.fmodelta = r.fmolod = r.fmolocimismatch = r.fmolocityped = -1);
                    else if (res2[0].fmodelta >= d2_999)
                        res2[0].fmop = "***";
                    else if (res2[0].fmodelta >= d2_99)
                        res2[0].fmop = "**";
                    else if (res2[0].fmodelta >= d2_95)
                        res2[0].fmop = "*";
                    else if (res2[0].fmodelta >= d2_80)
                        res2[0].fmop = "+";
                    else if (res2[0].fmodelta > 0)
                        res2[0].fmop = "-";

                    res1[0].fodelta = (res1.Count > 0 ? res1[0].folod : 0) - (res1.Count > 1 ? res1[1].folod : 0);

                    if (res1[0].fodelta >= d1_999)
                        res1[0].fop = "***";
                    else if (res1[0].fodelta >= d1_99)
                        res1[0].fop = "**";
                    else if (res1[0].fodelta >= d1_95)
                        res1[0].fop = "*";
                    else if (res1[0].fodelta >= d1_80)
                        res1[0].fop = "+";
                    else if (res1[0].fodelta > 0)
                        res1[0].fop = "-";

                    if (estsr)
                    {
                        if (m == null)
                        {
                            int id1 = candidate.IndexOf(indsdict[res1[0].fid]);
                            Swap(ref lod1pair[0], ref lod1pair[id1]);
                        }
                        else
                        {
                            int id1 = candidate.IndexOf(indsdict[res2[0].fid]);
                            Swap(ref lod2pair[0], ref lod2pair[id1]);
                            Swap(ref lod2trio[0], ref lod2trio[id1]);
                        }
                    }

                    if (PARENTAGE_OUTPUT == ParentageOutputStyle.Top1 && res2.Count > 1)
                        res2.RemoveAt(1);

                    ana_resPA[ii] = res2;

                    //GC.Collect();
                    Increment();
                }
            }

            public void AnalysisParentPairThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                int ploidy = (int)((object[])obj)[2];
                int noffspring = (int)((object[])obj)[3];
                List<ParentageAnalysisResultEntry>[] ana_resPP = (List<ParentageAnalysisResultEntry>[])((object[])obj)[4];

                double tin = (double)noffspring / N_THREAD;
                int nst = (int)(tin * id), ned = (int)(tin * (id + 1));
                bool estsr = PARENTAGE_ESTSR;

                for (int ii = nst; ii < ned; ++ii)
                {
                    List<IND> finds = this.finds, minds = this.minds;
                    IND o = oinds[ii];

                    //remove self
                    finds = finds.Where(f => f.name != o.name).ToList();
                    minds = minds.Where(m => m.name != o.name).ToList();

                    List<ParentageAnalysisResultEntry> res = new List<ParentageAnalysisResultEntry>(minds.Count * finds.Count);
                    List<ParentageAnalysisResultEntry> fres = new List<ParentageAnalysisResultEntry>(finds.Count), mres = new List<ParentageAnalysisResultEntry>(minds.Count);
                    double[] lod3pairf = estsr ? new double[finds.Count] : null;
                    double[] lod3pairm = estsr ? new double[minds.Count] : null;
                    double[] lod3triof = estsr ? new double[finds.Count] : null;
                    double[] lod3triom = estsr ? new double[minds.Count] : null;
                    if (estsr)
                    {
                        SetVal(lod3triof, -1e300);
                        SetVal(lod3triom, -1e300);
                    }

                    for (int mi = 0; mi < minds.Count; ++mi)
                    {
                        IND m = minds[mi];
                        ParentageAnalysisResultEntry tres = new ParentageAnalysisResultEntry();
                        tres.mid = m.name;
                        tres.mlocityped = m.LociTyped();
                        tres.modelta = 0;
                        tres.molocimismatch = o.Mismatch(m);
                        tres.molocityped = o.LociTyped(m);
                        tres.molod = m.name == o.name ? -1e300 : LOD(o, m);
                        tres.mop = "";
                        tres.oid = o.name;
                        tres.olocityped = o.LociTyped();
                        mres.Add(tres);
                        if (estsr) lod3pairm[mi] = tres.molod;
                    }

                    for (int fi = 0; fi < finds.Count; ++fi)
                    {
                        IND f = finds[fi];
                        ParentageAnalysisResultEntry tres = new ParentageAnalysisResultEntry();
                        tres.fid = f.name;
                        tres.flocityped = f.LociTyped();
                        tres.fodelta = 0;
                        tres.folocimismatch = o.Mismatch(f);
                        tres.folocityped = o.LociTyped(f);
                        tres.folod = f.name == o.name ? -1e300 : LOD(o, f);
                        tres.fop = "";
                        tres.oid = o.name;
                        tres.olocityped = o.LociTyped();
                        fres.Add(tres);
                        if (estsr) lod3pairf[fi] = tres.folod;
                    }

                    List<ParentageAnalysisResultEntry> fres2 = fres.OrderByDescending(r => r.folod).ToList();
                    List<ParentageAnalysisResultEntry> mres2 = mres.OrderByDescending(r => r.molod).ToList();

                    fres2[0].fodelta = (fres2.Count > 0 ? fres2[0].folod : 0) - (fres2.Count > 1 ? fres2[1].folod : 0);
                    mres2[0].modelta = (mres2.Count > 0 ? mres2[0].molod : 0) - (mres2.Count > 1 ? mres2[1].molod : 0);

                    if (fres2[0].fodelta >= dPF_999)
                        fres2[0].fop = "***";
                    else if (fres2[0].fodelta >= dPF_99)
                        fres2[0].fop = "**";
                    else if (fres2[0].fodelta >= dPF_95)
                        fres2[0].fop = "*";
                    else if (fres2[0].fodelta >= dPF_80)
                        fres2[0].fop = "+";
                    else if (fres2[0].fodelta > 0)
                        fres2[0].fop = "-";

                    if (mres2[0].modelta >= dPM_999)
                        mres2[0].fop = "***";
                    else if (mres2[0].modelta >= dPM_99)
                        mres2[0].fop = "**";
                    else if (mres2[0].modelta >= dPM_95)
                        mres2[0].fop = "*";
                    else if (mres2[0].modelta >= dPM_80)
                        mres2[0].fop = "+";
                    else if (mres2[0].modelta > 0)
                        mres2[0].fop = "-";

                    ////////////////////////////////////////////////////////////////
                    for (int i = 0; i < finds.Count; ++i)
                    {
                        for (int j = 0; j < minds.Count; ++j)
                        {
                            //if (!CONSIDER_SELFING && minds[j].name == finds[i].name) continue;
                            ParentageAnalysisResultEntry tres = new ParentageAnalysisResultEntry();
                            tres.fmop = "";
                            tres.flocityped = i;
                            tres.mlocityped = j;
                            tres.fmolod = LOD(o, finds[i], minds[j], minds[j]);
                            if (estsr)
                            {
                                lod3triof[i] = Math.Max(lod3triof[i], tres.fmolod);
                                lod3triom[j] = Math.Max(lod3triom[j], tres.fmolod);
                            }
                            res.Add(tres);
                        }
                    }

                    List<ParentageAnalysisResultEntry> res2 = res.OrderByDescending(r => r.fmolod).ToList();
                    res2[0].fmodelta = (res2.Count > 0 ? res2[0].fmolod : 0) - (res2.Count > 1 ? res2[1].fmolod : 0);

                    if (res2[0].fmodelta >= dP_999)
                        res2[0].fmop = "***";
                    else if (res2[0].fmodelta >= dP_99)
                        res2[0].fmop = "**";
                    else if (res2[0].fmodelta >= dP_95)
                        res2[0].fmop = "*";
                    else if (res2[0].fmodelta >= dP_80)
                        res2[0].fmop = "+";
                    else if (res2[0].fmodelta > 0)
                        res2[0].fmop = "-";

                    List<ParentageAnalysisResultEntry> rest1 = new List<ParentageAnalysisResultEntry>();
                    switch (PARENTAGE_OUTPUT)
                    {
                        default:
                        case ParentageOutputStyle.Top1:
                            for (int i = 0; i < Math.Min(1, res2.Count); ++i)
                                rest1.Add(res2[i]);
                            break;
                        case ParentageOutputStyle.Top2:
                            for (int i = 0; i < Math.Min(2, res2.Count); ++i)
                                rest1.Add(res2[i]);
                            break;
                        case ParentageOutputStyle.Top5:
                            for (int i = 0; i < Math.Min(5, res2.Count); ++i)
                                rest1.Add(res2[i]);
                            break;
                        case ParentageOutputStyle.Positive:
                            for (int i = 0; i < res2.Count; ++i)
                                if (res2[i].fmolod > 0)
                                    rest1.Add(res2[i]);
                            break;
                        case ParentageOutputStyle.All:
                            for (int i = 0; i < res2.Count; ++i)
                                rest1.Add(res2[i]);
                            break;
                    }

                    foreach (var r in rest1)
                    {
                        int j = r.mlocityped;
                        int i = r.flocityped;

                        IND m = minds[j];
                        IND f = finds[i];

                        ParentageAnalysisResultEntry fr = fres[i];
                        ParentageAnalysisResultEntry mr = mres[j];

                        r.fid = fr.fid;
                        r.flocityped = fr.flocityped;
                        r.mid = mr.mid;
                        r.mlocityped = mr.mlocityped;
                        r.oid = fr.oid;
                        r.olocityped = fr.olocityped;

                        r.fodelta = fr.fodelta;
                        r.folocimismatch = fr.folocimismatch;
                        r.folocityped = fr.folocityped;
                        r.folod = fr.folod;
                        r.fop = fr.fop;

                        r.modelta = mr.modelta;
                        r.molocimismatch = o.Mismatch(m);
                        r.molocityped = o.LociTyped(m);
                        r.molod = mr.molod;
                        r.mop = mr.fop;

                        r.fmolocimismatch = o.Mismatch(f, m);
                        r.fmolocityped = o.LociTyped(f, m);
                    }

                    if (estsr)
                    {
                        int id1 = finds.IndexOf(indsdict[res2[0].fid]), id2 = minds.IndexOf(indsdict[res2[0].mid]);
                        Swap(ref lod3pairf[0], ref lod3pairf[id1]);
                        Swap(ref lod3pairm[0], ref lod3pairm[id2]);

                        Swap(ref lod3triof[0], ref lod3triof[id1]);
                        Swap(ref lod3triom[0], ref lod3triom[id2]);
                    }

                    ana_resPP[ii] = rest1;
                    //GC.Collect();
                    Increment();
                }
            }

            public void AnalysisUnknownThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                int ploidy = (int)((object[])obj)[2];
                int noffspring = (int)((object[])obj)[3];
                List<ParentageAnalysisResultEntry>[] ana_resUS = (List<ParentageAnalysisResultEntry>[])((object[])obj)[4];

                double tin = (double)noffspring / N_THREAD;
                int nst = (int)(tin * id), ned = (int)(tin * (id + 1));
                bool estsr = PARENTAGE_ESTSR;

                for (int ii = nst; ii < ned; ++ii)
                {
                    List<IND> finds = this.finds;
                    IND o;
                    if (ARGS != null && ARGS.Length > 0 && (ARGS[0] == "PARENT2"))
                    {
                        string[] cells = UNKNOWN_OFFSPRING[ii].Split(new char[] { '\t', ',' }, StringSplitOptions.None);
                        finds = new List<IND>();
                        o = indsdict[cells[0]];
                        for (int i = 1; i < cells.Length; i++)
                            finds.Add(indsdict[cells[i]]);
                    }
                    else o = oinds[ii];
                    finds = finds.Where(f => f.name != o.name).ToList();

                    List<ParentageAnalysisResultEntry> res = new List<ParentageAnalysisResultEntry>(finds.Count * (finds.Count - 1) / 2);
                    List<ParentageAnalysisResultEntry> fres = new List<ParentageAnalysisResultEntry>(finds.Count);
                    double[] lod4pair = estsr ? new double[finds.Count] : null;
                    double[] lod4trio = estsr ? new double[finds.Count] : null;

                    if (estsr)
                        SetVal(lod4trio, -1e300);

                    for (int fi = 0; fi < finds.Count; ++fi)
                    {
                        IND f = finds[fi];
                        ParentageAnalysisResultEntry tres = new ParentageAnalysisResultEntry();
                        tres.mid = tres.fid = f.name;
                        tres.mlocityped = tres.flocityped = f.LociTyped();
                        tres.modelta = tres.fodelta = 0;
                        tres.molocimismatch = tres.folocimismatch = o.Mismatch(f);
                        tres.molocityped = tres.folocityped = o.LociTyped(f);
                        tres.molod = tres.folod = (f.name == o.name ? -1e300 : LOD(o, f));
                        tres.mop = tres.fop = "";

                        tres.oid = o.name;
                        tres.olocityped = o.LociTyped();
                        fres.Add(tres);
                        if (estsr) lod4pair[fi] = tres.molod;
                    }

                    for (int i = 0; i < finds.Count; ++i)
                    {
                        for (int j = i; j < finds.Count; ++j)
                        {
                            if (!CONSIDER_SELFING && j == i) continue;
                            ParentageAnalysisResultEntry tres = new ParentageAnalysisResultEntry();
                            tres.fmop = "";
                            tres.flocityped = j;
                            tres.mlocityped = i;
                            tres.fmolod = LOD(o, finds[j], finds[i], finds[i]);
                            if (estsr)
                            {
                                lod4trio[i] = Math.Max(lod4trio[i], tres.fmolod);
                                lod4trio[j] = Math.Max(lod4trio[j], tres.fmolod);
                            }
                            res.Add(tres);
                        }
                    }

                    List<ParentageAnalysisResultEntry> res2 = res.OrderByDescending(r => r.fmolod).ToList();
                    res2[0].fmodelta = (res2.Count > 0 ? res2[0].fmolod : 0) - (res2.Count > 1 ? res2[1].fmolod : 0);

                    if (res2[0].fmodelta >= dPU_999)
                        res2[0].fmop = "***";
                    else if (res2[0].fmodelta >= dPU_99)
                        res2[0].fmop = "**";
                    else if (res2[0].fmodelta >= dPU_95)
                        res2[0].fmop = "*";
                    else if (res2[0].fmodelta >= dPU_80)
                        res2[0].fmop = "+";
                    else if (res2[0].fmodelta > 0)
                        res2[0].fmop = "-";

                    List<ParentageAnalysisResultEntry> rest1 = new List<ParentageAnalysisResultEntry>();
                    switch (PARENTAGE_OUTPUT)
                    {
                        default:
                        case ParentageOutputStyle.Top1:
                            for (int i = 0; i < Math.Min(1, res2.Count); ++i)
                                rest1.Add(res2[i]);
                            break;
                        case ParentageOutputStyle.Top2:
                            for (int i = 0; i < Math.Min(2, res2.Count); ++i)
                                rest1.Add(res2[i]);
                            break;
                        case ParentageOutputStyle.Top5:
                            for (int i = 0; i < Math.Min(5, res2.Count); ++i)
                                rest1.Add(res2[i]);
                            break;
                        case ParentageOutputStyle.Positive:
                            for (int i = 0; i < res2.Count; ++i)
                                if (res2[i].fmolod > 0)
                                    rest1.Add(res2[i]);
                            break;
                        case ParentageOutputStyle.All:
                            for (int i = 0; i < res2.Count; ++i)
                                rest1.Add(res2[i]);
                            break;
                    }

                    foreach (var r in rest1)
                    {
                        int i = r.flocityped, j = r.mlocityped;
                        IND f = finds[i], m = finds[j];
                        ParentageAnalysisResultEntry fr = fres[i], mr = fres[j];
                        if (fr.folod > mr.folod)
                        {
                            Swap(ref f, ref m);
                            Swap(ref fr, ref mr);
                        }
                        //2. Calculate LOD
                        r.fid = fr.fid;
                        r.flocityped = fr.flocityped;
                        r.mid = mr.mid;
                        r.mlocityped = mr.mlocityped;
                        r.oid = fr.oid;
                        r.olocityped = fr.olocityped;

                        r.fodelta = fr.fodelta;
                        r.folocimismatch = fr.folocimismatch;
                        r.folocityped = fr.folocityped;
                        r.folod = fr.folod;
                        r.fop = fr.fop;

                        r.modelta = mr.fodelta;
                        r.molocimismatch = o.Mismatch(m);
                        r.molocityped = o.LociTyped(m);
                        r.molod = mr.folod;
                        r.mop = mr.fop;

                        r.fmolocimismatch = o.Mismatch(f, m);
                        r.fmolocityped = o.LociTyped(f, m);
                    }

                    if (estsr)
                    {
                        if (res2[0].fid != res2[0].mid)
                        {
                            //remove selfing
                            int id1 = finds.IndexOf(indsdict[res2[0].fid]), id2 = finds.IndexOf(indsdict[res2[0].mid]);
                            Swap(ref lod4pair[0], ref lod4pair[id1]);
                            Swap(ref lod4pair[1], ref lod4pair[id2]);

                            Swap(ref lod4trio[0], ref lod4trio[id1]);
                            Swap(ref lod4trio[1], ref lod4trio[id2]);
                        }
                        else
                        {
                            //denote selfing
                            int id1 = finds.IndexOf(indsdict[res2[0].fid]);
                            Swap(ref lod4pair[0], ref lod4pair[id1]);

                            Swap(ref lod4trio[0], ref lod4trio[id1]);
                        }
                    }

                    ana_resUS[ii] = rest1;
                    //GC.Collect();
                    Increment();
                }
            }

            public void AnalysisEndPaternity(List<ParentageAnalysisResultEntry>[] ana_resPA)
            {
                if (ana_resPA == null) return;
                StreamWriter wt = new StreamWriter(new FileStream("o_parentage_paternity.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_PARENTAGE_PATERNITY = wt;

                wt.WriteLine("Offspring ID	Loci typed	Mother ID	Loci typed	Pair loci compared	Pair loci mismatching	Pair LOD score	Candidate father ID	Loci typed	Pair loci compared	Pair loci mismatching	Pair LOD score	Pair Delta	Pair confidence	Trio loci compared	Trio loci mismatching	Trio LOD score	Trio Delta	Trio confidence");
                foreach (var a in ana_resPA)
                    foreach (var b in a)
                        b.WritePA(wt);

                wt.Flush();
                wt.Close();
            }

            public void AnalysisEndParentPair(List<ParentageAnalysisResultEntry>[] ana_resPP)
            {
                if (ana_resPP == null) return;
                StreamWriter wt = new StreamWriter(new FileStream("o_parentage_parentpair.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_PARENTAGE_PARENTPAIR = wt;

                wt.WriteLine("Offspring ID	Loci typed	Candidate mother ID	Loci typed	Pair loci compared	Pair loci mismatching	Pair LOD score	Pair Delta	Pair confidence	Candidate father ID	Loci typed	Pair loci compared	Pair loci mismatching	Pair LOD score	Pair Delta	Pair confidence	Trio loci compared	Trio loci mismatching	Trio LOD score	Trio Delta	Trio confidence");

                foreach (var a in ana_resPP)
                    foreach (var b in a)
                        b.WritePP(wt);

                wt.Flush();
                wt.Close();
            }

            public void AnalysisEndUnknown(List<ParentageAnalysisResultEntry>[] ana_resUS)
            {
                if (ana_resUS == null) return;
                StreamWriter wt = new StreamWriter(new FileStream("o_parentage_unknown.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_PARENTAGE_UNKNOWN = wt;

                wt.WriteLine("Offspring ID	Loci typed	First candidate ID	Loci typed	Pair loci compared	Pair loci mismatching	Pair LOD score	Second candidate ID	Loci typed	Pair loci compared	Pair loci mismatching	Pair LOD score	Trio loci compared	Trio loci mismatching	Trio LOD score	Trio Delta	Trio confidence");

                foreach (var a in ana_resUS)
                    foreach (var b in a)
                        b.WriteUS(wt);

                wt.Flush();
                wt.Close();
            }

            public static string Statistics(ParentageSimResult s, ParentageSimResultEntry[] res, bool outputvar = true)
            {
                int n = 0;
                double ex = 0, ex2 = 0;
                foreach (var p in res)
                {
                    if (p.state == s)
                    {
                        n++;
                        ex += p.delta;
                        ex2 += p.delta * p.delta;
                    }
                }
                double sd = 0;
                if (n > 0)
                {
                    ex /= n;
                    ex2 /= n;
                    sd = Math.Sqrt((ex2 - ex * ex) * n / (n - 1));
                }
                if (outputvar)
                    return n + "\t" + ex.ToString(DECIMAL) + "\t" + sd.ToString(DECIMAL);
                else
                    return n.ToString();
            }

            public static string Statistics2(ParentageSimResult s, ParentageSimResultEntry[] res, double d999, double d99, double d95, double d80, bool outputpercentage = true)
            {
                int n999 = 0, n99 = 0, n95 = 0, n80 = 0, n0 = 0;
                int nt999 = 0, nt99 = 0, nt95 = 0, nt80 = 0, nt0 = 0;
                foreach (var p in res)
                {
                    if (p.delta >= d999)
                    {
                        nt999++;
                        if (p.state == s) n999++;
                    }
                    if (p.delta >= d99)
                    {
                        nt99++;
                        if (p.state == s) n99++;
                    }
                    if (p.delta >= d95)
                    {
                        nt95++;
                        if (p.state == s) n95++;
                    }
                    if (p.delta >= d80)
                    {
                        nt80++;
                        if (p.state == s) n80++;
                    }
                    if (p.delta > 0)
                    {
                        nt0++;
                        if (p.state == s) n0++;
                    }
                }
                if (outputpercentage)
                    return string.Format("{0} ({1:0.0}%)\t{2} ({3:0.0}%)\t{4} ({5:0.0}%)\t{6} ({7:0.0}%)\t{8} ({9:0.0}%)",
                                         n999, nt999 == 0 ? 0 : n999 * 100.0 / nt999,
                                         n99, n99 == 0 ? 0 : n99 * 100.0 / nt99,
                                         n95, n95 == 0 ? 0 : n95 * 100.0 / nt95,
                                         n80, n80 == 0 ? 0 : n80 * 100.0 / nt80,
                                         n0, n0 == 0 ? 0 : n0 * 100.0 / nt0);
                else
                    return string.Format("{0}\t{1}\t{2}\t{3}\t{4}\t{5}",
                                         nt999, nt99, nt95, nt80, nt0, res.Length - nt0);
            }

            private int String2Confidence(string a)
            {
                switch (a)
                {
                    case "-": return 0;
                    case "+": return 800;
                    case "*": return 950;
                    case "**": return 990;
                    case "***": return 999;
                    default: return 0;
                }
            }
            /*
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public struct ExtremeAdder
            {
                //val = a * 2 ^ b
                [FieldOffset(0)]
                public double a;
                [FieldOffset(8)]
                public double b;

                [FieldOffset(0)]
                public ulong au;
                [FieldOffset(8)]
                public ulong bu;


                public ExtremeAdder(ExtremeAdder _ref)
                {
                    au = bu = 0;
                    a = _ref.a;
                    b = _ref.b;
                }

                public ExtremeAdder(double _a, double _b)
                {
                    au = bu = 0;
                    a = _a;
                    b = _b;
                }

                public static ExtremeAdder operator +(ExtremeAdder a, ExtremeAdder b)
                {
                    //add two classes
                    ExtremeAdder c = a;
                    b.Unify();
                    c.AddValueLog(b.b);
                    return c;
                }

                public static ExtremeAdder operator +(ExtremeAdder a, double b)
                {
                    //add a value
                    ExtremeAdder c = a;
                    c.AddValue(b);
                    return c;
                }

                public static ExtremeAdder operator &(ExtremeAdder a, double log2v)
                {
                    //add a value in log format
                    ExtremeAdder c = a;
                    c.AddValueLog(log2v);
                    return c;
                }

                public static ExtremeAdder operator -(ExtremeAdder a, ExtremeAdder b)
                {
                    //difference between two classes
                    ExtremeAdder c = a;
                    b.Unify();
                    c.MinusValueLog(b.b);
                    return c;
                }

                public static ExtremeAdder operator -(ExtremeAdder a, double b)
                {
                    //minus a value
                    ExtremeAdder c = a;
                    c.MinusValue(b);
                    return c;
                }

                public static ExtremeAdder operator ^(ExtremeAdder a, double log2v)
                {
                    //minus a value in log format
                    ExtremeAdder c = a;
                    c.MinusValueLog(log2v);
                    return c;
                }

                public static ExtremeAdder operator *(ExtremeAdder a, ExtremeAdder b)
                {
                    //product of two classes
                    ExtremeAdder c = a;
                    c.a *= b.a;
                    c.b += b.b;
                    return c;
                }

                public static ExtremeAdder operator *(ExtremeAdder a, double b)
                {
                    //multiply a value
                    ExtremeAdder c = a;
                    c.a *= b;
                    return c;
                }

                public static ExtremeAdder operator %(ExtremeAdder a, double log2v)
                {
                    //multiply a value in log format
                    ExtremeAdder c = a;
                    c.b += log2v;
                    return c;
                }

                public void AddValue(double v)
                {
                    //add a value
                    AddValueLog(Math.Log(v, 2));
                }

                public int GetAIndex()
                {
                    //return index of a
                    return (int)((au << 1) >> 52) - 1023;
                }

                public void AddValueLog(double log2v)
                {
                    //add a value in log format
                    double idx = GetAIndex() + b;
                    if (log2v > idx + 53)
                    {
                        //a 2^b + 2^log2v
                        a = 1;
                        b = log2v;
                    }
                    else if (log2v > idx)
                    {
                        //a 2^(b-log2v) 2^log2v + 2^log2v
                        a = 1 + a * Math.Pow(2, b - log2v);
                        b = log2v;
                    }
                    else if (log2v > idx - 53)
                    {
                        //a 2^b + 2^(log2v-b) 2^b
                        a = a + Math.Pow(2, log2v - b);
                    }
                    if (a > 0 && (a > 1e100 || a < 1e-100) || a < 0 && (a < -1e100 || a > -1e-100))
                        Unify();
                }

                public void MinusValue(double v)
                {
                    MinusValueLog(Math.Log(v, 2));
                }

                public void MinusValueLog(double log2v)
                {
                    //minus a val in log format
                    double idx = GetAIndex() + b;
                    if (log2v > idx + 53)
                    {
                        //a 2^b - 2^log2v
                        a = -1;
                        b = log2v;
                    }
                    else if (log2v > idx)
                    {
                        //a 2^(b-log2v) 2^log2v - 2^log2v
                        a = a * Math.Pow(2, b - log2v) - 1;
                        b = log2v;
                    }
                    else if (log2v > idx - 53)
                        // a 2^b - 2^(log2v-b) 2^b
                        a = a - Math.Pow(2, log2v - b);

                    if (a > 0 && (a > 1e100 || a < 1e-100) || a < 0 && (a < -1e100 || a > -1e-100))
                        Unify();
                }

                public void MulValue(double v)
                {
                    //multiply a value
                    b += Math.Log(v, 2);
                }

                public void MulLogValue(double log2v)
                {
                    //multiply a value in log format
                    b += log2v;
                }

                public double Unify()
                {
                    //return value
                    b += Math.Log(a, 2);
                    a = 1;
                    return b;
                }

                public static double AddLogValues(double log2v1, double log2v2)
                {
                    //Sum of two values, values are in log format
                    double maxq = Math.Max(log2v1, log2v2) - 52;
                    ExtremeAdder re = new ExtremeAdder(1, -1e300);
                    if (log2v1 > maxq) re.AddValueLog(log2v1);
                    if (log2v2 > maxq) re.AddValueLog(log2v2);
                    re.Unify();
                    return re.b;
                }

                public static double MinusLogValues(double log2v1, double log2v2)
                {
                    //difference of two values, values are in log format
                    double maxq = Math.Max(log2v1, log2v2) - 52;
                    ExtremeAdder re = new ExtremeAdder(1, -1e300);
                    if (log2v1 > maxq) re.AddValueLog(log2v1);
                    if (log2v2 > maxq) re.MinusValueLog(log2v2);
                    re.Unify();
                    return re.b;
                }

                public static double SumLogValues(double[] log2vs)
                {
                    //sum of values, values are in log format
                    double maxq = log2vs.Max() - 52;
                    ExtremeAdder re = new ExtremeAdder(1, -1e300);
                    foreach (double q in log2vs)
                        if (q > maxq)
                            re.AddValueLog(q);
                    re.Unify();
                    return re.b;
                }

                public static double SumLogValues(double[,] log2vs)
                {
                    //sum of values, values are in log format
                    ExtremeAdder re = new ExtremeAdder(1, -1e300);
                    double maxq = -1e300;
                    foreach (double q in log2vs)
                        if (q > maxq)
                            maxq = q;
                    maxq -= 52;
                    foreach (double q in log2vs)
                        if (q > maxq)
                            re.AddValueLog(q);

                    re.Unify();
                    return re.b;
                }

                public static double SumLogValues(double[,] log2vs, int ist, int ilen, int jst, int jlen)
                {
                    //sum of values, values are in log format
                    ilen = Math.Min(log2vs.GetLength(0), ist + ilen);
                    jlen = Math.Min(log2vs.GetLength(1), jst + jlen);

                    double maxq = -1e300;
                    for (int i = ist; i < ilen; ++i)
                        for (int j = jst; j < jlen; ++j)
                            if (log2vs[i, j] > maxq)
                                maxq = log2vs[i, j];
                    maxq -= 52;
                    ExtremeAdder re = new ExtremeAdder(1, -1e300);
                    for (int i = ist; i < ilen; ++i)
                        for (int j = jst; j < jlen; ++j)
                            if (log2vs[i, j] > maxq)
                                re.AddValueLog(log2vs[i, j]);

                    re.Unify();
                    return re.b;
                }

                public static double SumLogSquare(double[] log2vs)
                {
                    //sum of squared values, values are in log format
                    double maxq = log2vs.Max() - 52 / 2;
                    ExtremeAdder re = new ExtremeAdder(1, -1e300);
                    foreach (double q in log2vs)
                        if (q > maxq)
                            re.AddValueLog(q * 2);
                    re.Unify();
                    return re.b;
                }

                public static double SumLogUpper(double[,] log2vs)
                {
                    //sum of values in upper triangular matrix, values are in log format
                    ExtremeAdder re = new ExtremeAdder(1, -1e300);
                    int n = log2vs.GetLength(0);
                    double maxq = -1e300;

                    for (int i = 0; i < n; ++i)
                        for (int j = 0; j < i; ++j)
                            if (log2vs[i, j] > maxq)
                                maxq = log2vs[i, j];
                    maxq -= 52;
                    for (int i = 0; i < n; ++i)
                        for (int j = 0; j < i; ++j)
                            if (log2vs[i, j] > maxq)
                                re.AddValueLog(log2vs[i, j]);

                    re.Unify();
                    return re.b;
                }

                public static double SumLogUpperDiag(double[,] log2vs)
                {
                    //sum of values in upper triangular matrix and diagonal, values are in log format
                    ExtremeAdder re = new ExtremeAdder(1, -1e300);
                    int n = log2vs.GetLength(0);
                    double maxq = -1e300;

                    for (int i = 0; i < n; ++i)
                        for (int j = 0; j <= i; ++j)
                            if (log2vs[i, j] > maxq)
                                maxq = log2vs[i, j];
                    maxq -= 52;
                    for (int i = 0; i < n; ++i)
                        for (int j = 0; j <= i; ++j)
                            if (log2vs[i, j] > maxq)
                                re.AddValueLog(log2vs[i, j]);

                    re.Unify();
                    return re.b;
                }
            }
            */
            public void PaternityEstErrPair(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                int nsim = (int)((object[])obj)[2];
                int[] delta1 = (int[])((object[])obj)[3];
                int[] delta2 = (int[])((object[])obj)[4];

                int[] d1 = new int[L], d2 = new int[L];
                double tin = (double)nsim / N_THREAD;
                int nst = (int)(tin * id), ned = (int)(tin * (id + 1));

                for (int i = nst; i < ned; ++i)
                {
                    Random rnd = new Random(SEED ^ (i + 0x6ECD712D));//bug fixed on 20220324
                    int oid = rnd.Next(inds.Length), fid = rnd.Next(inds.Length);
                    IND o = inds[oid], f = inds[fid];
                    for (int l = 0; l < L; ++l)
                    {
                        if (o.g[l].hash != 0 && f.g[l].hash != 0)
                        {
                            if (PHENOTYPE.IsMismatch(o.g[l], f.g[l])) d1[l]++;
                            d2[l]++;
                        }
                    }
                    Increment();
                }

                lock (delta1)
                {
                    for (int l = 0; l < L; ++l)
                    {
                        delta1[l] += d1[l];
                        delta2[l] += d2[l];
                    }
                }
            }

            public double EstimateErrorRatePair(StreamWriter wt, string title, bool f1, bool f2, bool f3, bool f4, ref double weight,
                List<ParentageAnalysisResultEntry>[] ana_resPA, List<ParentageAnalysisResultEntry>[] ana_resPP, List<ParentageAnalysisResultEntry>[] ana_resUS)
            {
                Progress = "Estimating genotyping error rate";
                wt.WriteLine(title);

                //estimate deltal
                int nconfidence = 0;
                int[] gamma1 = new int[L], gamma2 = new int[L];
                int[] delta1 = new int[L], delta2 = new int[L];

                //Add thread
                Progress = "Estimating pair mismatch rate";
                ProgressValue = 0;
                ProgressMax = PARENTAGE_ERROR_NSIM;
                SetProgress(ProgressValue, ProgressMax);

                CallThread(PaternityEstErrPair, N_THREAD, new object[] { PARENTAGE_ERROR_NSIM, delta1, delta2 },
                PARENTAGE_ERROR_NSIM, ref ProgressValue);

                switch (PARENTAGE_ESTERR)
                {
                    case ParentageEstimateError.Confidence80: nconfidence = 800; break;
                    case ParentageEstimateError.Confidence95: nconfidence = 950; break;
                    case ParentageEstimateError.Confidence99: nconfidence = 990; break;
                    case ParentageEstimateError.Confidence999: nconfidence = 999; break;
                    case ParentageEstimateError.NotDone:
                    default: nconfidence = 1100; break;
                }

                Dictionary<int, int> table = new Dictionary<int, int>();

                if (f1 && ana_resPA != null)
                    foreach (var a in ana_resPA)
                    {
                        if (a.Count == 0) continue;
                        var c = a[0];
                        if (c.mid != "") continue;
                        IND o = indsdict[c.oid], f = indsdict[c.fid], m = c.mid == "" ? null : indsdict[c.mid];
                        bool sig = String2Confidence(c.mid == "" ? c.fop : c.fmop) >= nconfidence;
                        int fkey = (o.id << 16) | f.id, mkey = m == null ? 0 : (o.id << 16) | m.id;

                        if (sig && !table.ContainsKey(fkey))
                        {
                            table[fkey] = 0;
                            for (int l = 0; l < L; ++l)
                                if (o.g[l].hash != 0 && f.g[l].hash != 0)
                                {
                                    if (PHENOTYPE.IsMismatch(o.g[l], f.g[l])) gamma1[l]++;
                                    gamma2[l]++;
                                }
                        }

                        if (m != null && !table.ContainsKey(mkey))
                        {
                            table[mkey] = 0;
                            for (int l = 0; l < L; ++l)
                                if (o.g[l].hash != 0 && m.g[l].hash != 0)
                                {
                                    if (PHENOTYPE.IsMismatch(o.g[l], m.g[l])) gamma1[l]++;
                                    gamma2[l]++;
                                }
                        }
                    }

                if (f2 && ana_resPA != null)
                    foreach (var a in ana_resPA)
                    {
                        if (a.Count == 0) continue;
                        var c = a[0];
                        if (c.mid == "") continue;
                        IND o = indsdict[c.oid], f = indsdict[c.fid], m = c.mid == "" ? null : indsdict[c.mid];
                        bool sig = String2Confidence(c.mid == "" ? c.fop : c.fmop) >= nconfidence;
                        int fkey = (o.id << 16) | f.id, mkey = m == null ? 0 : (o.id << 16) | m.id;

                        if (sig && !table.ContainsKey(fkey))
                        {
                            table[fkey] = 0;
                            for (int l = 0; l < L; ++l)
                                if (o.g[l].hash != 0 && f.g[l].hash != 0)
                                {
                                    if (PHENOTYPE.IsMismatch(o.g[l], f.g[l])) gamma1[l]++;
                                    gamma2[l]++;
                                }
                        }

                        if (m != null && !table.ContainsKey(mkey))
                        {
                            table[mkey] = 0;
                            for (int l = 0; l < L; ++l)
                                if (o.g[l].hash != 0 && m.g[l].hash != 0)
                                {
                                    if (PHENOTYPE.IsMismatch(o.g[l], m.g[l])) gamma1[l]++;
                                    gamma2[l]++;
                                }
                        }
                    }

                if (f3 && ana_resPP != null)
                    foreach (var a in ana_resPP)
                    {
                        if (a.Count == 0) continue;
                        var c = a[0];
                        if (String2Confidence(c.fmop) < nconfidence) continue;
                        IND o = indsdict[c.oid], f = indsdict[c.fid], m = indsdict[c.mid];
                        int fkey = (o.id << 16) | f.id, mkey = (o.id << 16) | m.id;
                        if (!table.ContainsKey(fkey))
                        {
                            table[fkey] = 0;
                            for (int l = 0; l < L; ++l)
                                if (o.g[l].hash != 0 && f.g[l].hash != 0)
                                {
                                    if (PHENOTYPE.IsMismatch(o.g[l], f.g[l])) gamma1[l]++;
                                    gamma2[l]++;
                                }
                        }

                        if (!table.ContainsKey(mkey))
                        {
                            table[mkey] = 0;
                            for (int l = 0; l < L; ++l)
                                if (o.g[l].hash != 0 && m.g[l].hash != 0)
                                {
                                    if (PHENOTYPE.IsMismatch(o.g[l], m.g[l])) gamma1[l]++;
                                    gamma2[l]++;
                                }
                        }
                    }

                if (f4 && ana_resUS != null)
                    foreach (var a in ana_resUS)
                    {
                        if (a.Count == 0) continue;
                        var c = a[0];
                        if (String2Confidence(c.fmop) < nconfidence) continue;
                        IND o = indsdict[c.oid], f = indsdict[c.fid], m = indsdict[c.mid];
                        int fkey = (o.id << 16) | f.id, mkey = (o.id << 16) | m.id;
                        if (!table.ContainsKey(fkey))
                        {
                            table[fkey] = 0;
                            for (int l = 0; l < L; ++l)
                                if (o.g[l].hash != 0 && f.g[l].hash != 0)
                                {
                                    if (PHENOTYPE.IsMismatch(o.g[l], f.g[l])) gamma1[l]++;
                                    gamma2[l]++;
                                }
                        }

                        if (!table.ContainsKey(mkey))
                        {
                            table[mkey] = 0;
                            for (int l = 0; l < L; ++l)
                                if (o.g[l].hash != 0 && m.g[l].hash != 0)
                                {
                                    if (PHENOTYPE.IsMismatch(o.g[l], m.g[l])) gamma1[l]++;
                                    gamma2[l]++;
                                }
                        }
                    }

                if (table.Count == 0)
                {
                    wt.WriteLine("No reference pairs are found.\r\n");
                    return double.NaN;
                }

                wt.WriteLine("Estimating genotyping error rate from pair mismatch");
                wt.WriteLine("Locus\tn_pair\tgamma\tdelta\tE\tweight");

                double E1 = 0, E2 = 0;
                for (int l = 0; l < L; ++l)
                {
                    double gamma = gamma1[l] / (gamma2[l] + DUNDERFLOW);
                    double delta = delta1[l] / (delta2[l] + DUNDERFLOW);
                    double E = gamma / (delta + DUNDERFLOW);
                    double ivE = gamma2[l] * delta;

                    wt.WriteLine(total_pop.loc[l].name + "\t" +
                        gamma2[l] + "\t" +
                        gamma.ToString(DECIMAL) + "\t" +
                        delta.ToString(DECIMAL) + "\t" +
                        E.ToString(DECIMAL) + "\t" +
                        ivE.ToString(DECIMAL));

                    if (!double.IsInfinity(E) && !double.IsNaN(E))
                    {
                        E1 += E * ivE;
                        E2 += ivE;
                    }
                }

                double e = 1 - Math.Sqrt(1 - E1 / (E2 + DUNDERFLOW));
                wt.WriteLine("");
                wt.WriteLine("Number of pairs sampled to estimate delta: " + PARENTAGE_ERROR_NSIM);
                wt.WriteLine("Number of reference pairs: " + table.Count);
                wt.WriteLine("Multi-locus E: " + (E1 / (E2 + DUNDERFLOW)).ToString(DECIMAL));
                wt.WriteLine("Estimated genotyping error rate: " + e.ToString(DECIMAL));
                wt.WriteLine("Variance of genotyping error rate: e / " + (2 * E2).ToString(DECIMAL));
                wt.WriteLine("Weight of genotyping error rate: " + (2 * E2).ToString(DECIMAL));
                wt.WriteLine("");

                weight = 2 * E2;
                return e;
            }

            public void PaternityEstErrTrio(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                int nsim = (int)((object[])obj)[2];
                int[] deltao1 = (int[])((object[])obj)[3];
                int[] deltao2 = (int[])((object[])obj)[4];
                int[] deltas1 = (int[])((object[])obj)[5];
                int[] deltas2 = (int[])((object[])obj)[6];
                int[] deltap1 = (int[])((object[])obj)[7];
                int[] deltap2 = (int[])((object[])obj)[8];
                Dictionary<int, int> table = (Dictionary<int, int>)((object[])obj)[9];
                int[] table2 = table.Keys.ToArray();

                int[] do1 = new int[L], do2 = new int[L], ds1 = new int[L], ds2 = new int[L], dp1 = new int[L], dp2 = new int[L];
                double tin = (double)nsim / N_THREAD;
                int nst = (int)(tin * id), ned = (int)(tin * (id + 1));

                for (int i = nst; i < ned; ++i)
                {
                    Random rnd = new Random(SEED ^ (i + 0x15E35C2D));//bug fixed on 20220324
                    IND o = inds[rnd.Next(inds.Length)], f = inds[rnd.Next(inds.Length)], m = inds[rnd.Next(inds.Length)];
                    int cid = rnd.Next(table.Count);
                    IND o2 = inds[table2[cid] >> 16], m2 = inds[table2[cid] & 0xFFFF], f2 = inds[rnd.Next(inds.Length)];

                    for (int l = 0; l < L; ++l)
                    {
                        if (o.g[l].hash != 0 && f.g[l].hash != 0)
                        {
                            if (PHENOTYPE.IsMismatch(o.g[l], f.g[l], f.g[l])) ds1[l]++;
                            ds2[l]++;
                            if (m.g[l].hash != 0)
                            {
                                if (PHENOTYPE.IsMismatch(o.g[l], f.g[l], m.g[l])) do1[l]++;
                                do2[l]++;
                            }
                        }
                        if (o2.g[l].hash != 0 && f2.g[l].hash != 0 && m2.g[l].hash != 0)
                        {
                            if (PHENOTYPE.IsMismatch(o.g[l], f.g[l], m.g[l])) dp1[l]++;
                            dp2[l]++;
                        }
                    }
                    Increment();
                }

                lock (deltao1)
                {
                    for (int l = 0; l < L; ++l)
                    {
                        deltao1[l] += do1[l];
                        deltao2[l] += do2[l];
                        deltas1[l] += ds1[l];
                        deltas2[l] += ds2[l];
                        deltap1[l] += dp1[l];
                        deltap2[l] += dp2[l];
                    }
                }
            }

            public double EstimateErrorRateTrio(StreamWriter wt, string title, bool f2, bool f3, bool f4, ref double weight,
                List<ParentageAnalysisResultEntry>[] ana_resPA, List<ParentageAnalysisResultEntry>[] ana_resPP, List<ParentageAnalysisResultEntry>[] ana_resUS)
            {
                Progress = "Estimating genotyping error rate";
                //By Trio Mismatch
                wt.WriteLine(title);

                //estimate deltal
                int nconfidence = 0;
                int[] deltao1 = new int[L], deltao2 = new int[L], deltas1 = new int[L], deltas2 = new int[L], deltap1 = new int[L], deltap2 = new int[L];

                //prepare pair table
                Dictionary<int, int> table = new Dictionary<int, int>();

                if (f2 && ana_resPA != null)
                    foreach (var a in ana_resPA)
                    {
                        if (a.Count == 0) continue;
                        var c = a[0];
                        IND o = indsdict[c.oid], f = indsdict[c.fid], m = c.mid == "" ? null : indsdict[c.mid];
                        bool sig = String2Confidence(c.mid == "" ? c.fop : c.fmop) >= nconfidence;
                        int fkey = (o.id << 16) | f.id, mkey = m == null ? 0 : (o.id << 16) | m.id;
                        if (sig && !table.ContainsKey(fkey)) table[fkey] = 0;
                        if (m != null && !table.ContainsKey(mkey)) table[mkey] = 0;
                    }

                if (f3 && ana_resPP != null)
                    foreach (var a in ana_resPP)
                    {
                        if (a.Count == 0) continue;
                        var c = a[0];
                        IND o = indsdict[c.oid], f = indsdict[c.fid], m = indsdict[c.mid];
                        bool sig = String2Confidence(c.fmop) >= nconfidence;
                        int fkey = (o.id << 16) | f.id, mkey = (o.id << 16) | m.id;
                        if (sig && !table.ContainsKey(fkey)) table[fkey] = 0;
                        if (sig && !table.ContainsKey(mkey)) table[mkey] = 0;
                    }

                if (f4 && ana_resUS != null)
                    foreach (var a in ana_resUS)
                    {
                        if (a.Count == 0) continue;
                        var c = a[0];
                        IND o = indsdict[c.oid], f = indsdict[c.fid], m = indsdict[c.mid];
                        bool sig = String2Confidence(c.fmop) >= nconfidence;
                        int fkey = (o.id << 16) | f.id, mkey = (o.id << 16) | m.id;
                        if (sig && !table.ContainsKey(fkey)) table[fkey] = 0;
                        if (sig && !table.ContainsKey(mkey)) table[mkey] = 0;
                    }

                if (table.Count == 0)
                {
                    wt.WriteLine("No reference pairs are found.\r\n");
                    return double.NaN;
                }

                //Add thread
                Progress = "Estimating trio mismatch rate";
                ProgressValue = 0;
                ProgressMax = PARENTAGE_ERROR_NSIM;
                SetProgress(ProgressValue, ProgressMax);

                CallThread(PaternityEstErrTrio, N_THREAD,
                            new object[] { PARENTAGE_ERROR_NSIM, deltao1, deltao2, deltas1, deltas2, deltap1, deltap2, table },
                PARENTAGE_ERROR_NSIM, ref ProgressValue);

                switch (PARENTAGE_ESTERR)
                {
                    case ParentageEstimateError.Confidence80: nconfidence = 800; break;
                    case ParentageEstimateError.Confidence95: nconfidence = 950; break;
                    case ParentageEstimateError.Confidence99: nconfidence = 990; break;
                    case ParentageEstimateError.Confidence999: nconfidence = 999; break;
                    case ParentageEstimateError.NotDone: 
                    default: nconfidence = 1100; break;
                }

                int[] gamma1 = new int[L], gamma2 = new int[L];
                int nselfing = 0, ntrio = 0;
                Dictionary<ulong, int> table2 = new Dictionary<ulong, int>();

                if (f2 && ana_resPA != null)
                    foreach (var a in ana_resPA)
                    {
                        if (a.Count == 0) continue;
                        var c = a[0];
                        IND o = indsdict[c.oid], f = indsdict[c.fid], m = c.mid == "" ? null : indsdict[c.mid];
                        if (m == null || String2Confidence(c.fmop) < nconfidence) continue;
                        if (f == m) nselfing++;
                        if (f.id < m.id) Swap(ref f, ref m);
                        ulong key = ((ulong)o.id << 32) ^ ((ulong)f.id << 16) ^ (ulong)m.id;
                        if (table2.ContainsKey(key)) continue;
                        table2[key] = 0;

                        for (int l = 0; l < L; ++l)
                        {
                            if (o.g[l].hash == 0 || f.g[l].hash == 0 || m.g[l].hash == 0) continue;
                            if (PHENOTYPE.IsMismatch(o.g[l], f.g[l], m.g[l])) gamma1[l]++;
                            gamma2[l]++;
                        }
                        ntrio++;
                    }

                if (f3 && ana_resPP != null)
                    foreach (var a in ana_resPP)
                    {
                        if (a.Count == 0) continue;
                        var c = a[0];
                        if (String2Confidence(c.fmop) < nconfidence) continue;
                        IND o = indsdict[c.oid], f = indsdict[c.fid], m = indsdict[c.mid];
                        if (f == m) nselfing++;
                        if (f.id < m.id) Swap(ref f, ref m);
                        ulong key = ((ulong)o.id << 32) ^ ((ulong)f.id << 16) ^ (ulong)m.id;
                        if (table2.ContainsKey(key)) continue;
                        table2[key] = 0;

                        for (int l = 0; l < L; ++l)
                        {
                            if (o.g[l].hash == 0 || f.g[l].hash == 0 || m.g[l].hash == 0) continue;
                            if (PHENOTYPE.IsMismatch(o.g[l], f.g[l], m.g[l])) gamma1[l]++;
                            gamma2[l]++;
                        }
                        ntrio++;
                    }

                if (f4 && ana_resUS != null)
                    foreach (var a in ana_resUS)
                    {
                        if (a.Count == 0) continue;
                        var c = a[0];
                        if (String2Confidence(c.fmop) < nconfidence) continue;
                        IND o = indsdict[c.oid], f = indsdict[c.fid], m = indsdict[c.mid];
                        if (f == m) nselfing++;
                        if (f.id < m.id) Swap(ref f, ref m);
                        ulong key = ((ulong)o.id << 32) ^ ((ulong)f.id << 16) ^ (ulong)m.id;
                        if (table2.ContainsKey(key)) continue;
                        table2[key] = 0;

                        for (int l = 0; l < L; ++l)
                        {
                            if (o.g[l].hash == 0 || f.g[l].hash == 0 || m.g[l].hash == 0) continue;
                            if (PHENOTYPE.IsMismatch(o.g[l], f.g[l], m.g[l])) gamma1[l]++;
                            gamma2[l]++;
                        }
                        ntrio++;
                    }

                if (table2.Count == 0)
                {
                    wt.WriteLine("No reference trios are found.\r\n");
                    return double.NaN;
                }

                wt.WriteLine("Estimating genotyping error rate from trio mismatch");
                wt.WriteLine("Locus\tn_trio\tgamma\tdelta\tdeltao\tdeltas\tdeltap\te\tweight");
                double E1 = 0, E2 = 0, st = nselfing / (double)table2.Count;
                for (int l = 0; l < L; ++l)
                {
                    double gamma = gamma1[l] / (gamma2[l] + DUNDERFLOW);
                    double deltao = deltao1[l] / (deltao2[l] + DUNDERFLOW);
                    double deltas = deltas1[l] / (deltas2[l] + DUNDERFLOW);
                    double deltap = deltap1[l] / (deltap2[l] + DUNDERFLOW);
                    double delta = (1 - st) * (deltao + 2 * deltap) + 2 * st * deltas;
                    double c1 =    (1 - st) * (deltao + 2 * deltap) + 2 * st * deltas;
                    double c2 = (1 - st) * (deltao - 4 * deltap) - st * deltas;
                    double c3 = (1 - st) * (2 * deltap - deltao);//Eqn (A8) is incorrect, this is correct

                    double ee = (Math.Sqrt(c1 * c1 + 4 * c2 * gamma) - c1) / (2 * c2);
                    double ivE = gamma2[l] * delta;

                    wt.Write(total_pop.loc[l].name + "\t" +
                        gamma2[l] + "\t" +
                        gamma.ToString(DECIMAL) + "\t" +
                        delta.ToString(DECIMAL) + "\t" +
                        deltao.ToString(DECIMAL) + "\t" +
                        deltas.ToString(DECIMAL) + "\t" +
                        deltap.ToString(DECIMAL) + "\t" +
                        ee.ToString(DECIMAL) + "\t" +
                        ivE.ToString(DECIMAL) + "\r\n");

                    if (!double.IsInfinity(ee) && !double.IsNaN(ee))
                    {
                        E1 += ee * ivE;
                        E2 += ivE;
                    }
                }

                double e = E1 / (E2 + DUNDERFLOW);
                wt.WriteLine("");
                wt.WriteLine("Number of trios sampled to estimate delta: " + PARENTAGE_ERROR_NSIM);
                wt.WriteLine("Number of reference pairs: " + table.Count);
                wt.WriteLine("Number of reference trios: " + table2.Count);
                wt.WriteLine("Selfing rate in the reference trios: " + nselfing + " / " + table2.Count);
                wt.WriteLine("Estimated genotyping error rate: " + e.ToString(DECIMAL));
                wt.WriteLine("Variance of genotyping error rate: e / " + (E2).ToString(DECIMAL));
                wt.WriteLine("Weight of genotyping error rate: " + E2.ToString(DECIMAL));
                wt.WriteLine("");

                weight = E2;
                return e;
            }

            public double EstimateSampleRateApp12(StreamWriter wt, string confidence, ref double weight, double c, double u, double r, double n)
            {
                double ps = 0.5;
                if (c - u < 0.01)
                    weight = 1e-10;
                else
                {
                    double a = (r + 1) / (n + 2);
                    double varah = a * (1 - a) / n;
                    weight = (c - u) * (c - u) / varah;
                    ps = (r / n - u) / (c - u + DUNDERFLOW);
                }

                wt.WriteLine("\t" + confidence
                    + "\t" + c.ToString(DECIMAL)
                    + "\t" + u.ToString(DECIMAL)
                    + "\t" + r.ToString("F0")
                    + "\t" + n.ToString("F0")
                    + "\t" + ps.ToString(DECIMAL)
                    + "\t" + weight.ToString(DECIMAL)
                    );
                return ps;
            }

            public double EstimateSampleRateApp3(StreamWriter wt, string confidence, ref double weight, double c, double u, double r, double n)
            {
                double ps = 0.5;
                if (c - u < 0.01)
                    weight = 1e-10;
                else
                {
                    double a = (r + 1) / (n + 2);
                    double lna = Math.Log(a), lnma = Math.Log(1 - a);
                    double ps1 = 0, ps2 = 0;
                    for (int r2 = 0; r2 <= n; ++r2)
                    {
                        double prob = Math.Exp(BinomialLn(n, r2) + r2 * lna + (n - r2) * lnma);
                        double v = r2 / n < u ? 0 : (r2 / n > c ? 1 : Math.Sqrt((r2 / n - u) / (c - u + DUNDERFLOW)));
                        ps1 += v * prob;
                        ps2 += v * v * prob;
                    }
                    weight = 1.0 / (ps2 - ps1 * ps1);
                    ps = r / n < u ? 0 : (r / n > c ? 1 : Math.Sqrt((r / n - u) / (c - u + DUNDERFLOW)));
                }

                wt.WriteLine("\t" + confidence
                    + "\t" + c.ToString(DECIMAL)
                    + "\t" + u.ToString(DECIMAL)
                    + "\t" + r.ToString("F0")
                    + "\t" + n.ToString("F0")
                    + "\t" + ps.ToString(DECIMAL)
                    + "\t" + weight.ToString(DECIMAL)
                    );
                return ps;
            }

            public double EstimateSampleRateApp4(StreamWriter wt, string confidence, ref double weight, double c, double u, double r, double n, double su)
            {
                double ps = 0.5;
                if (c - u < 0.01)
                    weight = 1e-10;
                else
                {
                    double a = (r + 1) / (n + 2);
                    double lna = Math.Log(a), lnma = Math.Log(1 - a);
                    double ps1 = 0, ps2 = 0;
                    double p = (r / n - u) / (c - u + DUNDERFLOW);
                    for (int r2 = 0; r2 <= n; ++r2)
                    {
                        double prob = Math.Exp(BinomialLn(n, r2) + r2 * lna + (n - r2) * lnma);
                        double p2 = (r2 / n - u) / (c - u + DUNDERFLOW);
                        double v = r2 / n < u ? 0 : (r2 / n > c ? 1 : (su > 0.99 ? p2 : (su - Math.Sqrt(su * su + 4 * p2 - 4 * su * p2)) / (2 * su - 2)));
                        ps1 += v * prob;
                        ps2 += v * v * prob;
                    }
                    weight = 1.0 / (ps2 - ps1 * ps1);
                    ps = r / n < u ? 0 : (r / n > c ? 1 : (su > 0.99 ? p : (su - Math.Sqrt(su * su + 4 * p - 4 * su * p)) / (2 * su - 2)));
                }

                wt.WriteLine("\t" + confidence
                    + "\t" + c.ToString(DECIMAL)
                    + "\t" + u.ToString(DECIMAL)
                    + "\t" + r.ToString("F0")
                    + "\t" + n.ToString("F0")
                    + "\t" + ps.ToString(DECIMAL)
                    + "\t" + weight.ToString(DECIMAL)
                    );

                return ps;
            }

            public double EstimateSampleRate(StreamWriter wt, ref double su,
                ParentageSimResultEntry[] sim_res1, ParentageSimResultEntry[] sim_res2, ParentageSimResultEntry[] sim_res3, 
                ParentageSimResultEntry[] sim_res3f, ParentageSimResultEntry[] sim_res3m, ParentageSimResultEntry[] sim_res4,
                List<ParentageAnalysisResultEntry>[] ana_resPA, List<ParentageAnalysisResultEntry>[] ana_resPP, List<ParentageAnalysisResultEntry>[] ana_resUS)
            {
                Progress = "Estimating sample rate";

                if (PARENTAGE_SKIPSIM)
                {
                    wt.Write("The estimation of sample rate requires to perform simulation. ");
                    return 0;
                }

                double tps99 = 0, tw99 = 0, tps95 = 0, tw95 = 0, tps80 = 0, tw80 = 0;

                if (PARENTAGE_PATERNITY && ana_resPA != null && ana_resPA.Length > 0)
                {
                    double n1 = ana_resPA.Count(r => r[0].mid == ""), n2 = ana_resPA.Count(r => r[0].mid != ""), n5 = 0, n6 = 0;
                    if (n1 > 0)
                    {
                        n5 = sim_res1.Count(r => r.state == ParentageSimResult.S1_Success || r.state == ParentageSimResult.S1_Fail_ParentSampled);
                        n6 = sim_res1.Count(r => r.state == ParentageSimResult.S1_Fail_ParentUnsampled);
                        wt.WriteLine("\r\nEstimate sample rate in paternity analyse (father only)");
                        wt.WriteLine("\tConfidence Level\tac\tau\tna\tnc\tps\tweight");

                        double w_99 = 0, w_95 = 0, w_80 = 0, ps_99 = 0, ps_95 = 0, ps_80 = 0;

                        ps_99 = EstimateSampleRateApp12(wt, "99%", ref w_99,
                                sim_res1.Count(r => (r.state == ParentageSimResult.S1_Success || r.state == ParentageSimResult.S1_Fail_ParentSampled) && r.delta > d1_99) / n5,
                                sim_res1.Count(r => r.state == ParentageSimResult.S1_Fail_ParentUnsampled && r.delta > d1_99) / n6,
                                ana_resPA.Count(r => r[0].fodelta > d1_99 && r[0].mid == ""), n1);
                        ps_95 = EstimateSampleRateApp12(wt, "95%", ref w_95,
                                sim_res1.Count(r => (r.state == ParentageSimResult.S1_Success || r.state == ParentageSimResult.S1_Fail_ParentSampled) && r.delta > d1_95) / n5,
                                sim_res1.Count(r => r.state == ParentageSimResult.S1_Fail_ParentUnsampled && r.delta > d1_95) / n6,
                                ana_resPA.Count(r => r[0].fodelta > d1_95 && r[0].mid == ""), n1);
                        ps_80 = EstimateSampleRateApp12(wt, "80%", ref w_80,
                                sim_res1.Count(r => (r.state == ParentageSimResult.S1_Success || r.state == ParentageSimResult.S1_Fail_ParentSampled) && r.delta > d1_80) / n5,
                                sim_res1.Count(r => r.state == ParentageSimResult.S1_Fail_ParentUnsampled && r.delta > d1_80) / n6,
                                ana_resPA.Count(r => r[0].fodelta > d1_80 && r[0].mid == ""), n1);

                        wt.WriteLine("\tWeighted average of sample rate: " + ((ps_99 * w_99 + ps_95 * w_95 + ps_80 * w_80) / (w_99 + w_95 + w_80)).ToString(DECIMAL));
                        wt.WriteLine("\tWeight: " + (w_99 + w_95 + w_80).ToString(DECIMAL));

                        tps99 += ps_99 * w_99; tw99 += w_99;
                        tps95 += ps_95 * w_95; tw95 += w_95;
                        tps80 += ps_80 * w_80; tw80 += w_80;
                    }

                    if (n2 > 0)
                    {
                        n5 = sim_res2.Count(r => r.state == ParentageSimResult.S2_Success || r.state == ParentageSimResult.S2_Fail_ParentSampled);
                        n6 = sim_res2.Count(r => r.state == ParentageSimResult.S2_Fail_ParentUnsampled);
                        wt.WriteLine("\r\nEstimate sample rate in paternity analyse (mother known)");
                        wt.WriteLine("\tConfidence Level\tac\tau\tna\tnc\tps\tweight");

                        double w_99 = 0, w_95 = 0, w_80 = 0, ps_99 = 0, ps_95 = 0, ps_80 = 0;

                        ps_99 = EstimateSampleRateApp12(wt, "99%", ref w_99,
                                sim_res2.Count(r => (r.state == ParentageSimResult.S2_Success || r.state == ParentageSimResult.S2_Fail_ParentSampled) && r.delta > d2_99) / n5,
                                sim_res2.Count(r => r.state == ParentageSimResult.S2_Fail_ParentUnsampled && r.delta > d2_99) / n6,
                                ana_resPA.Count(r => r[0].fmodelta > d2_99 && r[0].mid != ""), n2);
                        ps_95 = EstimateSampleRateApp12(wt, "95%", ref w_95,
                                sim_res2.Count(r => (r.state == ParentageSimResult.S2_Success || r.state == ParentageSimResult.S2_Fail_ParentSampled) && r.delta > d2_95) / n5,
                                sim_res2.Count(r => r.state == ParentageSimResult.S2_Fail_ParentUnsampled && r.delta > d2_95) / n6,
                                ana_resPA.Count(r => r[0].fmodelta > d2_95 && r[0].mid != ""), n2);
                        ps_80 = EstimateSampleRateApp12(wt, "80%", ref w_80,
                                sim_res2.Count(r => (r.state == ParentageSimResult.S2_Success || r.state == ParentageSimResult.S2_Fail_ParentSampled) && r.delta > d2_80) / n5,
                                sim_res2.Count(r => r.state == ParentageSimResult.S2_Fail_ParentUnsampled && r.delta > d2_80) / n6,
                                ana_resPA.Count(r => r[0].fmodelta > d2_80 && r[0].mid != ""), n2);

                        wt.WriteLine("\tWeighted average of sample rate: " + ((ps_99 * w_99 + ps_95 * w_95 + ps_80 * w_80) / (w_99 + w_95 + w_80)).ToString(DECIMAL));
                        wt.WriteLine("\tWeight: " + (w_99 + w_95 + w_80).ToString(DECIMAL));

                        tps99 += ps_99 * w_99; tw99 += w_99;
                        tps95 += ps_95 * w_95; tw95 += w_95;
                        tps80 += ps_80 * w_80; tw80 += w_80;
                    }
                }

                if (PARENTAGE_PARENTPAIR && ana_resPP != null && ana_resPP.Length > 0)
                {
                    double n3 = ana_resPP.Length, n5 = 0, n6 = 0;
                    if (n3 > 0)
                    {
                        n5 = sim_res3.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled));
                        n6 = sim_res3.Count(r => (r.state == ParentageSimResult.S3_Fail_PairUnsampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled));
                        wt.WriteLine("\r\nEstimate sample rate in parent-pair analyse (sexes known)");
                        wt.WriteLine("\tConfidence Level\tac\tau\tna\tnc\tps\tweight");

                        double w_99 = 0, w_95 = 0, w_80 = 0, ps_99 = 0, ps_95 = 0, ps_80 = 0;

                        ps_99 = EstimateSampleRateApp3(wt, "99%", ref w_99,
                                sim_res3.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled) && r.delta > dP_99) / n5,
                                sim_res3.Count(r => (r.state == ParentageSimResult.S3_Fail_PairUnsampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled) && r.delta > dP_99) / n6,
                                ana_resPP.Count(r => r[0].fmodelta > dP_99), n3);
                        ps_95 = EstimateSampleRateApp3(wt, "95%", ref w_95,
                                sim_res3.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled) && r.delta > dP_95) / n5,
                                sim_res3.Count(r => (r.state == ParentageSimResult.S3_Fail_PairUnsampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled) && r.delta > dP_95) / n6,
                                ana_resPP.Count(r => r[0].fmodelta > dP_95), n3);
                        ps_80 = EstimateSampleRateApp3(wt, "80%", ref w_80,
                                sim_res3.Count(r => (r.state == ParentageSimResult.S3_Success || r.state == ParentageSimResult.S3_Fail_PairSampled) && r.delta > dP_80) / n5,
                                sim_res3.Count(r => (r.state == ParentageSimResult.S3_Fail_PairUnsampled || r.state == ParentageSimResult.S3_Fail_FatherUnsampled || r.state == ParentageSimResult.S3_Fail_MotherUnsampled) && r.delta > dP_80) / n6,
                                ana_resPP.Count(r => r[0].fmodelta > dP_80), n3);

                        wt.WriteLine("\tWeighted average of sample rate: " + ((ps_99 * w_99 + ps_95 * w_95 + ps_80 * w_80) / (w_99 + w_95 + w_80)).ToString(DECIMAL));
                        wt.WriteLine("\tWeight: " + (w_99 + w_95 + w_80).ToString(DECIMAL));

                        tps99 += ps_99 * w_99; tw99 += w_99;
                        tps95 += ps_95 * w_95; tw95 += w_95;
                        tps80 += ps_80 * w_80; tw80 += w_80;
                    }
                }

                if (PARENTAGE_UNKNOWN && ana_resUS != null && ana_resUS.Length > 0)
                {
                    double n4 = ana_resUS.Length, n5 = 0, n6 = 0;
                    if (n4 > 0)
                    {
                        n5 = sim_res4.Count(r => (r.state == ParentageSimResult.S4_Success || r.state == ParentageSimResult.S4_Fail_PairSampled));
                        n6 = sim_res4.Count(r => (r.state == ParentageSimResult.S4_Fail_PairUnsampled || r.state == ParentageSimResult.S4_Fail_OneSampled));

                        int na99 = ana_resUS.Count(r => r[0].fmodelta > dPU_99);
                        int na95 = ana_resUS.Count(r => r[0].fmodelta > dPU_95);
                        int na80 = ana_resUS.Count(r => r[0].fmodelta > dPU_80);
                        int ns99 = ana_resUS.Count(r => r[0].fmodelta > dPU_99 && r[0].fid == r[0].mid);
                        int ns95 = ana_resUS.Count(r => r[0].fmodelta > dPU_95 && r[0].fid == r[0].mid);
                        int ns80 = ana_resUS.Count(r => r[0].fmodelta > dPU_80 && r[0].fid == r[0].mid);
                        su = (ns99 + ns95 + ns80) / (na99 + na95 + na80 + DUNDERFLOW);

                        wt.WriteLine("\r\nEstimate sample rate in parent-pair analyse (sexes unknown)");
                        wt.WriteLine("\tConfidence Level\tns\tnc");
                        wt.WriteLine("\t99%\t" + ns99 + "\t" + na99);
                        wt.WriteLine("\t95%\t" + ns95 + "\t" + na95);
                        wt.WriteLine("\t80%\t" + ns80 + "\t" + na80);
                        wt.WriteLine("\tsu: " + su.ToString(DECIMAL));

                        wt.WriteLine("\tConfidence Level\tac\tau\tna\tnc\tps\tweight");
                        double w_99 = 0, w_95 = 0, w_80 = 0, ps_99 = 0, ps_95 = 0, ps_80 = 0;

                        ps_99 = EstimateSampleRateApp4(wt, "99%", ref w_99,
                                sim_res4.Count(r => (r.state == ParentageSimResult.S4_Success || r.state == ParentageSimResult.S4_Fail_PairSampled) && r.delta > dPU_99) / n5,
                                sim_res4.Count(r => (r.state == ParentageSimResult.S4_Fail_PairUnsampled || r.state == ParentageSimResult.S4_Fail_OneSampled) && r.delta > dPU_99) / n6,
                                na99, n4, su);
                        ps_95 = EstimateSampleRateApp4(wt, "95%", ref w_95,
                                sim_res4.Count(r => (r.state == ParentageSimResult.S4_Success || r.state == ParentageSimResult.S4_Fail_PairSampled) && r.delta > dPU_95) / n5,
                                sim_res4.Count(r => (r.state == ParentageSimResult.S4_Fail_PairUnsampled || r.state == ParentageSimResult.S4_Fail_OneSampled) && r.delta > dPU_95) / n6,
                                na95, n4, su);
                        ps_80 = EstimateSampleRateApp4(wt, "80%", ref w_80,
                                sim_res4.Count(r => (r.state == ParentageSimResult.S4_Success || r.state == ParentageSimResult.S4_Fail_PairSampled) && r.delta > dPU_80) / n5,
                                sim_res4.Count(r => (r.state == ParentageSimResult.S4_Fail_PairUnsampled || r.state == ParentageSimResult.S4_Fail_OneSampled) && r.delta > dPU_80) / n6,
                                na80, n4, su);

                        wt.WriteLine("\tWeighted average of sample rate: " + ((ps_99 * w_99 + ps_95 * w_95 + ps_80 * w_80) / (w_99 + w_95 + w_80)).ToString(DECIMAL));
                        wt.WriteLine("\tWeight: " + (w_99 + w_95 + w_80).ToString(DECIMAL));

                        tps99 += ps_99 * w_99; tw99 += w_99;
                        tps95 += ps_95 * w_95; tw95 += w_95;
                        tps80 += ps_80 * w_80; tw80 += w_80;
                    }
                }

                wt.WriteLine("\r\nEstimate sample rate in all applications");
                wt.WriteLine("\tConfidence Level\tps\tweight");
                wt.WriteLine("\t99%\t" + (tps99 / tw99).ToString(DECIMAL) + "\t" + tw99.ToString(DECIMAL));
                wt.WriteLine("\t95%\t" + (tps95 / tw95).ToString(DECIMAL) + "\t" + tw95.ToString(DECIMAL));
                wt.WriteLine("\t80%\t" + (tps80 / tw80).ToString(DECIMAL) + "\t" + tw80.ToString(DECIMAL));
                wt.WriteLine("\tWeighted average of sample rate: " + ((tps99 + tps95 + tps80) / (tw99 + tw95 + tw80)).ToString(DECIMAL));
                wt.WriteLine("\tWeight: " + (tw99 + tw95 + tw80).ToString(DECIMAL));

                return (tps99 + tps95 + tps80) / (tw99 + tw95 + tw80);
            }

            public void CalcParentage()
            {
                ParentageSimResultEntry[] sim_res1 = null, sim_res2 = null, sim_res3 = null, sim_res3f = null, sim_res3m = null, sim_res4 = null;
                ParentageLodStructEntry sim_lod1 = null, sim_lod2 = null, sim_lod3 = null, sim_lod3f = null, sim_lod3m = null, sim_lod4 = null;
                List<ParentageAnalysisResultEntry>[] ana_resPA = null, ana_resPP = null, ana_resUS = null;

                //1. check individual ploidy
                int def_ploidy = inds.Max(i => i.ploidy), min_ploidy = inds.Min(i => i.ploidy);

                //2. Prepare Genotype Generator
                Progress = "Preparing genotype generator";
                ProgressValue = 0;
                foreach (LOC l in total_pop.loc)
                    ProgressMax += (int)Binomial(def_ploidy + l.freq.Count - 1, def_ploidy);
                SetProgress(ProgressValue, ProgressMax);

                foreach (LOC l in total_pop.loc)
                    l.Generator(def_ploidy, ALPHA[l.id, def_ploidy]);

                LOD2 = new ConcurrentDictionary<ulong, double>[L];
                LOD3 = new ConcurrentDictionary<ulong, double>[L];
                LOD4 = new ConcurrentDictionary<ulong, double>[L];
                T1D = new ConcurrentDictionary<ulong, double>[L];
                T2D = new ConcurrentDictionary<ulong, double>[L];
                for (int i = 0; i < L; ++i)
                {
                    LOD2[i] = new ConcurrentDictionary<ulong, double>();
                    LOD3[i] = new ConcurrentDictionary<ulong, double>();
                    LOD4[i] = new ConcurrentDictionary<ulong, double>();
                    T1D[i] = new ConcurrentDictionary<ulong, double>();
                    T2D[i] = new ConcurrentDictionary<ulong, double>();
                }

                bool restartflag = false;
                restart:

                //3. Perform simulation
                if (PARENTAGE_METHOD == ParentageMethod.Exclusion)
                {
                    SetDecimal(form1.D1_999, d1_999 = 1);
                    SetDecimal(form1.D1_99, d1_99 = 1);
                    SetDecimal(form1.D1_95, d1_95 = 1);
                    SetDecimal(form1.D1_80, d1_80 = 1);

                    SetDecimal(form1.D2_999, d2_999 = 1);
                    SetDecimal(form1.D2_99, d2_99 = 1);
                    SetDecimal(form1.D2_95, d2_95 = 1);
                    SetDecimal(form1.D2_80, d2_80 = 1);

                    SetDecimal(form1.DP_999, dP_999 = 1);
                    SetDecimal(form1.DP_99, dP_99 = 1);
                    SetDecimal(form1.DP_95, dP_95 = 1);
                    SetDecimal(form1.DP_80, dP_80 = 1);

                    SetDecimal(form1.DPF_999, dPF_999 = 1);
                    SetDecimal(form1.DPF_99, dPF_99 = 1);
                    SetDecimal(form1.DPF_95, dPF_95 = 1);
                    SetDecimal(form1.DPF_80, dPF_80 = 1);

                    SetDecimal(form1.DPM_999, dPM_999 = 1);
                    SetDecimal(form1.DPM_99, dPM_99 = 1);
                    SetDecimal(form1.DPM_95, dPM_95 = 1);
                    SetDecimal(form1.DPM_80, dPM_80 = 1);

                    SetDecimal(form1.DPU_999, dPU_999 = 1);
                    SetDecimal(form1.DPU_99, dPU_99 = 1);
                    SetDecimal(form1.DPU_95, dPU_95 = 1);
                    SetDecimal(form1.DPU_80, dPU_80 = 1);
                }
                else if (!PARENTAGE_SKIPSIM) //Whether to Skip Simulation
                {
                    ploidy_sim = def_ploidy;

                    ParentageLodPercentileEntry dist1 = new ParentageLodPercentileEntry(N_THREAD), dist2 = new ParentageLodPercentileEntry(N_THREAD), dist3 = new ParentageLodPercentileEntry(N_THREAD), dist3f = new ParentageLodPercentileEntry(N_THREAD), dist3m = new ParentageLodPercentileEntry(N_THREAD), dist4 = new ParentageLodPercentileEntry(N_THREAD);

                    if (PARENTAGE_PATERNITY)
                    {
                        //PARENTAGE_PATERNITY
                        //Prepare simulation
                        d1_999 = d1_99 = d1_95 = d1_80 =
                            d2_999 = d2_99 = d2_95 = d2_80 = 999;
                        sim_res1 = new ParentageSimResultEntry[PARENTAGE_NSIM];
                        sim_res2 = new ParentageSimResultEntry[PARENTAGE_NSIM];
                        sim_lod1 = new ParentageLodStructEntry();
                        sim_lod2 = new ParentageLodStructEntry();

                        //Add thread
                        Progress = "Simulating paternity";
                        ProgressValue = 0;
                        ProgressMax = PARENTAGE_NSIM;
                        SetProgress(ProgressValue, ProgressMax);

                        CallThread(SimulatePaternityThread, N_THREAD,
                                   new object[] { def_ploidy, sim_res1, sim_res2, sim_lod1, sim_lod2, dist1, dist2 },
                                   PARENTAGE_NSIM, ref ProgressValue);
                    }

                    if (PARENTAGE_PARENTPAIR)
                    {
                        //PARENTAGE_PARENTPAIR
                        //Prepare simulation
                        dP_999 = dP_99 = dP_95 = dP_80 =
                        dPF_999 = dPF_99 = dPF_95 = dPF_80 =
                        dPM_999 = dPM_99 = dPM_95 = dPM_80 = 999;

                        sim_res3 = new ParentageSimResultEntry[PARENTAGE_NSIM];
                        sim_res3f = new ParentageSimResultEntry[PARENTAGE_NSIM];
                        sim_res3m = new ParentageSimResultEntry[PARENTAGE_NSIM];
                        sim_lod3 = new ParentageLodStructEntry();
                        sim_lod3f = new ParentageLodStructEntry();
                        sim_lod3m = new ParentageLodStructEntry();

                        //Add thread
                        Progress = "Simulating parent pair";
                        ProgressValue = 0;
                        ProgressMax = PARENTAGE_NSIM;
                        SetProgress(ProgressValue, ProgressMax);

                        CallThread(SimulateParentPairThread, N_THREAD,
                                   new object[] { def_ploidy, sim_res3, sim_res3f, sim_res3m, sim_lod3, sim_lod3f, sim_lod3m, dist3, dist3f, dist3m },
                                   PARENTAGE_NSIM, ref ProgressValue);
                    }

                    if (PARENTAGE_UNKNOWN)
                    {
                        //PARENTAGE_PARENTPAIR Sexes Unknown
                        dPU_999 = dPU_99 = dPU_95 = dPU_80 = 999;
                        sim_res4 = new ParentageSimResultEntry[PARENTAGE_NSIM];
                        sim_lod4 = new ParentageLodStructEntry();

                        //Add thread
                        Progress = "Simulating parent pair (unknown sexes)";
                        ProgressValue = 0;
                        ProgressMax = PARENTAGE_NSIM;
                        SetProgress(ProgressValue, ProgressMax);

                        CallThread(SimulateUnknownThread, N_THREAD,
                                   new object[] { def_ploidy, sim_res4, sim_lod4, dist4 },
                                   PARENTAGE_NSIM, ref ProgressValue);
                    }

                    //wait until end
                    SimulateEnd(sim_res1, sim_res2, sim_res3, sim_res3f, sim_res3m, sim_res4,
                                sim_lod1, sim_lod2, sim_lod3, sim_lod3f, sim_lod3m, sim_lod4,
                                dist1, dist2, dist3, dist3f, dist3m, dist4);
                }

                //Analyze
                if (PARENTAGE_PATERNITY)
                {
                    //PARENTAGE_PATERNITY
                    int noffspring = PATERNITY_OFFSPRING.Length;
                    ana_resPA = new List<ParentageAnalysisResultEntry>[noffspring];

                    //Add thread
                    Progress = "Analyzing paternity";
                    ProgressValue = 0;
                    ProgressMax = noffspring;
                    SetProgress(ProgressValue, ProgressMax);

                    AnalysisStartPaternity();
                    CallThread(AnalysisPaternityThread, N_THREAD,
                               new object[] { def_ploidy, noffspring, ana_resPA },
                               noffspring, ref ProgressValue);
                    AnalysisEndPaternity(ana_resPA);
                }

                if (PARENTAGE_PARENTPAIR)
                {
                    //Parent Pair
                    int noffspring = PARENTPAIR_OFFSPRING.Length;
                    ana_resPP = new List<ParentageAnalysisResultEntry>[noffspring];

                    //Add thread
                    Progress = "Analyzing parent pair";
                    ProgressValue = 0;
                    ProgressMax = noffspring;
                    SetProgress(ProgressValue, ProgressMax);

                    AnalysisStartParentPair();
                    CallThread(AnalysisParentPairThread, N_THREAD,
                               new object[] { def_ploidy, noffspring, ana_resPP },
                               noffspring, ref ProgressValue);
                    AnalysisEndParentPair(ana_resPP);
                }

                if (PARENTAGE_UNKNOWN)
                {
                    //Parent Pair
                    int noffspring = UNKNOWN_OFFSPRING.Length;
                    ana_resUS = new List<ParentageAnalysisResultEntry>[noffspring];

                    //Add thread
                    Progress = "Analyzing parent pair (unknown sexes)";
                    ProgressValue = 0;
                    ProgressMax = noffspring;
                    SetProgress(ProgressValue, ProgressMax);

                    AnalysisStartUnknown();
                    CallThread(AnalysisUnknownThread, N_THREAD, 
                               new object[] { def_ploidy, noffspring, ana_resUS },
                               noffspring, ref ProgressValue);
                    AnalysisEndUnknown(ana_resUS);
                }

                double este = PARENTAGE_MISTYPE_RATE;
                if (PARENTAGE_METHOD == ParentageMethod.Pheno && PARENTAGE_ESTERR != ParentageEstimateError.NotDone && !restartflag)
                {
                    StreamWriter wt = new StreamWriter(new FileStream("o_parentage_error.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                    OUTPUT_PARENTAGE_ERROR = wt;

                    int n1 = ana_resPA == null || ana_resPA.Length == 0 ? 0 : ana_resPA.Count(r => r[0].mid == "");
                    int n2 = ana_resPA == null || ana_resPA.Length == 0 ? 0 : ana_resPA.Count(r => r[0].mid != "");
                    int n3 = ana_resPP == null ? 0 : ana_resPP.Length;
                    int n4 = ana_resUS == null ? 0 : ana_resUS.Length;

                    double w1 = 0, w2 = 0, e1 = 0, e2 = 0, ew = 0, pw = 0;

                    if (n1 > 0)
                    {
                        ew += w1 * EstimateErrorRatePair(wt, "Estimate error rate by pair mismatch in paternity analyse (father only)", true, false, false, false, ref w1, ana_resPA, ana_resPP, ana_resUS);
                        pw += w1;
                    }

                    if (n2 > 0)
                    {
                        e1 = EstimateErrorRatePair(wt, "Estimate error rate by pair mismatch in paternity analyse (mother known)", false, true, false, false, ref w1, ana_resPA, ana_resPP, ana_resUS);
                        e2 = EstimateErrorRateTrio(wt, "Estimate error rate by trio mismatch in paternity analyse (mother known)", true, false, false, ref w2, ana_resPA, ana_resPP, ana_resUS);
                        ew += e1 * w1 + e2 * w2;
                        pw += w1 + w2;
                    }

                    if (n3 > 0)
                    {
                        e1 = EstimateErrorRatePair(wt, "Estimate error rate by pair mismatch in parent-pair analyse (sexes known)", false, false, true, false, ref w1, ana_resPA, ana_resPP, ana_resUS);
                        e2 = EstimateErrorRateTrio(wt, "Estimate error rate by trio mismatch in parent-pair analyse (sexes known)", false, true, false, ref w2, ana_resPA, ana_resPP, ana_resUS);
                        ew += e1 * w1 + e2 * w2;
                        pw += w1 + w2;
                    }

                    if (n4 > 0)
                    {
                        e1 = EstimateErrorRatePair(wt, "Estimate error rate by pair mismatch in parent-pair analyse (sexes unknown)", false, false, false, true, ref w1, ana_resPA, ana_resPP, ana_resUS);
                        e2 = EstimateErrorRateTrio(wt, "Estimate error rate by pair mismatch in parent-pair analyse (sexes unknown)", false, false, true, ref w2, ana_resPA, ana_resPP, ana_resUS);
                        ew += e1 * w1 + e2 * w2;
                        pw += w1 + w2;
                    }

                    este = pw == 0 ? PARENTAGE_MISTYPE_RATE : ew / pw;

                    wt.WriteLine("Estimated genotyping error rate in all applications: " + (ew / pw).ToString(DECIMAL));
                    wt.WriteLine("Weight of genotyping error rate in all applications: " + pw.ToString(DECIMAL));
                    wt.Flush();
                    wt.Close();
                }

                if (PARENTAGE_METHOD == ParentageMethod.Pheno && PARENTAGE_ESTSR)
                {
                    StreamWriter sr = new StreamWriter(new FileStream("o_parentage_sample.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                    OUTPUT_PARENTAGE_SAMPLERATE = sr;

                    double su = 0;
                    if (PARENTAGE_REDO && !restartflag)
                    {
                        PARENTAGE_MISTYPE_RATE = este;
                        PARENTAGE_SAMPLING_RATE = EstimateSampleRate(sr, ref su, sim_res1, sim_res2, sim_res3, sim_res3f, sim_res3m, sim_res4, ana_resPP, ana_resPA, ana_resUS);
                        foreach (var l in total_pop.loc)
                            l.s = su;
                        restartflag = true;
                        sr.Flush();
                        sr.Close();
                        goto restart;
                    }

                    if (restartflag) sr.WriteLine("Simulations and analyses are reperofrmed!");
                    sr.WriteLine("Prior genotyping error rate: " + PARENTAGE_MISTYPE_RATE.ToString(DECIMAL));
                    sr.WriteLine("Prior sample rate: " + PARENTAGE_SAMPLING_RATE.ToString(DECIMAL));
                    sr.WriteLine("Prior selfing rate: " + total_pop.loc[0].s.ToString(DECIMAL));
                    sr.WriteLine("");
                    EstimateSampleRate(sr, ref su, sim_res1, sim_res2, sim_res3, sim_res3f, sim_res3m, sim_res4, ana_resPP, ana_resPA, ana_resUS);
                    sr.Flush();
                    sr.Close();
                }

            }
            #endregion

            #region AMOVA
            /*
            public class RNG
            {
	            private uint x;
                private uint y;
                private uint z;
                private uint seed;
                private double U1, U2;
                private bool state;

                public RNG()
                {

                }

                public RNG(uint s)
                {
                    seed = s;
                    state = false;
                    x = 123456789 ^ seed;
                    y = 362436069 ^ (seed << 6);
                    z = 521288629 ^ (seed << 12);
                }


                public uint XorShift96()
                {
                    uint t;
                    x ^= x << 16;
                    x ^= x >> 5;
                    x ^= x << 1;
                    t = x;

                    x = y;
                    y = z;
                    z = t ^ x ^ y;
                    return z;
                }


                public void GetRandSeq(int[] td, int n)
                {
                    for (int i = 0; i < n; ++i)
                        td[i] = (int)((XorShift96() << 16) | i);
                    Array.Sort(td);
                    for (int i = 0; i < n; ++i)
                        td[i] &= 0xFFFF;
                }

                public void Permute<T>(IList<T> val)
                {
                    for (int i = val.Count; i > 1; --i)
                    {
                        int rd = Next(i);
                        T t = val[i - 1];
                        val[i - 1] = val[rd];
                        val[rd] = t;
                    }
                }

                public int Next(int min, int max)
                {
                    // will not equal to max
                    return (int)((XorShift96() + min) % (max - min));
                }

                public int Next(int max)
                {
                    // will not equal to max
                    return (int)(XorShift96() % max);
                }
            }
            */

            public double[,] amova_F1, amova_F2;
            public double[,] amova_F1sq, amova_F2sq;
            public double[,] amova_cF1, amova_cF2;
            public double[,] amova_eF1, amova_eF2;

            public static void SubSqAmova(double[,] sum, double[,] val)
            {
                int m = sum.GetLength(0), n = sum.GetLength(1);
                for (int i = 0; i < m; ++i)
                    for (int j = i + 1; j < n; ++j)
                        sum[i, j] -= val[i, j] * val[i, j];
            }

            public static void SubSqAmova(double[] sum, double[] val)
            {
                int m = sum.Length;
                for (int i = 0; i < m; ++i)
                    sum[i] -= val[i] * val[i];
            }

            public static void AddAmova(double[,] sum, double[,] val)
            {
                int m = sum.GetLength(0), n = sum.GetLength(1);
                for (int i = 0; i < m; ++i)
                    for (int j = i + 1; j < n; ++j)
                        sum[i, j] += val[i, j];
            }

            public static void AddAmova(double[] sum, double[] val)
            {
                int m = sum.Length;
                for (int i = 0; i < m; ++i)
                    sum[i] += val[i];
            }

            public static void AddSq(double[,] sum, double[,] val)
            {
                int m = sum.GetLength(0), n = sum.GetLength(1);
                for (int i = 0; i < m; ++i)
                    for (int j = i + 1; j < n; ++j)
                        sum[i, j] += val[i, j] * val[i, j];
            }

            public static void AddSq(double[] sum, double[] val)
            {
                int m = sum.Length;
                for (int i = 0; i < m; ++i)
                    sum[i] += val[i] * val[i];
            }

            public static void MulAmova(double[,] sum, double val)
            {
                int m = sum.GetLength(0), n = sum.GetLength(1);
                for (int i = 0; i < m; ++i)
                    for (int j = i + 1; j < n; ++j)
                        sum[i, j] *= val;
            }

            public static void MulAmova(double[] sum, double val)
            {
                int m = sum.Length;
                for (int i = 0; i < m; ++i)
                    sum[i] *= val;
            }

            public static void CountGreater(double[,] count, double[,] oval, double[,] nval)
            {
                int m = count.GetLength(0), n = count.GetLength(1);
                for (int i = 0; i < m; ++i)
                    for (int j = i + 1; j < n; ++j)
                        if (oval[i, j] < nval[i, j])
                            count[i, j]++;
            }

            public static void CountGreater(double[] count, double[] oval, double[] nval)
            {
                int m = count.Length;
                for (int i = 0; i < m; ++i)
                    if (oval[i] < nval[i])
                        count[i]++;
            }

            public void AMOVAThreadHomo(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                VESSEL _vs = (VESSEL)((object[])obj)[2];
                double[,] oF1 = (double[,])((object[])obj)[3];
                double[,] oF2 = (double[,])((object[])obj)[4];

                double[,] C = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[] tw = new double[AMOVA_NLAY + 1];
                int[] tid = new int[AMOVA_NLAY + 1];
                double[] SS1 = new double[AMOVA_NLAY], SS2 = new double[AMOVA_NLAY];
                double[,] F1 = new double[AMOVA_NLAY, AMOVA_NLAY], F2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[] vs1 = new double[AMOVA_NLAY], vs2 = new double[AMOVA_NLAY];
                double[] V1 = null, V2 = null;
                double VTOT1 = 0, VTOT2 = 0;

                double[,] sum_F1 = new double[AMOVA_NLAY, AMOVA_NLAY], sum_F2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_F1sq = new double[AMOVA_NLAY, AMOVA_NLAY], sum_F2sq = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_cF1 = new double[AMOVA_NLAY, AMOVA_NLAY], sum_cF2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_eF1 = new double[AMOVA_NLAY, AMOVA_NLAY], sum_eF2 = new double[AMOVA_NLAY, AMOVA_NLAY];

                //Permute
                Random rnd = new Random(SEED ^ (id + 0x477CACD4));//buf fixed on 20220324
                for (int fa = 1; fa <= AMOVA_NLAY; ++fa)
                {
                    for (int fb = fa + 1; fb <= AMOVA_NLAY; ++fb)
                    {
                        //Copy vessels
                        VESSEL vs = new VESSEL(_vs);
                        vs.InitW();
                        VESSEL.InitC(C, tid, AMOVA_NH);
                        vs.GetC(tw, tid, C, -1);
                        for (int m = id; m < AMOVA_PERMUTE; m += nthreads)
                        {
                            //RNG rng = new RNG((uint)m);
                            //permute a-1 among a within b

                            vs.Shuffle(rnd, fa, fb, 1, null);

                            //Get Coefficient
                            vs.GetSSHomo(SS1, SS2);
                            VESSEL.GetV(C, SS1, SS2, ref V1, ref V2);
                            VESSEL.GetF(V1, V2, ref VTOT1, ref VTOT2, F1, F2, vs1, vs2);

                            if (AMOVA_IAM)
                            {
                                sum_F1[fa - 1, fb - 1] += F1[fa - 1, fb - 1];
                                sum_F1sq[fa - 1, fb - 1] += F1[fa - 1, fb - 1] * F1[fa - 1, fb - 1];
                                if (F1[fa - 1, fb - 1] > oF1[fa - 1, fb - 1] + 1e-7) sum_cF1[fa - 1, fb - 1]++;
                                else if (F1[fa - 1, fb - 1] > oF1[fa - 1, fb - 1] - 1e-7) sum_eF1[fa - 1, fb - 1]++;
                            }
                            if (AMOVA_SMM)
                            {
                                sum_F2[fa - 1, fb - 1] += F2[fa - 1, fb - 1];
                                sum_F2sq[fa - 1, fb - 1] += F2[fa - 1, fb - 1] * F2[fa - 1, fb - 1];
                                if (F2[fa - 1, fb - 1] > oF2[fa - 1, fb - 1] + 1e-7) sum_cF2[fa - 1, fb - 1]++;
                                else if (F2[fa - 1, fb - 1] > oF2[fa - 1, fb - 1] - 1e-7) sum_eF2[fa - 1, fb - 1]++;
                            }
                            Increment();
                        }
                    }
                }

                if (AMOVA_IAM)
                {
                    lock (amova_F1)
                    {
                        AddAmova(amova_F1, sum_F1);
                        AddAmova(amova_F1sq, sum_F1sq);
                        AddAmova(amova_cF1, sum_cF1);
                        AddAmova(amova_eF1, sum_eF1);
                    }
                }
                if (AMOVA_SMM)
                {
                    lock (amova_F2)
                    {
                        AddAmova(amova_F2, sum_F2);
                        AddAmova(amova_F2sq, sum_F2sq);
                        AddAmova(amova_cF2, sum_cF2);
                        AddAmova(amova_eF2, sum_eF2);
                    }
                }
            }

            public void AMOVAThreadAniso2(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                bool sumss = (bool)((object[])obj)[2];
                double[,] oF1 = (double[,])((object[])obj)[3];
                double[,] oF2 = (double[,])((object[])obj)[4];

                double[] V1 = new double[AMOVA_NLAY], V2 = new double[AMOVA_NLAY];
                double[] SS1 = new double[AMOVA_NLAY], SS2 = new double[AMOVA_NLAY];
                double[,] C = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[] vs1 = new double[AMOVA_NLAY], vs2 = new double[AMOVA_NLAY];
                double[,] F1 = new double[AMOVA_NLAY, AMOVA_NLAY], F2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_F1 = new double[AMOVA_NLAY, AMOVA_NLAY], sum_F2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_F1sq = new double[AMOVA_NLAY, AMOVA_NLAY], sum_F2sq = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_cF1 = new double[AMOVA_NLAY, AMOVA_NLAY], sum_cF2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_eF1 = new double[AMOVA_NLAY, AMOVA_NLAY], sum_eF2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double tr = AMOVA_PERMUTE / (double)nthreads + 1e-10;
                int nst = (int)(id * tr);
                int ned = (int)((id + 1) * tr);

                for (int fa = 1, id1 = 0; fa <= AMOVA_NLAY; ++fa)
                    for (int fb = fa + 1; fb <= AMOVA_NLAY; ++fb, ++id1)
                        for (int m = nst; m < ned; m++)
                        {
                            double VTOT1 = 0, VTOT2 = 0;
                            for (int i = 0; i < AMOVA_NLAY; ++i)
                            {
                                if (AMOVA_IAM)
                                {
                                    if (sumss) SS1[i] = AMOVA_SV1_ANISO[id1, m, i];
                                    else V1[i] = AMOVA_SV1_ANISO[id1, m, i];
                                }
                                if (sumss && AMOVA_SMM)
                                {
                                    if (sumss) SS2[i] = AMOVA_SV2_ANISO[id1, m, i];
                                    else V2[i] = AMOVA_SV2_ANISO[id1, m, i];
                                }
                                for (int j = 0; j <= i; ++j)
                                    C[i, j] = AMOVA_C_ANISO[id1, m, i, j];
                            }

                            if (sumss) VESSEL.GetV(C, SS1, SS2, ref V1, ref V2);
                            VESSEL.GetF(V1, V2, ref VTOT1, ref VTOT2, F1, F2, vs1, vs2);

                            if (AMOVA_IAM)
                            {
                                sum_F1[fa - 1, fb - 1] += F1[fa - 1, fb - 1];
                                sum_F1sq[fa - 1, fb - 1] += F1[fa - 1, fb - 1] * F1[fa - 1, fb - 1];
                                if (F1[fa - 1, fb - 1] > oF1[fa - 1, fb - 1] + 1e-7) sum_cF1[fa - 1, fb - 1]++;
                                else if (F1[fa - 1, fb - 1] > oF1[fa - 1, fb - 1] - 1e-7) sum_eF1[fa - 1, fb - 1]++;
                            }
                            if (AMOVA_SMM)
                            {
                                sum_F2[fa - 1, fb - 1] += F2[fa - 1, fb - 1];
                                sum_F2sq[fa - 1, fb - 1] += F2[fa - 1, fb - 1] * F2[fa - 1, fb - 1];
                                if (F2[fa - 1, fb - 1] > oF2[fa - 1, fb - 1] + 1e-7) sum_cF2[fa - 1, fb - 1]++;
                                else if (F2[fa - 1, fb - 1] > oF2[fa - 1, fb - 1] - 1e-7) sum_eF2[fa - 1, fb - 1]++;
                            }
                            Increment();
                        }

                if (AMOVA_IAM)
                {
                    lock (amova_F1)
                    {
                        AddAmova(amova_F1, sum_F1);
                        AddAmova(amova_F1sq, sum_F1sq);
                        AddAmova(amova_cF1, sum_cF1);
                        AddAmova(amova_eF1, sum_eF1);
                    }
                }
                if (AMOVA_SMM)
                {
                    lock (amova_F2)
                    {
                        AddAmova(amova_F2, sum_F2);
                        AddAmova(amova_F2sq, sum_F2sq);
                        AddAmova(amova_cF2, sum_cF2);
                        AddAmova(amova_eF2, sum_eF2);
                    }
                }
            }

            public void AMOVAThreadAniso(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                bool sumss = (bool)((object[])obj)[2];
                VESSEL _vs = (VESSEL)((object[])obj)[3];
                int l = (int)((object[])obj)[4];

                double tr = AMOVA_PERMUTE / (double)nthreads + 1e-10;
                int nst = (int)(id * tr);
                int ned = (int)((id + 1) * tr);

                Random rnd = new Random(SEED ^ (l + 0x2D9E19CD));//buf fixed on 20220324
                double[] ss1 = new double[AMOVA_NLAY], ss2 = new double[AMOVA_NLAY];
                double[] v1 = null, v2 = null;
                double[] tw = new double[AMOVA_NLAY + 1];
                int[] tid = new int[AMOVA_NLAY + 1];
                double[,] c = new double[AMOVA_NLAY, AMOVA_NLAY];

                //Permute
                for (int fa = 1, id1 = 0; fa <= AMOVA_NLAY; ++fa)
                    for (int fb = fa + 1; fb <= AMOVA_NLAY; ++fb, ++id1)
                    {
                        VESSEL vs = new VESSEL(_vs);
                        vs.InitW();

                        for (int m = nst; m < ned; ++m)
                        {
                            //RNG rng = new RNG((uint)((id1 * 2 * AMOVA_PERMUTE + l * AMOVA_PERMUTE + m)));//test

                            //permute a-1 among a within b
                            vs.Shuffle(rnd, fa, fb, 2, null);

                            VESSEL.InitC(c, tid, AMOVA_NH_ANISO[l]);
                            vs.GetC(tw, tid, c, -1);
                            vs.GetSSAniso(c, ss1, ss2, l);
                            Add(AMOVA_C_ANISO, AMOVA_C_ANISO, id1, m, c);

                            if (sumss)
                            {
                                if (AMOVA_IAM) Add(AMOVA_SV1_ANISO, AMOVA_SV1_ANISO, id1, m, ss1);
                                if (AMOVA_SMM) Add(AMOVA_SV2_ANISO, AMOVA_SV2_ANISO, id1, m, ss2);
                            }
                            else
                            {
                                //sum var
                                VESSEL.GetV(c, ss1, ss2, ref v1, ref v2);
                                if (AMOVA_IAM) Add(AMOVA_SV1_ANISO, AMOVA_SV1_ANISO, id1, m, v1);
                                if (AMOVA_SMM) Add(AMOVA_SV2_ANISO, AMOVA_SV2_ANISO, id1, m, v2);
                            }
                            Increment(50);
                        }
                    }
            }

            public void AMOVAThreadGeno(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                bool sumss = (bool)((object[])obj)[2];
                VESSEL _vs = (VESSEL)((object[])obj)[3];
                double[,] oF1 = (double[,])((object[])obj)[4];
                double[,] oF2 = (double[,])((object[])obj)[5];
                double tr = AMOVA_PERMUTE / (double)nthreads + 1e-10;
                int nt = (int)((id + 1) * tr) - (int)(id * tr);

                Random rnd = new Random(SEED ^ (id + 0x2FA9A701));//buf fixed on 20220324

                double[,] C = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] c = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[] SS1 = new double[AMOVA_NLAY], SS2 = new double[AMOVA_NLAY];
                double[] ss1 = new double[AMOVA_NLAY], ss2 = new double[AMOVA_NLAY];
                double[] V1 = new double[AMOVA_NLAY], V2 = new double[AMOVA_NLAY];
                double[] v1 = null, v2 = null;
                double[,] F1 = new double[AMOVA_NLAY, AMOVA_NLAY], F2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[] vs1 = new double[AMOVA_NLAY], vs2 = new double[AMOVA_NLAY];
                double[,] sum_F1 = new double[AMOVA_NLAY, AMOVA_NLAY], sum_F2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_F1sq = new double[AMOVA_NLAY, AMOVA_NLAY], sum_F2sq = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_cF1 = new double[AMOVA_NLAY, AMOVA_NLAY], sum_cF2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_eF1 = new double[AMOVA_NLAY, AMOVA_NLAY], sum_eF2 = new double[AMOVA_NLAY, AMOVA_NLAY];

                int[] tid = new int[AMOVA_NLAY + 1];
                double[] tw = new double[AMOVA_NLAY + 1];

                for (int fa = AMOVA_IGNOREIND ? 1 : 2; fa < AMOVA_NLAY; ++fa)
                {
                    for (int fb = fa + 1; fb <= AMOVA_NLAY; ++fb)
                    {
                        VESSEL vs = new VESSEL(_vs);
                        vs.InitW();
                        for (int k = 0; k < nt; ++k)
                        {
                            if (AMOVA_IAM) { SetVal(SS1, 0); SetVal(V1, 0); }
                            if (AMOVA_SMM) { SetVal(SS2, 0); SetVal(V2, 0); }
                            SetVal(C, 0);

                            vs.Shuffle(rnd, fa, fb, 3, null);
                            for (int l = 0; l < L; ++l)
                            {
                                VESSEL.InitC(c, tid, AMOVA_NH_ANISO[l]);
                                vs.GetC(tw, tid, c, l);
                                vs.GetSSGeno(c, ss1, ss2, l);

                                if (sumss)
                                {
                                    Add(C, C, c);
                                    if (AMOVA_IAM) Add(SS1, SS1, ss1);
                                    if (AMOVA_SMM) Add(SS2, SS2, ss2);
                                }
                                else
                                {
                                    //sum var
                                    Add(C, C, c);
                                    VESSEL.GetV(c, ss1, ss2, ref v1, ref v2);
                                    if (AMOVA_IAM) Add(V1, V1, v1);
                                    if (AMOVA_SMM) Add(V2, V2, v2);
                                }
                            }

                            //estimate
                            double VTOT1 = 0, VTOT2 = 0;
                            if (sumss) VESSEL.GetV(C, SS1, SS2, ref V1, ref V2);
                            VESSEL.GetF(V1, V2, ref VTOT1, ref VTOT2, F1, F2, vs1, vs2);

                            if (AMOVA_IAM)
                            {
                                sum_F1[fa - 1, fb - 1] += F1[fa - 1, fb - 1];
                                sum_F1sq[fa - 1, fb - 1] += F1[fa - 1, fb - 1] * F1[fa - 1, fb - 1];
                                if (F1[fa - 1, fb - 1] > oF1[fa - 1, fb - 1] + 1e-7) sum_cF1[fa - 1, fb - 1]++;
                            }
                            if (AMOVA_SMM)
                            {
                                sum_F2[fa - 1, fb - 1] += F2[fa - 1, fb - 1];
                                sum_F2sq[fa - 1, fb - 1] += F2[fa - 1, fb - 1] * F2[fa - 1, fb - 1];
                                if (F2[fa - 1, fb - 1] > oF2[fa - 1, fb - 1] + 1e-7) sum_cF2[fa - 1, fb - 1]++;
                            }
                            Increment();
                        }
                    }
                }

                if (AMOVA_IAM)
                {
                    lock (amova_F1)
                    {
                        AddAmova(amova_F1, sum_F1);
                        AddAmova(amova_F1sq, sum_F1sq);
                        AddAmova(amova_cF1, sum_cF1);
                        AddAmova(amova_eF1, sum_eF1);
                    }
                }
                if (AMOVA_SMM)
                {
                    lock (amova_F2)
                    {
                        AddAmova(amova_F2, sum_F2);
                        AddAmova(amova_F2sq, sum_F2sq);
                        AddAmova(amova_cF2, sum_cF2);
                        AddAmova(amova_eF2, sum_eF2);
                    }
                }
            }

            public void AMOVAThreadML(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                bool isgeno = (bool)((object[])obj)[2];
                VESSEL _vs = (VESSEL)((object[])obj)[3];
                double[,] oF1 = (double[,])((object[])obj)[4];
                IND[] inds = (IND[])((object[])obj)[5];

                Random rnd = new Random(SEED ^ (id + 0x3B5F7CFC));//bug fixed on 20220324
                double[,] F1 = null;

                double[,] sum_F1 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_F1sq = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_cF1 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] sum_eF1 = new double[AMOVA_NLAY, AMOVA_NLAY];

                double[] Fi = new double[AMOVA_NLAY]; //FIS FIC1 FIC2 FIT
                for (int fa = AMOVA_IGNOREIND ? 1 : 2; fa < AMOVA_NLAY; ++fa)
                {
                    for (int fb = fa + 1; fb <= AMOVA_NLAY; ++fb)
                    {
                        VESSEL vs = new VESSEL(_vs);
                        vs.InitW();
                        for (int m = id; m < AMOVA_PERMUTE; m += nthreads)
                        {
                            //RNG rng = new RNG((uint)m);

                            vs.Shuffle(rnd, fa, fb, 4, inds);
                            for (int clay = AMOVA_IGNOREIND ? 0 : 1; clay < AMOVA_NLAY; ++clay)
                            {
                                Point4 x = Point4.DownHillSimplex(1, 10, vs.Likelihood, new object[] { clay, isgeno, inds });
                                Fi[clay] = x.real[0];
                            }

                            VESSEL.GetF(Fi, ref F1);

                            sum_F1[fa - 1, fb - 1] += F1[fa - 1, fb - 1];
                            sum_F1sq[fa - 1, fb - 1] += F1[fa - 1, fb - 1] * F1[fa - 1, fb - 1];
                            if (F1[fa - 1, fb - 1] > oF1[fa - 1, fb - 1] + 1e-7) sum_cF1[fa - 1, fb - 1]++;
                            else if (F1[fa - 1, fb - 1] > oF1[fa - 1, fb - 1] - 1e-7) sum_eF1[fa - 1, fb - 1]++;

                            Increment();
                        }
                    }
                }

                if (AMOVA_IAM)
                {
                    lock (amova_F1)
                    {
                        AddAmova(amova_F1, sum_F1);
                        AddAmova(amova_F1sq, sum_F1sq);
                        AddAmova(amova_cF1, sum_cF1);
                        AddAmova(amova_eF1, sum_eF1);
                    }
                }
            }

            public class VESSEL_ENUMERATOR
            {
                public int[] rid;
                public int[] id;
                public VESSEL[] trace;
                public int lay;

                public void Copy(VESSEL_ENUMERATOR r)
                {
                    Array.Copy(r.rid, rid, rid.Length);
                    Array.Copy(r.id, id, id.Length);
                    Array.Copy(r.trace, trace, trace.Length);
                    lay = r.lay;
                }

                public VESSEL_ENUMERATOR(int _lay, VESSEL root)
                {
                    lay = _lay;
                    rid = new int[AMOVA_NLAY + 1];
                    id = new int[AMOVA_NLAY + 1];
                    trace = new VESSEL[AMOVA_NLAY + 1];
                    trace[AMOVA_NLAY] = root;
                    for (int clay = AMOVA_NLAY - 1; clay >= lay; --clay)
                        trace[clay] = trace[clay + 1].subunits[0];
                }

                public VESSEL Next()
                {
                    if (trace[lay + 1].subunits.Count > rid[lay] + 1)
                    {
                        rid[lay]++;
                        id[lay]++;
                        trace[lay] = trace[lay + 1].subunits[rid[lay]];
                    }
                    else
                    {
                        for (int clay = lay; clay < AMOVA_NLAY; ++clay)
                        {
                            if (trace[clay + 1].subunits.Count > rid[clay] + 1)
                            {
                                rid[clay]++;
                                id[clay]++;
                                trace[clay] = trace[clay + 1].subunits[rid[clay]];
                                for (int clay2 = clay - 1; clay2 >= lay; --clay2)
                                    trace[clay2] = trace[clay2 + 1].subunits[rid[clay2]];
                                break;
                            }
                            else
                            {
                                id[clay]++;
                                rid[clay] = 0;
                                trace[lay] = null;
                            }
                        }
                    }

                    return trace[lay];
                }

                public int GetId()
                {
                    return trace[lay].hid;
                }

            }

            public class VESSEL
            {
                public List<VESSEL> subunits = null;
                public int nhaplo = -1;
                public int[] nhaplos = null;
                public Dictionary<int, double>[] fre;
                public int lay = -1;
                public int hid = -1;

                public IDictionary<int, double> GetFreq(IND[] inds, int l)
                {
                    if (hid == -1) return fre[l];
                    return inds[hid].g[l].freq;
                }

                public VESSEL()
                {

                }

                public VESSEL(VESSEL r)
                {
                    nhaplo = r.nhaplo;
                    lay = r.lay;
                    hid = r.hid;
                    if (r.subunits != null)
                    {
                        subunits = new List<VESSEL>();
                        foreach (VESSEL s in r.subunits)
                            subunits.Add(new VESSEL(s));
                    }
                    if (r.nhaplos != null) nhaplos = Clone(r.nhaplos);
                    if (r.fre != null)
                    {
                        fre = new Dictionary<int, double>[r.fre.Length];
                        for (int l = 0; l < fre.Length; ++l)
                            fre[l] = Clone(r.fre[l]);
                    }
                }

                public VESSEL(SUBPOP s, int _lay, ref int _hid, int l, int method)
                {
                    lay = _lay;
                    subunits = new List<VESSEL>();
                    int L = s.loc.Length;
                    nhaplo = l == -1 ? s.nhaplotypes : s.loc[l].nhaplotypes;

                    if (s.subpops != null && s.subpops.Length > 0)
                    {
                        //reg
                        if (l == -1)
                        {
                            if (method >= 3) nhaplos = new int[L];
                            if (method == 4)
                            {
                                fre = new Dictionary<int, double>[L];
                                for (int l2 = 0; l2 < s.loc.Length; ++l2)
                                    fre[l2] = CloneKey(s.loc[l2].freq);

                            }
                            foreach (SUBPOP ss in s.subpops)
                            {
                                VESSEL tv = new VESSEL(ss, lay - 1, ref _hid, l, method);
                                if (method >= 3) Add(nhaplos, nhaplos, tv.nhaplos);
                                if (method == 4) for (int l2 = 0; l2 < L; ++l2)
                                        AddMul(fre[l2], tv.fre[l2], tv.nhaplos[l2]);
                                subunits.Add(tv);
                            }
                            if (method == 4) for (int l2 = 0; l2 < L; ++l2)
                                    Unify(fre[l2]);
                        }
                        else foreach (SUBPOP ss in s.subpops)
                            {
                                if (ss.loc[l].nhaplotypes > 0)
                                    subunits.Add(new VESSEL(ss, lay - 1, ref _hid, l, method));
                                else _hid += ss.nhaplotypes;
                            }
                    }
                    else if (!AMOVA_IGNOREIND)
                    {
                        //pop, ind
                        if (l == -1)
                        {
                            if (method < 3) foreach (IND ss in s.inds)
                                    subunits.Add(new VESSEL(ss, lay - 1, ref _hid, l, method));
                            else
                            {
                                nhaplos = new int[L];
                                if (method == 4)
                                {
                                    fre = new Dictionary<int, double>[L];
                                    for (int l2 = 0; l2 < s.loc.Length; ++l2)
                                        fre[l2] = CloneKey(s.loc[l2].freq);
                                }
                                foreach (IND ss in s.inds)//Weight Genotype
                                {
                                    VESSEL tv = new VESSEL(ss, lay - 1, ref _hid, l, method);
                                    Add(nhaplos, nhaplos, tv.nhaplos);
                                    subunits.Add(tv);
                                    if (method == 4) for (int l2 = 0; l2 < L; ++l2)
                                            if (ss.g[l2].hash != 0)
                                                Add(fre[l2], fre[l2], ss.g[l2].freq);
                                }
                                if (method == 4) for (int l2 = 0; l2 < L; ++l2)
                                        Unify(fre[l2]);
                            }
                        }
                        else foreach (IND ss in s.inds)
                            {
                                if (ss.g[l].hash != 0)
                                    subunits.Add(new VESSEL(ss, lay - 1, ref _hid, l, method));
                                else
                                    _hid += ss.ploidy;
                            }
                    }
                    else
                    {
                        //pop, no ind
                        if (l == -1)
                        {
                            //homo, ml
                            if (method < 3) foreach (IND ss in s.inds)
                                    for (int i = 0; i < ss.ploidy; ++i)
                                        subunits.Add(new VESSEL(lay - 1, ref _hid, l));
                            else
                            {
                                nhaplos = new int[s.loc.Length];
                                if (method == 4)
                                {
                                    fre = new Dictionary<int, double>[L];
                                    for (int l2 = 0; l2 < s.loc.Length; ++l2)
                                        fre[l2] = CloneKey(s.loc[l2].freq);
                                }
                                foreach (IND ss in s.inds)//Weight Genotype
                                {
                                    VESSEL tv = new VESSEL(ss, lay - 1, ref _hid, l, method);
                                    Add(nhaplos, nhaplos, tv.nhaplos);
                                    subunits.Add(tv);
                                    if (method == 4) for (int l2 = 0; l2 < L; ++l2)
                                            if (ss.g[l2].hash != 0)
                                                Add(fre[l2], fre[l2], ss.g[l2].freq);
                                }
                                if (method == 4) for (int l2 = 0; l2 < L; ++l2)
                                        Unify(fre[l2]);
                            }
                        }
                        else foreach (IND ss in s.inds)
                            {
                                //pop, no ind, aniso
                                if (ss.g[l].hash != 0)
                                    for (int i = 0; i < ss.ploidy; ++i)
                                        subunits.Add(new VESSEL(lay - 1, ref _hid, l));
                                else
                                    _hid += ss.ploidy;
                            }
                    }
                }

                public VESSEL(IND s, int _lay, ref int _hid, int l, int method)
                {
                    if (method >= 3)
                    {
                        lay = _lay;
                        nhaplo = s.ploidy;
                        int L = s.g.Length;
                        nhaplos = new int[L];
                        hid = _hid++;
                        for (l = 0; l < L; ++l)
                            nhaplos[l] = s.g[l].hash != 0 ? nhaplo : 0;
                    }
                    else
                    {
                        lay = _lay;
                        subunits = new List<VESSEL>();
                        nhaplo = s.ploidy;
                        for (int i = 0; i < nhaplo; ++i)
                            subunits.Add(new VESSEL(lay - 1, ref _hid, l));
                    }
                }

                public VESSEL(int _lay, ref int _hid, int l)
                {
                    subunits = null;
                    lay = _lay;
                    hid = _hid++;
                    nhaplo = 1;
                }

                public void GetVessels(List<VESSEL> vs, int fa)
                {
                    if (fa == lay)
                        vs.AddRange(subunits);
                    else foreach (VESSEL s in subunits)
                            s.GetVessels(vs, fa);
                }

                public int Replace(List<VESSEL> vs, int fa, ref int _id, int method, IND[] inds)
                {
                    if (fa == lay)
                    {
                        int L = 0;
                        if (method >= 3) SetVal(nhaplos, 0);
                        if (method == 4)
                        {
                            L = nhaplos.Length;
                            for (int l = 0; l < L; ++l)
                                SetVal(fre[l], 0);
                        }

                        nhaplo = 0;
                        for (int i = 0; i < subunits.Count; ++i)
                        {
                            subunits[i] = vs[_id++];
                            nhaplo += subunits[i].nhaplo;
                            if (method >= 3) Add(nhaplos, nhaplos, subunits[i].nhaplos);
                            if (method == 4) for (int l = 0; l < L; ++l)
                                    AddMul(fre[l], subunits[i].GetFreq(inds, l), subunits[i].nhaplos[l]);
                        }
                        if (method == 4) for (int l = 0; l < L; ++l)
                                Unify(fre[l]);
                    }
                    else
                    {
                        int L = 0;
                        nhaplo = 0;
                        if (method >= 3) SetVal(nhaplos, 0);
                        if (method == 4)
                        {
                            L = nhaplos.Length;
                            for (int l = 0; l < L; ++l)
                                SetVal(fre[l], 0);
                        }
                        foreach (VESSEL s in subunits)
                        {
                            nhaplo += s.Replace(vs, fa, ref _id, method, inds);
                            if (method >= 3) Add(nhaplos, nhaplos, s.nhaplos);
                            if (method == 4) for (int l = 0; l < L; ++l)
                                    AddMul(fre[l], s.GetFreq(inds, l), s.nhaplos[l]);
                        }
                        if (method == 4) for (int l = 0; l < L; ++l)
                                Unify(fre[l]);
                    }
                    return nhaplo;
                }

                /*
                public void Shuffle(RNG rnd, int fa, int fb, int method, IND[] inds)
                {
                    if (lay > fb)
                        foreach (VESSEL s in subunits)
                            s.Shuffle(rnd, fa, fb, method, inds);
                    else if (fb == lay)
                    {
                        List<VESSEL> vs = new List<VESSEL>();
                        GetVessels(vs, fa);
                        rnd.Permute(vs);
                        int id = 0;
                        Replace(vs, fa, ref id, method, inds);
                    }
                }
                */

                public void Shuffle(Random rnd, int fa, int fb, int method, IND[] inds)
                {
                    if (lay > fb)
                        foreach (VESSEL s in subunits)
                            s.Shuffle(rnd, fa, fb, method, inds);
                    else if (fb == lay)
                    {
                        List<VESSEL> vs = new List<VESSEL>();
                        GetVessels(vs, fa);
                        Permute(vs, rnd);
                        int id = 0;
                        Replace(vs, fa, ref id, method, inds);
                    }
                }

                public void GetC(double[] tw, int[] tid, double[,] C, int l)
                {
                    if (l == -1)
                    {
                        if (nhaplo == 0) return;
                        tw[lay] = 1.0 / nhaplo;
                        for (int i = lay; i < AMOVA_NLAY; ++i)
                            C[i, lay] -= nhaplo * nhaplo * tw[i + 1];
                        if (subunits != null) foreach (VESSEL s in subunits)
                                s.GetC(tw, tid, C, l);
                        AMOVA_W[lay][tid[lay]++] = tw[lay];
                    }
                    else
                    {
                        if (nhaplos[l] == 0) { tid[lay]++; return; }
                        tw[lay] = 1.0 / nhaplos[l];
                        for (int i = lay; i < AMOVA_NLAY; ++i)
                            C[i, lay] -= nhaplos[l] * nhaplos[l] * tw[i + 1];

                        if (AMOVA_IGNOREIND)
                        {
                            if (lay > 1) foreach (VESSEL s in subunits)
                                    s.GetC(tw, tid, C, l);
                            else for (int i = lay - 1; i < AMOVA_NLAY; ++i)
                                    C[i, lay - 1] -= nhaplos[l] * tw[i + 1];
                        }
                        else
                        {
                            if (subunits != null) foreach (VESSEL s in subunits)
                                    s.GetC(tw, tid, C, l);
                            else for (int i = lay - 1; i < AMOVA_NLAY; ++i)
                                    C[i, lay - 1] -= nhaplos[l] * tw[i + 1];
                        }
                        AMOVA_W[lay][tid[lay]++] = tw[lay];
                    }
                }

                private void CountVessels(int[] id)
                {
                    id[lay]++;
                    if (subunits != null)
                        foreach (VESSEL s in subunits)
                            s.CountVessels(id);
                }

                public void InitW()
                {
                    int[] id = new int[AMOVA_NLAY + 1];
                    AMOVA_W = new double[AMOVA_NLAY + 1][];
                    CountVessels(id);
                    for (int lay = 0; lay <= AMOVA_NLAY; ++lay)
                        AMOVA_W[lay] = new double[id[lay]];
                }

                public static void InitC(double[,] C, int[] id, int Nh)
                {
                    for (int i = 0; i < AMOVA_NLAY; ++i)
                        for (int j = 0; j <= i; ++j)
                            C[i, j] = Nh;
                    SetVal(id, 0);
                    return;
                }

                public void GetSSHomo(double[] SS1, double[] SS2)
                {
                    if (AMOVA_IAM) Array.Clear(SS1, 0, AMOVA_NLAY);
                    if (AMOVA_SMM) Array.Clear(SS2, 0, AMOVA_NLAY);

                    VESSEL_ENUMERATOR ve1 = new VESSEL_ENUMERATOR(0, this), ve2 = new VESSEL_ENUMERATOR(0, this);
                    for (int i = 0; i < AMOVA_NH; ++i)
                    {
                        int hid1 = ve1.GetId();
                        ve2.Copy(ve1); ve2.Next();
                        for (int j = i + 1; j < AMOVA_NH; ++j)
                        {
                            int hid2 = ve2.GetId();
                            double GD1t = 0, GD2t = 0;
                            if (AMOVA_IAM) GD1t = AMOVA_GD1[hid1, hid2];
                            if (AMOVA_SMM) GD2t = AMOVA_GD2[hid1, hid2];
                            for (int lay = 1; lay <= AMOVA_NLAY; ++lay)//Ignore
                            {
                                if (ve1.id[lay] == ve2.id[lay])
                                {
                                    double w = AMOVA_W[lay][ve1.id[lay]];
                                    if (AMOVA_IAM) SS1[lay - 1] += GD1t * w;
                                    if (AMOVA_SMM) SS2[lay - 1] += GD2t * w;
                                }
                            }
                            ve2.Next();
                        }
                        ve1.Next();
                    }
                }

                public void GetSSAniso(double[,] C, double[] SS1, double[] SS2, int l)
                {
                    Array.Clear(SS1, 0, AMOVA_NLAY);
                    Array.Clear(SS2, 0, AMOVA_NLAY);

                    int Nh = AMOVA_NH_ANISO[l];
                    VESSEL_ENUMERATOR ve1 = new VESSEL_ENUMERATOR(0, this), ve2 = new VESSEL_ENUMERATOR(0, this);
                    for (int i = 0; i < Nh; ++i)
                    {
                        int hid1 = ve1.GetId();
                        ve2.Copy(ve1); ve2.Next();
                        for (int j = i + 1; j < Nh; ++j)
                        {
                            int hid2 = ve2.GetId();
                            double GD1t = 0, GD2t = 0;
                            if (AMOVA_IAM) GD1t = AMOVA_GD1[hid1, hid2];
                            if (AMOVA_SMM) GD2t = AMOVA_GD2[hid1, hid2];

                            for (int lay = 1; lay <= AMOVA_NLAY; ++lay)
                            {
                                if (ve1.id[lay] == ve2.id[lay])
                                {
                                    double w = AMOVA_W[lay][ve1.id[lay]];
                                    if (AMOVA_IAM) SS1[lay - 1] += GD1t * w;
                                    if (AMOVA_SMM) SS2[lay - 1] += GD2t * w;
                                }
                            }
                            ve2.Next();
                        }
                        ve1.Next();
                    }
                }

                public void GetSSGeno(double[,] C, double[] SS1, double[] SS2, int l)
                {
                    Array.Clear(SS1, 0, AMOVA_NLAY);
                    Array.Clear(SS2, 0, AMOVA_NLAY);

                    VESSEL_ENUMERATOR ve1 = new VESSEL_ENUMERATOR(AMOVA_IGNOREIND ? 0 : 1, this), ve2 = new VESSEL_ENUMERATOR(AMOVA_IGNOREIND ? 0 : 1, this);
                    for (int i = 0; i < AMOVA_NIND; ++i)
                    {
                        int hid1 = ve1.GetId();
                        if (AMOVA_IND[hid1].g[l].hash != 0)
                        {
                            double GD1t = 0, GD2t = 0;
                            if (AMOVA_IAM) GD1t = AMOVA_GD1[l, hid1];
                            if (AMOVA_SMM) GD2t = AMOVA_GD2[l, hid1];
                            if (GD1t > 0 || GD2t > 0) for (int lay = 1; lay <= AMOVA_NLAY; ++lay)
                                {
                                    double w = AMOVA_W[lay][ve1.id[lay]];
                                    if (AMOVA_IAM) SS1[lay - 1] += GD1t * w;
                                    if (AMOVA_SMM) SS2[lay - 1] += GD2t * w;
                                }

                            ve2.Copy(ve1); ve2.Next();
                            for (int j = i + 1; j < AMOVA_NIND; ++j)
                            {
                                int hid2 = ve2.GetId();
                                if (AMOVA_IND[hid2].g[l].hash != 0)
                                {
                                    if (AMOVA_IAM) GD1t = AMOVA_GDL1[l, hid1, hid2];
                                    if (AMOVA_SMM) GD2t = AMOVA_GDL2[l, hid1, hid2];
                                    if (GD1t > 0 || GD2t > 0) for (int lay = 1; lay <= AMOVA_NLAY; ++lay)
                                        {
                                            if (ve1.id[lay] == ve2.id[lay])
                                            {
                                                double w = AMOVA_W[lay][ve1.id[lay]];
                                                if (AMOVA_IAM) SS1[lay - 1] += GD1t * w;
                                                if (AMOVA_SMM) SS2[lay - 1] += GD2t * w;
                                            }
                                        }
                                }
                                ve2.Next();
                            }
                        }
                        ve1.Next();
                    }
                }

                public void GetCML(double[,] C, int l, int[] tid, double[] tw)
                {
                    InitC(C, tid, AMOVA_NH_ANISO[l]);
                    GetC(tw, tid, C, l);
                }

                public static void GetV(double[,] C, double[] SS1, double[] SS2, ref double[] V1, ref double[] V2)
                {
                    LinearAlgebra.MatrixBuilder<double> MAT = LinearAlgebra.Matrix<double>.Build;
                    LinearAlgebra.Matrix<double> MC = MAT.DenseOfArray(C).Inverse();
                    if (SS1 != null) V1 = (MC * MAT.DenseOfColumnArrays(SS1).RowSums()).ToArray();
                    if (SS2 != null) V2 = (MC * MAT.DenseOfColumnArrays(SS2).RowSums()).ToArray();
                }

                public static void GetF(double[] V1, double[] V2, ref double VTOT1, ref double VTOT2, double[,] F1, double[,] F2, double[] vs1, double[] vs2)
                {
                    if (V1 != null)
                    {
                        VTOT1 = V1.Sum();
                        vs1[0] = V1[0];
                        for (int i = 1; i < AMOVA_NLAY; ++i)
                            vs1[i] = vs1[i - 1] + V1[i] + DUNDERFLOW;
                        for (int i = 0; i < AMOVA_NLAY; ++i)
                            for (int j = i + 1; j < AMOVA_NLAY; ++j)
                                F1[i, j] = 1.0 - vs1[i] / vs1[j];
                    }

                    if (V2 != null)
                    {
                        VTOT2 = V2.Sum();
                        vs2[0] = V2[0];
                        for (int i = 1; i < AMOVA_NLAY; ++i)
                            vs2[i] = vs2[i - 1] + V2[i] + DUNDERFLOW;

                        for (int i = 0; i < AMOVA_NLAY; ++i)
                            for (int j = i + 1; j < AMOVA_NLAY; ++j)
                                F2[i, j] = 1.0 - vs2[i] / vs2[j];
                    }
                }

                public static void GetF(double[] Fi, ref double[,] F1)
                {
                    F1 = new double[AMOVA_NLAY, AMOVA_NLAY];
                    if (AMOVA_IGNOREIND)
                    {
                        //Fis Fic1 Fic2 Fit
                        for (int i = 0; i < AMOVA_NLAY; ++i)
                            for (int j = i + 1; j < AMOVA_NLAY; ++j)
                                //FST = 1 - (1-FIT)/(1-FIS)
                                F1[i, j] = 1 - (1 - Fi[j]) / (1 - Fi[i]);
                    }
                    else
                    {
                        //0 Fis Fic1 Fic2 Fit
                        for (int i = 1; i < AMOVA_NLAY; ++i)
                            F1[0, i] = Fi[i];
                        for (int i = 1; i < AMOVA_NLAY; ++i)
                        {
                            for (int j = i + 1; j < AMOVA_NLAY; ++j)
                                //FST = 1 - (1-FIT)/(1-FIS)
                                F1[i, j] = 1 - (1 - Fi[j]) / (1 - Fi[i]);
                        }
                    }

                }

                public void Likelihood(Point4 xp, object[] par)
                {
                    int clay = (int)par[0];
                    bool isgeno = (bool)par[1];
                    IND[] inds = (IND[])par[2];

                    //FIT
                    double tli = 0;
                    xp.i2r_selfing();
                    double f = xp.real[0];

                    int L = inds[0].g.Length;
                    VESSEL_ENUMERATOR ve = new VESSEL_ENUMERATOR(AMOVA_IGNOREIND ? 0 : 1, this);

                    for (int i = 0; i < inds.Length; ++i)
                    {
                        IND ind = inds[ve.GetId()];
                        double li = 0;
                        for (int l = 0; l < L; ++l)
                        {
                            PHENOTYPE p = ind.g[l];
                            if (p.genotypes.Length == 0) continue;

                            if (isgeno)
                                li += p.genotypes.Sum(g => g.poster * Math.Log(g.GFZ(ve.trace[clay + 1].fre[l], f)));
                            else
                                li += Math.Log(p.PFZ(ISGENOTYPE, ve.trace[clay + 1].fre[l], f));
                        }
                        tli += li;
                        ve.Next();
                    }
                    xp.li = tli;
                }
            }

            [ThreadStatic] public static double[][] AMOVA_W = null;
            public static HAPLOTYPE[] AMOVA_H = null;

            public static double[,] AMOVA_GD1 = null, AMOVA_GD2 = null;
            public static double[,,] AMOVA_SV1_ANISO = null, AMOVA_SV2_ANISO = null;
            public static double[,,] AMOVA_GDL1 = null, AMOVA_GDL2 = null;
            public static double[,,,] AMOVA_C_ANISO = null;

            public static IND[] AMOVA_IND;
            public static int AMOVA_NLAY, AMOVA_NH, AMOVA_NIND;
            public static int[] AMOVA_NH_ANISO;
            public static double[] NULLSQDIST = null;

            public void CalcAMOVA()
            {
                StreamWriter wt = new StreamWriter(new FileStream("o_amova.txt", FileMode.Create, FileAccess.Write), Encoding.UTF8);
                OUTPUT_AMOVA = wt;

                if (AMOVA_HOMO) CalcAMOVA_homo(wt);
                if (AMOVA_ANISO) CalcAMOVA_aniso(wt, true);
                if (AMOVA_GENO) CalcAMOVA_geno(wt, true);
                if (AMOVA_ML) CalcAMOVA_ml(wt, false);
                wt.Flush();
                wt.Close();
            }

            public void CalcAMOVA_homo_correctfis(double ptype, double[,] F1, double[] V1, double[] SS1, double[,] C)
            {
                //20200520  homoploid Fis Correction
                //Correct F
                double[] Fi = new double[AMOVA_NLAY];
                F1[0, 1] /= ptype;
                for (int clay = 2; clay < AMOVA_NLAY; ++clay)
                    Fi[clay] = F1[0, clay] = 1 - (1 - F1[0, 1]) * (1 - F1[1, clay]);

                //Correct V
                double Vt1 = V1.Sum(), SSt1 = SS1.Sum();
                V1[0] = 1 - Fi[AMOVA_NLAY - 1];
                V1[1] = AMOVA_NLAY == 2 ? 1 - V1[0] : Fi[1] * (1.0 - Fi[AMOVA_NLAY - 1]) / (1.0 - Fi[1]);
                if (AMOVA_NLAY > 2) V1[AMOVA_NLAY - 1] = (Fi[AMOVA_NLAY - 1] - Fi[AMOVA_NLAY - 2]) / (1.0 - Fi[AMOVA_NLAY - 2]);
                for (int clay = 2; clay < AMOVA_NLAY - 1; ++clay)
                    V1[clay] = (Fi[clay] - Fi[clay - 1]) * (1 - Fi[AMOVA_NLAY - 1]) / ((1 - Fi[clay - 1]) * (1 - Fi[clay]));
                Mul(V1, V1, Vt1);

                //Correct SS
                LinearAlgebra.MatrixBuilder<double> MAT = LinearAlgebra.Matrix<double>.Build;
                SS1 = (MAT.DenseOfArray(C) * MAT.DenseOfColumnArrays(V1).RowSums()).ToArray();
            }

            public void CalcAMOVA_homo(StreamWriter wt)
            {
                Progress = "Performing AMOVA";
                AMOVA_NLAY = (AMOVA_IGNOREIND ? 1 : 2) + regions.Length;

                //Init SS
                foreach (IND ind in inds)
                    ind.SS1 = ind.SS2 = 0;

                for (int rl = 0; rl < regions.Length; ++rl)
                    foreach (SUBPOP tr in regions[rl])
                        tr.SS1 = tr.SS2 = 0;

                foreach (SUBPOP tp in subpops)
                    tp.SS1 = tp.SS2 = 0;

                double[] SS1 = new double[AMOVA_NLAY], SS2 = new double[AMOVA_NLAY];
                double[] V1 = null, V2 = null;
                double[,] F1 = new double[AMOVA_NLAY, AMOVA_NLAY], F2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[] vs1 = new double[AMOVA_NLAY], vs2 = new double[AMOVA_NLAY];

                //Init haplotypes
                AMOVA_NH = total_pop.nhaplotypes;
                AMOVA_H = GetHaplotype(total_pop, AMOVA_NLAY, AMOVA_IGNOREIND, true);

                double[,] C = new double[AMOVA_NLAY, AMOVA_NLAY];

                int tref = 0;
                VESSEL vs = new VESSEL(total_pop, AMOVA_NLAY, ref tref, -1, 1);
                int[] tid = new int[AMOVA_NLAY + 1];
                double[] tw = new double[AMOVA_NLAY + 1];
                vs.InitW();
                VESSEL.InitC(C, tid, AMOVA_NH);
                vs.GetC(tw, tid, C, -1);

                ProgressValue = 0;
                ProgressMax = AMOVA_NH * (AMOVA_NH - 1) / 2;
                SetProgress(ProgressValue, ProgressMax);

                if (AMOVA_IAM) AMOVA_GD1 = new double[AMOVA_NH, AMOVA_NH];
                if (AMOVA_SMM) AMOVA_GD2 = new double[AMOVA_NH, AMOVA_NH];

                VESSEL_ENUMERATOR ve1 = new VESSEL_ENUMERATOR(0, vs), ve2 = new VESSEL_ENUMERATOR(0, vs);
                for (int i = 0; i < AMOVA_NH; ++i)
                {
                    ve2.Copy(ve1); ve2.Next();
                    for (int j = i + 1; j < AMOVA_NH; ++j)
                    {
                        double GD1t = 0, GD2t = 0;
                        for (int l = 0; l < L; ++l)
                        {
                            foreach (int a in AMOVA_H[i].allele[l].Keys)
                            {
                                foreach (int b in AMOVA_H[j].allele[l].Keys)
                                {
                                    if (a == b) continue;
                                    if (a == NULL_ALLELE)
                                    {
                                        if (AMOVA_IAM) GD1t += AMOVA_H[i].allele[l][a] * AMOVA_H[j].allele[l][b];
                                        if (AMOVA_SMM) GD2t += AMOVA_H[i].allele[l][a] * AMOVA_H[j].allele[l][b] * NULLSQDIST[l];
                                    }
                                    else if (b == NULL_ALLELE)
                                    {
                                        if (AMOVA_IAM) GD1t += AMOVA_H[i].allele[l][a] * AMOVA_H[j].allele[l][b];
                                        if (AMOVA_SMM) GD2t += AMOVA_H[i].allele[l][a] * AMOVA_H[j].allele[l][b] * NULLSQDIST[l];
                                    }
                                    else
                                    {
                                        if (AMOVA_IAM) GD1t += AMOVA_H[i].allele[l][a] * AMOVA_H[j].allele[l][b];
                                        if (AMOVA_SMM) GD2t += AMOVA_H[i].allele[l][a] * AMOVA_H[j].allele[l][b] * (a - b) * (a - b);
                                    }
                                }
                            }
                        }

                        if (AMOVA_IAM) AMOVA_GD1[j, i] = AMOVA_GD1[i, j] = GD1t;
                        if (AMOVA_SMM) AMOVA_GD2[j, i] = AMOVA_GD2[i, j] = GD2t;

                        for (int lay = 1; lay < AMOVA_NLAY; ++lay)
                        {
                            if (ve1.id[lay] == ve2.id[lay])
                            {
                                double w = AMOVA_W[lay][ve1.id[lay]];
                                if (lay == 1 && !AMOVA_IGNOREIND)
                                {
                                    if (AMOVA_IAM) inds[ve1.id[lay]].SS1 += GD1t * w;
                                    if (AMOVA_SMM) inds[ve1.id[lay]].SS2 += GD2t * w;
                                }
                                else
                                {
                                    SUBPOP tp = null;
                                    if (lay == 2 && !AMOVA_IGNOREIND)
                                        tp = subpops[ve1.id[lay]];
                                    else if (lay == 1 && AMOVA_IGNOREIND)
                                        tp = subpops[ve1.id[lay]];
                                    else
                                        tp = regions[lay - 2 - (AMOVA_IGNOREIND ? 0 : 1)][ve1.id[lay]];

                                    if (AMOVA_IAM) tp.SS1 += GD1t * w;
                                    if (AMOVA_SMM) tp.SS2 += GD2t * w;
                                }
                            }
                        }
                        ve2.Next();
                        Increment();
                    }
                    ve1.Next();
                }

                ProgressValue = AMOVA_NH * (AMOVA_NH - 1) / 2;
                SetProgress(ProgressMax, ProgressMax);

                double VTOT1 = 0, VTOT2 = 0;
                vs.GetSSHomo(SS1, SS2);
                VESSEL.GetV(C, SS1, SS2, ref V1, ref V2);
                VESSEL.GetF(V1, V2, ref VTOT1, ref VTOT2, F1, F2, vs1, vs2);
                string[] levelstr = new string[AMOVA_NLAY], levelshortstr = new string[AMOVA_NLAY];

                if (AMOVA_IGNOREIND)
                {
                    levelstr[0] = "Populations";
                    levelshortstr[0] = "S";
                    for (int clay = 1; clay < AMOVA_NLAY; ++clay)
                    {
                        levelstr[clay] = "Regions level " + clay;
                        levelshortstr[clay] = "C" + clay;
                    }
                }
                else
                {
                    levelstr[0] = "Individuals";
                    levelshortstr[0] = "I";
                    levelstr[1] = "Populations";
                    levelshortstr[1] = "S";
                    for (int clay = 2; clay < AMOVA_NLAY; ++clay)
                    {
                        levelstr[clay] = "Regions level " + (clay - 1);
                        levelshortstr[clay] = "C" + (clay - 1);
                    }

                    //20200520  homoploid Fis Correction
                    if (AMOVA_HOMO_CORR)
                    {
                        double ptype = 1.0 - total_pop.loc.Sum(l => l.nphenotypes) / (double)(L * total_pop.inds.Length);
                        CalcAMOVA_homo_correctfis(ptype, F1, V1, SS1, C);
                        CalcAMOVA_homo_correctfis(ptype, F2, V2, SS2, C);
                    }
                }
                levelstr[AMOVA_NLAY - 1] = "Total";
                levelshortstr[AMOVA_NLAY - 1] = "T";

                amova_F1 = new double[AMOVA_NLAY, AMOVA_NLAY]; amova_F2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                amova_F1sq = new double[AMOVA_NLAY, AMOVA_NLAY]; amova_F2sq = new double[AMOVA_NLAY, AMOVA_NLAY];
                amova_cF1 = new double[AMOVA_NLAY, AMOVA_NLAY]; amova_cF2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                amova_eF1 = new double[AMOVA_NLAY, AMOVA_NLAY]; amova_eF2 = new double[AMOVA_NLAY, AMOVA_NLAY];

                Progress = "Permutating AMOVA";
                ProgressValue = 0;
                ProgressMax = AMOVA_PERMUTE * (int)BINOMIAL[AMOVA_NLAY, 2];
                SetProgress(ProgressValue, ProgressMax);

                CallThread(AMOVAThreadHomo, N_THREAD, new object[] { vs, F1, F2 }, ProgressMax, ref ProgressValue);

                AMOVA_GD1 = AMOVA_GD2 = null;
                AMOVA_GDL1 = AMOVA_GDL2 = null;

                MulAmova(amova_F1, 1.0 / AMOVA_PERMUTE); MulAmova(amova_F2, 1.0 / AMOVA_PERMUTE);
                MulAmova(amova_F1sq, 1.0 / AMOVA_PERMUTE); MulAmova(amova_F2sq, 1.0 / AMOVA_PERMUTE);
                SubSqAmova(amova_F1sq, amova_F1); SubSqAmova(amova_F2sq, amova_F2);

                double[] DFB = new double[AMOVA_NLAY + 1];
                double[] SSB1 = new double[AMOVA_NLAY + 1], SSB2 = new double[AMOVA_NLAY + 1];
                double[] MS1 = new double[AMOVA_NLAY + 1], MS2 = new double[AMOVA_NLAY + 1];
                for (int i = 0; i < AMOVA_NLAY; ++i)
                {
                    DFB[i] = Math.Round(i > 0 ? (C[i, 0] - C[i - 1, 0]) : (C[i, 0]));
                    SSB1[i] = i > 0 ? SS1[i] - SS1[i - 1] : SS1[i];
                    SSB2[i] = i > 0 ? SS2[i] - SS2[i - 1] : SS2[i];
                    MS1[i] = SSB1[i] / DFB[i];
                    MS2[i] = SSB2[i] / DFB[i];
                }
                DFB[AMOVA_NLAY] = C[AMOVA_NLAY - 1, 0];
                SSB1[AMOVA_NLAY] = SS1[AMOVA_NLAY - 1];
                SSB2[AMOVA_NLAY] = SS2[AMOVA_NLAY - 1];
                MS1[AMOVA_NLAY] = SSB1[AMOVA_NLAY] / DFB[AMOVA_NLAY];
                MS2[AMOVA_NLAY] = SSB2[AMOVA_NLAY] / DFB[AMOVA_NLAY];

                if (AMOVA_IAM)
                {
                    wt.Write("Summary AMOVA Table (IAM), model: homoploid\r\n");
                    wt.Write("Source      \td.f.\tSS\tMS\tVar\t%\r\n");

                    if (!(AMOVA_IGNOREIND && regions.Length == 0))
                        wt.Write("Within " + levelstr[0] + "\t" + DFB[0].ToString("F0") + "\t" + SSB1[0].ToString(DECIMAL) + "\t" + MS1[0].ToString(DECIMAL) + "\t" + V1[0].ToString(DECIMAL) + "\t" + (V1[0] * 100.0 / VTOT1).ToString(DECIMAL) + "\r\n");
                    for (int clay = 1; clay < AMOVA_NLAY; ++clay)
                        wt.Write("Among " + levelstr[clay - 1] + "\t" + DFB[clay].ToString("F0") + "\t" + SSB1[clay].ToString(DECIMAL) + "\t" + MS1[clay].ToString(DECIMAL) + "\t" + V1[clay].ToString(DECIMAL) + "\t" + (V1[clay] * 100.0 / VTOT1).ToString(DECIMAL) + "\r\n");
                    wt.Write("Total\t" + DFB[AMOVA_NLAY].ToString("F0") + "\t" + SSB1[AMOVA_NLAY].ToString(DECIMAL) + "\t" + MS1[AMOVA_NLAY].ToString(DECIMAL) + "\t" + VTOT1.ToString(DECIMAL) + "\t" + (VTOT1 * 100.0 / VTOT1).ToString(DECIMAL) + "\r\n");
                    wt.Write("\r\n");


                    wt.Write("F-statistics (IAM) \tValue\tPermMean\tPermVar\tP(rand>obs)\tP(rand=obs)\r\n");
                    for (int i = 0; i < AMOVA_NLAY; ++i)
                        for (int j = i + 1; j < AMOVA_NLAY; ++j)
                            wt.Write("F" + levelshortstr[i] + levelshortstr[j]
                                      + "\t" + F1[i, j].ToString(DECIMAL)
                                      + "\t" + amova_F1[i, j].ToString(DECIMAL)
                                      + "\t" + amova_F1sq[i, j].ToString(DECIMAL)
                                      + "\t" + (amova_cF1[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                                      + "\t" + (amova_eF1[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                                      + "\r\n");
                    wt.Write("\r\n");
                }

                if (AMOVA_SMM)
                {
                    wt.Write("Summary AMOVA Table (SMM), model: homoploid\r\n");
                    wt.Write("Source      \td.f.\tSS\tMS\tVar\t%\r\n");

                    if (!(AMOVA_IGNOREIND && regions.Length == 0))
                        wt.Write("Within " + levelstr[0] + "\t" + DFB[0].ToString("F0") + "\t" + SSB2[0].ToString(DECIMAL) + "\t" + MS2[0].ToString(DECIMAL) + "\t" + V2[0].ToString(DECIMAL) + "\t" + (V2[0] * 100.0 / VTOT2).ToString(DECIMAL) + "\r\n");
                    for (int clay = 1; clay < AMOVA_NLAY; ++clay)
                        wt.Write("Among " + levelstr[clay - 1] + "\t" + DFB[clay].ToString("F0") + "\t" + SSB2[clay].ToString(DECIMAL) + "\t" + MS2[clay].ToString(DECIMAL) + "\t" + V2[clay].ToString(DECIMAL) + "\t" + (V2[clay] * 100.0 / VTOT2).ToString(DECIMAL) + "\r\n");
                    wt.Write("Total\t" + DFB[AMOVA_NLAY].ToString("F0") + "\t" + SSB2[AMOVA_NLAY].ToString(DECIMAL) + "\t" + MS2[AMOVA_NLAY].ToString(DECIMAL) + "\t" + VTOT2.ToString(DECIMAL) + "\t" + (VTOT2 * 100.0 / VTOT2).ToString(DECIMAL) + "\r\n");
                    wt.Write("\r\n");


                    wt.Write("F-statistics (SMM) \tValue\tPermMean\tPermVar\tP(rand>obs)\tP(rand=obs)\r\n");
                    for (int i = 0; i < AMOVA_NLAY; ++i)
                        for (int j = i + 1; j < AMOVA_NLAY; ++j)
                            wt.Write("F" + levelshortstr[i] + levelshortstr[j]
                                      + "\t" + F2[i, j].ToString(DECIMAL)
                                      + "\t" + amova_F2[i, j].ToString(DECIMAL)
                                      + "\t" + amova_F2sq[i, j].ToString(DECIMAL)
                                      + "\t" + (amova_cF2[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                                      + "\t" + (amova_eF2[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                                      + "\r\n");
                    wt.Write("\r\n");
                }

                if (AMOVA_OUTPUTSS)
                {
                    for (int rl = regions.Length - 2; rl >= 0; --rl)
                    {
                        wt.Write("SS within each region level " + (rl + 1) + "\r\n");
                        wt.Write("ID\t#Hap");
                        if (AMOVA_IAM) wt.Write("\tIAM");
                        if (AMOVA_SMM) wt.Write("\tSMM");
                        wt.Write("\r\n");
                        for (int i = 0; i < regions[rl].Length; ++i)
                        {
                            SUBPOP tr = regions[rl][i];
                            wt.Write(tr.name + "\t" + tr.nhaplotypes);
                            if (AMOVA_IAM) wt.Write("\t" + tr.SS1.ToString(DECIMAL));
                            if (AMOVA_SMM) wt.Write("\t" + tr.SS2.ToString(DECIMAL));
                            wt.Write("\r\n");
                        }
                        wt.Write("\r\n");
                    }

                    wt.Write("SS within each population\r\n");
                    wt.Write("ID\t#Hap");
                    if (AMOVA_IAM) wt.Write("\tIAM");
                    if (AMOVA_SMM) wt.Write("\tSMM");
                    wt.Write("\r\n");
                    foreach (SUBPOP tp in subpops)
                    {
                        wt.Write(tp.name + "\t" + tp.nhaplotypes);
                        if (AMOVA_IAM) wt.Write("\t" + tp.SS1.ToString(DECIMAL));
                        if (AMOVA_SMM) wt.Write("\t" + tp.SS2.ToString(DECIMAL));
                        wt.Write("\r\n");
                    }
                    wt.Write("\r\n");

                    if (!AMOVA_IGNOREIND)
                    {
                        wt.Write("SS within each individual\r\n");
                        wt.Write("ID\t#Hap");
                        if (AMOVA_IAM) wt.Write("\tIAM");
                        if (AMOVA_SMM) wt.Write("\tSMM");
                        wt.Write("\r\n");
                        foreach (IND ind in inds)
                        {
                            wt.Write(ind.name + "\t" + ind.ploidy);
                            if (AMOVA_IAM) wt.Write("\t" + ind.SS1.ToString(DECIMAL));
                            if (AMOVA_SMM) wt.Write("\t" + ind.SS2.ToString(DECIMAL));
                            wt.Write("\r\n");
                        }
                        wt.Write("\r\n");
                    }
                }
            }

            public void CalcAMOVA_aniso(StreamWriter wt, bool sumss)
            {
                //Anisoploid model
                Progress = "Performing AMOVA";
                AMOVA_NLAY = (AMOVA_IGNOREIND ? 1 : 2) + regions.Length;

                //Init SS
                foreach (IND ind in inds)
                    ind.SS1 = ind.SS2 = 0;

                for (int rl = 0; rl < regions.Length; ++rl)
                    foreach (SUBPOP tr in regions[rl])
                        tr.SS1 = tr.SS2 = 0;

                foreach (SUBPOP tp in subpops)
                    tp.SS1 = tp.SS2 = 0;

                double[,] F1 = new double[AMOVA_NLAY, AMOVA_NLAY], F2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[] SS1 = new double[AMOVA_NLAY], SS2 = new double[AMOVA_NLAY];
                double[] ss1 = new double[AMOVA_NLAY], ss2 = new double[AMOVA_NLAY];
                double[] V1 = new double[AMOVA_NLAY], V2 = new double[AMOVA_NLAY];
                double[] v1 = null, v2 = null;
                double[] vs1 = new double[AMOVA_NLAY], vs2 = new double[AMOVA_NLAY];
                int[] tid = new int[AMOVA_NLAY + 1];
                double[] tw = new double[AMOVA_NLAY + 1];

                //Init haplotypes
                AMOVA_NH = total_pop.nhaplotypes;
                AMOVA_NH_ANISO = total_pop.loc.Select(l => l.nhaplotypes).ToArray();
                AMOVA_H = GetHaplotype(total_pop, AMOVA_NLAY, AMOVA_IGNOREIND, false);
                double[,] C = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] c = new double[AMOVA_NLAY, AMOVA_NLAY];

                AMOVA_C_ANISO = new double[(int)BINOMIAL[AMOVA_NLAY, 2], AMOVA_PERMUTE, AMOVA_NLAY, AMOVA_NLAY];
                if (AMOVA_IAM)
                {
                    AMOVA_GD1 = new double[AMOVA_NH, AMOVA_NH];
                    AMOVA_SV1_ANISO = new double[(int)BINOMIAL[AMOVA_NLAY, 2], AMOVA_PERMUTE, AMOVA_NLAY];
                }
                if (AMOVA_SMM)
                {
                    AMOVA_GD2 = new double[AMOVA_NH, AMOVA_NH];
                    AMOVA_SV2_ANISO = new double[(int)BINOMIAL[AMOVA_NLAY, 2], AMOVA_PERMUTE, AMOVA_NLAY];
                }

                ProgressValue = 0;
                ProgressMax = AMOVA_NH_ANISO.Sum(h => h * (h - 1) / 2) + L * AMOVA_PERMUTE * (int)BINOMIAL[AMOVA_NLAY, 2] * 50;
                SetProgress(ProgressValue, ProgressMax);

                Progress = "Permutating AMOVA";

                amova_F1 = new double[AMOVA_NLAY, AMOVA_NLAY]; amova_F2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                amova_F1sq = new double[AMOVA_NLAY, AMOVA_NLAY]; amova_F2sq = new double[AMOVA_NLAY, AMOVA_NLAY];
                amova_cF1 = new double[AMOVA_NLAY, AMOVA_NLAY]; amova_cF2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                amova_eF1 = new double[AMOVA_NLAY, AMOVA_NLAY]; amova_eF2 = new double[AMOVA_NLAY, AMOVA_NLAY];

                for (int l = 0; l < L; ++l)
                {
                    int tref = 0;
                    VESSEL vs = new VESSEL(total_pop, AMOVA_NLAY, ref tref, l, 2);
                    vs.InitW();
                    VESSEL.InitC(c, tid, AMOVA_NH_ANISO[l]);
                    vs.GetC(tw, tid, c, -1);
                    if (AMOVA_IAM) SetVal(AMOVA_GD1, 0);
                    if (AMOVA_SMM) SetVal(AMOVA_GD2, 0);

                    Parallel.For(0, AMOVA_NH, new ParallelOptions() { MaxDegreeOfParallelism = N_THREAD }, i =>
                    //for (int i = 0; i < AMOVA_NH; ++i)
                    {
                        HAPLOTYPE h1 = AMOVA_H[i];
                        if (h1.allele[l] != null) for (int j = i + 1; j < AMOVA_NH; ++j)
                            {
                                HAPLOTYPE h2 = AMOVA_H[j];
                                if (h2.allele[l] == null) continue;
                                double GD1t = 0, GD2t = 0;
                                foreach (int a in h1.allele[l].Keys)
                                {
                                    foreach (int b in h2.allele[l].Keys)
                                    {
                                        if (a == b) continue;
                                        if (a == NULL_ALLELE)
                                        {
                                            if (AMOVA_IAM) GD1t += h1.allele[l][a] * h2.allele[l][b];
                                            if (AMOVA_SMM) GD2t += h1.allele[l][a] * h2.allele[l][b] * NULLSQDIST[l];
                                        }
                                        else if (b == NULL_ALLELE)
                                        {
                                            if (AMOVA_IAM) GD1t += h1.allele[l][a] * h2.allele[l][b];
                                            if (AMOVA_SMM) GD2t += h1.allele[l][a] * h2.allele[l][b] * NULLSQDIST[l];
                                        }
                                        else
                                        {
                                            if (AMOVA_IAM) GD1t += h1.allele[l][a] * h2.allele[l][b];
                                            if (AMOVA_SMM) GD2t += h1.allele[l][a] * h2.allele[l][b] * (a - b) * (a - b);
                                        }
                                    }
                                }
                                if (AMOVA_IAM) AMOVA_GD1[i, j] = AMOVA_GD1[j, i] = GD1t;
                                if (AMOVA_SMM) AMOVA_GD2[i, j] = AMOVA_GD2[j, i] = GD2t;

                                SUBPOP tp1 = h1.ind.subpop, tp2 = h2.ind.subpop; ;
                                for (int lay = 1; lay < AMOVA_NLAY; ++lay)
                                {
                                    if (lay == 1 && !AMOVA_IGNOREIND && h1.ind == h2.ind)
                                    {
                                        lock (h1.ind)
                                        {
                                            if (AMOVA_IAM) h1.ind.SS1 += GD1t / h1.ind.ploidy;
                                            if (AMOVA_SMM) h1.ind.SS2 += GD2t / h1.ind.ploidy;
                                        }
                                    }
                                    if (lay > 1 && !AMOVA_IGNOREIND || AMOVA_IGNOREIND)
                                    {
                                        if (tp1 == tp2)
                                        {
                                            lock (tp1)
                                            {
                                                if (AMOVA_IAM) tp1.SS1 += GD1t / tp1.loc[l].nhaplotypes;
                                                if (AMOVA_SMM) tp1.SS2 += GD2t / tp1.loc[l].nhaplotypes;
                                            }
                                        }
                                        tp1 = tp1.region;
                                        tp2 = tp2.region;
                                    }
                                }
                                Increment();
                            }
                    });
                    vs.GetSSAniso(c, ss1, ss2, l);

                    Add(C, C, c);

                    if (sumss)
                    {
                        if (AMOVA_IAM) Add(SS1, SS1, ss1);
                        if (AMOVA_SMM) Add(SS2, SS2, ss2);
                    }
                    else
                    {
                        //sum var
                        VESSEL.GetV(c, ss1, ss2, ref v1, ref v2);
                        if (AMOVA_IAM) Add(V1, V1, v1);
                        if (AMOVA_SMM) Add(V2, V2, v2);
                    }

                    CallThread(AMOVAThreadAniso, N_THREAD,
                               new object[] { sumss, vs, l },
                    ProgressValue + 50 * AMOVA_PERMUTE * (int)BINOMIAL[AMOVA_NLAY, 2], ref ProgressValue);
                }

                double VTOT1 = 0, VTOT2 = 0;
                if (sumss) VESSEL.GetV(C, SS1, SS2, ref V1, ref V2);
                VESSEL.GetF(V1, V2, ref VTOT1, ref VTOT2, F1, F2, vs1, vs2);

                AMOVA_GD1 = AMOVA_GD2 = null;
                AMOVA_GDL1 = AMOVA_GDL2 = null;
                ProgressValue = 0;
                ProgressMax = AMOVA_PERMUTE * (int)BINOMIAL[AMOVA_NLAY, 2];
                SetProgress(ProgressValue, ProgressMax);

                CallThread(AMOVAThreadAniso2, N_THREAD,
                           new object[] { sumss, F1, F2 },
                ProgressMax, ref ProgressValue);

                AMOVA_SV1_ANISO = AMOVA_SV2_ANISO = null;
                AMOVA_C_ANISO = null;

                MulAmova(amova_F1, 1.0 / AMOVA_PERMUTE);    MulAmova(amova_F2, 1.0 / AMOVA_PERMUTE);
                MulAmova(amova_F1sq, 1.0 / AMOVA_PERMUTE);  MulAmova(amova_F2sq, 1.0 / AMOVA_PERMUTE);
                SubSqAmova(amova_F1sq, amova_F1);           SubSqAmova(amova_F2sq, amova_F2);

                ProgressValue = L;
                SetProgress(ProgressMax, ProgressMax);

                string[] levelstr = new string[AMOVA_NLAY], levelshortstr = new string[AMOVA_NLAY];

                if (AMOVA_IGNOREIND)
                {
                    levelstr[0] = "Populations";
                    levelshortstr[0] = "S";
                    for (int clay = 1; clay < AMOVA_NLAY; ++clay)
                    {
                        levelstr[clay] = "Regions level " + clay;
                        levelshortstr[clay] = "C" + clay;
                    }
                }
                else
                {
                    levelstr[0] = "Individuals";
                    levelshortstr[0] = "I";
                    levelstr[1] = "Populations";
                    levelshortstr[1] = "S";
                    for (int clay = 2; clay < AMOVA_NLAY; ++clay)
                    {
                        levelstr[clay] = "Regions level " + (clay - 1);
                        levelshortstr[clay] = "C" + (clay - 1);
                    }
                }
                levelstr[AMOVA_NLAY - 1] = "Total";
                levelshortstr[AMOVA_NLAY - 1] = "T";

                double[] DFB = new double[AMOVA_NLAY + 1];
                double[] SSB1 = new double[AMOVA_NLAY + 1], SSB2 = new double[AMOVA_NLAY + 1];
                double[] MS1 = new double[AMOVA_NLAY + 1], MS2 = new double[AMOVA_NLAY + 1];
                for (int i = 0; i < AMOVA_NLAY; ++i)
                {
                    DFB[i] = Math.Round(i > 0 ? (C[i, 0] - C[i - 1, 0]) : (C[i, 0]));
                    SSB1[i] = i > 0 ? SS1[i] - SS1[i - 1] : SS1[i];
                    SSB2[i] = i > 0 ? SS2[i] - SS2[i - 1] : SS2[i];
                    MS1[i] = SSB1[i] / DFB[i];
                    MS2[i] = SSB2[i] / DFB[i];
                }

                DFB[AMOVA_NLAY] = C[AMOVA_NLAY - 1, 0];
                SSB1[AMOVA_NLAY] = SS1[AMOVA_NLAY - 1];
                SSB2[AMOVA_NLAY] = SS2[AMOVA_NLAY - 1];
                MS1[AMOVA_NLAY] = SSB1[AMOVA_NLAY] / DFB[AMOVA_NLAY];
                MS2[AMOVA_NLAY] = SSB2[AMOVA_NLAY] / DFB[AMOVA_NLAY];

                if (AMOVA_IAM)
                {
                    wt.Write("Summary AMOVA Table (IAM), model: anisoploid\r\n");
                    wt.Write("Source      \td.f.\tSS\tMS\tVar\t%\r\n");

                    if (!(AMOVA_IGNOREIND && regions.Length == 0))
                        wt.Write("Within " + levelstr[0] + "\t" + DFB[0].ToString("F0") + "\t" + SSB1[0].ToString(DECIMAL) + "\t" + MS1[0].ToString(DECIMAL) + "\t" + V1[0].ToString(DECIMAL) + "\t" + (V1[0] * 100.0 / VTOT1).ToString(DECIMAL) + "\r\n");
                    for (int clay = 1; clay < AMOVA_NLAY; ++clay)
                        wt.Write("Among " + levelstr[clay - 1] + "\t" + DFB[clay].ToString("F0") + "\t" + SSB1[clay].ToString(DECIMAL) + "\t" + MS1[clay].ToString(DECIMAL) + "\t" + V1[clay].ToString(DECIMAL) + "\t" + (V1[clay] * 100.0 / VTOT1).ToString(DECIMAL) + "\r\n");
                    wt.Write("Total\t" + DFB[AMOVA_NLAY].ToString("F0") + "\t" + SSB1[AMOVA_NLAY].ToString(DECIMAL) + "\t" + MS1[AMOVA_NLAY].ToString(DECIMAL) + "\t" + VTOT1.ToString(DECIMAL) + "\t" + (VTOT1 * 100.0 / VTOT1).ToString(DECIMAL) + "\r\n");
                    wt.Write("\r\n");
                
                    wt.Write("F-statistics (IAM) \tValue\tPermMean\tPermVar\tP(rand>obs)\tP(rand=obs)\r\n");
                    for (int i = 0; i < AMOVA_NLAY; ++i)
                        for (int j = i + 1; j < AMOVA_NLAY; ++j)
                            wt.Write("F" + levelshortstr[i] + levelshortstr[j]
                                      + "\t" + F1[i, j].ToString(DECIMAL)
                                      + "\t" + amova_F1[i, j].ToString(DECIMAL)
                                      + "\t" + amova_F1sq[i, j].ToString(DECIMAL)
                                      + "\t" + (amova_cF1[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                                      + "\t" + (amova_eF1[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                                      + "\r\n");
                    wt.Write("\r\n");
                }

                if (AMOVA_SMM)
                {
                    wt.Write("Summary AMOVA Table (SMM), model: anisoploid\r\n");
                    wt.Write("Source      \td.f.\tSS\tMS\tVar\t%\r\n");

                    if (!(AMOVA_IGNOREIND && regions.Length == 0))
                        wt.Write("Within " + levelstr[0] + "\t" + DFB[0].ToString("F0") + "\t" + SSB2[0].ToString(DECIMAL) + "\t" + MS2[0].ToString(DECIMAL) + "\t" + V2[0].ToString(DECIMAL) + "\t" + (V2[0] * 100.0 / VTOT2).ToString(DECIMAL) + "\r\n");
                    for (int clay = 1; clay < AMOVA_NLAY; ++clay)
                        wt.Write("Among " + levelstr[clay - 1] + "\t" + DFB[clay].ToString("F0") + "\t" + SSB2[clay].ToString(DECIMAL) + "\t" + MS2[clay].ToString(DECIMAL) + "\t" + V2[clay].ToString(DECIMAL) + "\t" + (V2[clay] * 100.0 / VTOT2).ToString(DECIMAL) + "\r\n");
                    wt.Write("Total\t" + DFB[AMOVA_NLAY].ToString("F0") + "\t" + SSB2[AMOVA_NLAY].ToString(DECIMAL) + "\t" + MS2[AMOVA_NLAY].ToString(DECIMAL) + "\t" + VTOT2.ToString(DECIMAL) + "\t" + (VTOT2 * 100.0 / VTOT2).ToString(DECIMAL) + "\r\n");
                    wt.Write("\r\n");
                
                    wt.Write("F-statistics (SMM) \tValue\tPermMean\tPermVar\tP(rand>obs)\tP(rand=obs)\r\n");
                    for (int i = 0; i < AMOVA_NLAY; ++i)
                        for (int j = i + 1; j < AMOVA_NLAY; ++j)
                            wt.Write("F" + levelshortstr[i] + levelshortstr[j]
                                      + "\t" + F2[i, j].ToString(DECIMAL)
                                      + "\t" + amova_F2[i, j].ToString(DECIMAL)
                                      + "\t" + amova_F2sq[i, j].ToString(DECIMAL)
                                      + "\t" + (amova_cF2[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                                      + "\t" + (amova_eF2[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                                      + "\r\n");
                    wt.Write("\r\n");
                }

                for (int rl = regions.Length - 2; rl >= 0; --rl)
                {
                    wt.Write("SS within each region level " + (rl + 1) + "\r\n");
                    wt.Write("ID\t#Hap");
                    if (AMOVA_IAM) wt.Write("\tIAM");
                    if (AMOVA_SMM) wt.Write("\tSMM");
                    wt.Write("\r\n");
                    for (int i = 0; i < regions[rl].Length; ++i)
                    {
                        SUBPOP tr = regions[rl][i];
                        wt.Write(tr.name + "\t" + tr.nhaplotypes);
                        if (AMOVA_IAM) wt.Write("\t" + tr.SS1.ToString(DECIMAL));
                        if (AMOVA_SMM) wt.Write("\t" + tr.SS2.ToString(DECIMAL));
                        wt.Write("\r\n");
                    }
                    wt.Write("\r\n");
                }

                wt.Write("SS within each population\r\n");
                wt.Write("ID\t#Hap");
                if (AMOVA_IAM) wt.Write("\tIAM");
                if (AMOVA_SMM) wt.Write("\tSMM");
                wt.Write("\r\n");
                foreach (SUBPOP tp in subpops)
                {
                    wt.Write(tp.name + "\t" + tp.nhaplotypes);
                    if (AMOVA_IAM) wt.Write("\t" + tp.SS1.ToString(DECIMAL));
                    if (AMOVA_SMM) wt.Write("\t" + tp.SS2.ToString(DECIMAL));
                    wt.Write("\r\n");
                }
                wt.Write("\r\n");

                if (!AMOVA_IGNOREIND)
                {
                    wt.Write("SS within each individual\r\n");
                    wt.Write("ID\t#Hap");
                    if (AMOVA_IAM) wt.Write("\tIAM");
                    if (AMOVA_SMM) wt.Write("\tSMM");
                    wt.Write("\r\n");
                    foreach (IND ind in inds)
                    {
                        wt.Write(ind.name + "\t" + ind.ploidy);
                        if (AMOVA_IAM) wt.Write("\t" + ind.SS1.ToString(DECIMAL));
                        if (AMOVA_SMM) wt.Write("\t" + ind.SS2.ToString(DECIMAL));
                        wt.Write("\r\n");
                    }
                    wt.Write("\r\n");
                }
            }

            public void CalcAMOVA_geno(StreamWriter wt, bool sumss)
            {
                //Weight genotype model
                Progress = "Performing AMOVA";
                AMOVA_NLAY = (AMOVA_IGNOREIND ? 1 : 2) + regions.Length;

                foreach (IND ind in inds)
                    ind.SS1 = ind.SS2 = 0;

                for (int rl = 0; rl < regions.Length; ++rl)
                    foreach (SUBPOP tr in regions[rl])
                        tr.SS1 = tr.SS2 = 0;

                foreach (SUBPOP tp in subpops)
                    tp.SS1 = tp.SS2 = 0;

                double[] SS1 = new double[AMOVA_NLAY], SS2 = new double[AMOVA_NLAY];
                double[] V1 = new double[AMOVA_NLAY], V2 = new double[AMOVA_NLAY];
                double[] vs1 = new double[AMOVA_NLAY], vs2 = new double[AMOVA_NLAY];
                double[,] F1 = new double[AMOVA_NLAY, AMOVA_NLAY], F2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                AMOVA_IND = total_pop.inds;

                double[,] C = new double[AMOVA_NLAY, AMOVA_NLAY];
                AMOVA_NH_ANISO = total_pop.loc.Select(l => l.nhaplotypes).ToArray();
                AMOVA_NH = total_pop.nhaplotypes;
                ProgressValue = 0;
                ProgressMax = L;
                SetProgress(ProgressValue, ProgressMax);

                AMOVA_NIND = total_pop.inds.Length;
                if (AMOVA_IAM)
                {
                    AMOVA_GD1 = new double[L, AMOVA_NIND];
                    AMOVA_GDL1 = new double[L, AMOVA_NIND, AMOVA_NIND];

                }
                if (AMOVA_SMM)
                {
                    AMOVA_GD2 = new double[L, AMOVA_NIND];
                    AMOVA_GDL2 = new double[L, AMOVA_NIND, AMOVA_NIND];
                }

                //rearrange inds
                List<IND> inds2t = new List<IND>();
                total_pop.RearrangeInds(inds2t);
                IND[] inds2 = inds2t.ToArray();

                int tref = 0;
                VESSEL vs = new VESSEL(total_pop, AMOVA_NLAY, ref tref, -1, 3);

                //calc SS
                Parallel.For(0, L, new ParallelOptions() { MaxDegreeOfParallelism = N_THREAD }, l =>
                //for (int l = 0; l < L; ++l)
                {
                    double[] ss1 = new double[AMOVA_NLAY], ss2 = new double[AMOVA_NLAY];
                    double[] v1 = null, v2 = null;
                    double[,] c = new double[AMOVA_NLAY, AMOVA_NLAY];
                    double[] tw = new double[AMOVA_NLAY + 1];
                    int[] tid = new int[AMOVA_NLAY + 1];
                    vs.InitW();
                    VESSEL.InitC(c, tid, AMOVA_NH_ANISO[l]);
                    vs.GetC(tw, tid, c, l);

                    //SSWI
                    for (int i = 0; i < AMOVA_NIND; ++i)
                    {
                        IND ii = inds2[i];
                        PHENOTYPE pi = ii.g[l];
                        double sd1 = AMOVA_IAM ? pi.GetIAMDist() : 0;
                        double sd2 = AMOVA_SMM ? pi.GetSMMDist(NULLSQDIST[l]) : 0;
                        if (AMOVA_IAM) AMOVA_GD1[l, i] = sd1;
                        if (AMOVA_SMM) AMOVA_GD2[l, i] = sd2;
                        SUBPOP tp1 = ii.subpop, tp2 = null;

                        if (sd1 > 0 || sd2 > 0)
                        {
                            if (!AMOVA_IGNOREIND) lock (ii)
                                {
                                    if (AMOVA_IAM) ii.SS1 += sd1 / ii.ploidy;
                                    if (AMOVA_SMM) ii.SS2 += sd2 / ii.ploidy;
                                }

                            for (int clay = AMOVA_IGNOREIND ? 0 : 1; clay < AMOVA_NLAY; ++clay)
                            {
                                lock (tp1)
                                {
                                    if (AMOVA_IAM) tp1.SS1 += sd1 / tp1.loc[l].nhaplotypes;
                                    if (AMOVA_SMM) tp1.SS2 += sd2 / tp1.loc[l].nhaplotypes;
                                }
                                tp1 = tp1.region;
                            }
                        }

                        for (int j = i + 1; j < AMOVA_NIND; ++j)
                        {
                            IND ij = inds2[j];
                            PHENOTYPE pj = ij.g[l];
                            sd1 = AMOVA_IAM ? pi.GetIAMDist(pj) : 0;
                            sd2 = AMOVA_SMM ? pi.GetSMMDist(NULLSQDIST[l], pj) : 0;
                            if (AMOVA_IAM) AMOVA_GDL1[l, i, j] = AMOVA_GDL1[l, j, i] = sd1;
                            if (AMOVA_SMM) AMOVA_GDL2[l, i, j] = AMOVA_GDL2[l, j, i] = sd2;
                            tp1 = ii.subpop; tp2 = ij.subpop;
                            if (sd1 > 0 || sd2 > 0)
                            {
                                for (int clay = AMOVA_IGNOREIND ? 0 : 1; clay < AMOVA_NLAY; ++clay)
                                {
                                    if (tp1 == tp2) lock (tp1)
                                        {
                                            if (AMOVA_IAM) tp1.SS1 += sd1 / tp1.loc[l].nhaplotypes;
                                            if (AMOVA_SMM) tp1.SS2 += sd2 / tp1.loc[l].nhaplotypes;
                                        }
                                    tp1 = tp1.region;
                                    tp2 = tp2.region;
                                }
                            }
                        }
                    }

                    vs.GetSSGeno(c, ss1, ss2, l);

                    if (sumss)
                    {
                        lock (C)
                        {
                            Add(C, C, c);
                            if (AMOVA_IAM) Add(SS1, SS1, ss1);
                            if (AMOVA_SMM) Add(SS2, SS2, ss2);
                        }
                    }
                    else
                    {
                        //sum var
                        lock (C)
                        {
                            Add(C, C, c);
                        }
                        VESSEL.GetV(c, ss1, ss2, ref v1, ref v2);
                        lock (C)
                        {
                            if (AMOVA_IAM) Add(V1, V1, v1);
                            if (AMOVA_SMM) Add(V2, V2, v2);
                        }
                    }
                    Increment();
                });

                double VTOT1 = 0, VTOT2 = 0;
                if (sumss) VESSEL.GetV(C, SS1, SS2, ref V1, ref V2);
                VESSEL.GetF(V1, V2, ref VTOT1, ref VTOT2, F1, F2, vs1, vs2);

                ProgressValue = L;
                SetProgress(ProgressMax, ProgressMax);

                string[] levelstr = new string[AMOVA_NLAY], levelshortstr = new string[AMOVA_NLAY];

                if (AMOVA_IGNOREIND)
                {
                    levelstr[0] = "Populations";
                    levelshortstr[0] = "S";
                    for (int clay = 1; clay < AMOVA_NLAY; ++clay)
                    {
                        levelstr[clay] = "Regions level " + clay;
                        levelshortstr[clay] = "C" + clay;
                    }
                }
                else
                {
                    levelstr[0] = "Individuals";
                    levelshortstr[0] = "I";
                    levelstr[1] = "Populations";
                    levelshortstr[1] = "S";
                    for (int clay = 2; clay < AMOVA_NLAY; ++clay)
                    {
                        levelstr[clay] = "Regions level " + (clay - 1);
                        levelshortstr[clay] = "C" + (clay - 1);
                    }
                }
                levelstr[AMOVA_NLAY - 1] = "Total";
                levelshortstr[AMOVA_NLAY - 1] = "T";

                amova_F1 = new double[AMOVA_NLAY, AMOVA_NLAY]; amova_F2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                amova_F1sq = new double[AMOVA_NLAY, AMOVA_NLAY]; amova_F2sq = new double[AMOVA_NLAY, AMOVA_NLAY];
                amova_cF1 = new double[AMOVA_NLAY, AMOVA_NLAY]; amova_cF2 = new double[AMOVA_NLAY, AMOVA_NLAY];
                amova_eF1 = new double[AMOVA_NLAY, AMOVA_NLAY]; amova_eF2 = new double[AMOVA_NLAY, AMOVA_NLAY];

                Progress = "Permutating AMOVA";
                ProgressValue = 0;
                ProgressMax = AMOVA_PERMUTE * (int)BINOMIAL[AMOVA_IGNOREIND ? AMOVA_NLAY : AMOVA_NLAY - 1, 2];
                SetProgress(ProgressValue, ProgressMax);

                CallThread(AMOVAThreadGeno, N_THREAD,
                           new object[] { sumss, vs, F1, F2 },
                ProgressMax, ref ProgressValue);

                AMOVA_GD1 = AMOVA_GD2 = null;
                AMOVA_GDL1 = AMOVA_GDL2 = null;

                MulAmova(amova_F1, 1.0 / AMOVA_PERMUTE); MulAmova(amova_F2, 1.0 / AMOVA_PERMUTE);
                MulAmova(amova_F1sq, 1.0 / AMOVA_PERMUTE); MulAmova(amova_F2sq, 1.0 / AMOVA_PERMUTE);
                SubSqAmova(amova_F1sq, amova_F1); SubSqAmova(amova_F2sq, amova_F2);

                double[] DFB = new double[AMOVA_NLAY + 1];
                double[] SSB1 = new double[AMOVA_NLAY + 1], SSB2 = new double[AMOVA_NLAY + 1];
                double[] MS1 = new double[AMOVA_NLAY + 1], MS2 = new double[AMOVA_NLAY + 1];
                for (int i = 0; i < AMOVA_NLAY; ++i)
                {
                    DFB[i] = Math.Round(i > 0 ? (C[i, 0] - C[i - 1, 0]) : (C[i, 0]));
                    SSB1[i] = i > 0 ? SS1[i] - SS1[i - 1] : SS1[i];
                    SSB2[i] = i > 0 ? SS2[i] - SS2[i - 1] : SS2[i];
                    MS1[i] = SSB1[i] / DFB[i];
                    MS2[i] = SSB2[i] / DFB[i];
                }
                DFB[AMOVA_NLAY] = C[AMOVA_NLAY - 1, 0];
                SSB1[AMOVA_NLAY] = SS1[AMOVA_NLAY - 1];
                SSB2[AMOVA_NLAY] = SS2[AMOVA_NLAY - 1];
                MS1[AMOVA_NLAY] = SSB1[AMOVA_NLAY] / DFB[AMOVA_NLAY];
                MS2[AMOVA_NLAY] = SSB2[AMOVA_NLAY] / DFB[AMOVA_NLAY];

                if (AMOVA_IAM)
                {
                    wt.Write("Summary AMOVA Table (IAM), model: weight genotype\r\n");
                    wt.Write("Source      \td.f.\tSS\tMS\tVar\t%\r\n");

                    if (!(AMOVA_IGNOREIND && regions.Length == 0))
                        wt.Write("Within " + levelstr[0] + "\t" + DFB[0].ToString("F0") + "\t" + SSB1[0].ToString(DECIMAL) + "\t" + MS1[0].ToString(DECIMAL) + "\t" + V1[0].ToString(DECIMAL) + "\t" + (V1[0] * 100.0 / VTOT1).ToString(DECIMAL) + "\r\n");
                    for (int clay = 1; clay < AMOVA_NLAY; ++clay)
                        wt.Write("Among " + levelstr[clay - 1] + "\t" + DFB[clay].ToString("F0") + "\t" + SSB1[clay].ToString(DECIMAL) + "\t" + MS1[clay].ToString(DECIMAL) + "\t" + V1[clay].ToString(DECIMAL) + "\t" + (V1[clay] * 100.0 / VTOT1).ToString(DECIMAL) + "\r\n");
                    wt.Write("Total\t" + DFB[AMOVA_NLAY].ToString("F0") + "\t" + SSB1[AMOVA_NLAY].ToString(DECIMAL) + "\t" + MS1[AMOVA_NLAY].ToString(DECIMAL) + "\t" + VTOT1.ToString(DECIMAL) + "\t" + (VTOT1 * 100.0 / VTOT1).ToString(DECIMAL) + "\r\n");
                    wt.Write("\r\n");
                
                    wt.Write("F-statistics (IAM) \tValue\tPermMean\tPermVar\tP(rand>obs)\tP(rand=obs)\r\n");
                    for (int i = 0; i < AMOVA_NLAY; ++i)
                        for (int j = i + 1; j < AMOVA_NLAY; ++j)
                            wt.Write("F" + levelshortstr[i] + levelshortstr[j] + "\t" + F1[i, j].ToString(DECIMAL)
                                      + (i == 0 ? "\t\t\t\t\r\n" :
                               "\t" + amova_F1[i, j].ToString(DECIMAL)
                               + "\t" + amova_F1sq[i, j].ToString(DECIMAL)
                               + "\t" + (amova_cF1[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                               + "\t" + (amova_eF1[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                               + "\r\n"));
                    wt.Write("\r\n");
                }

                if (AMOVA_SMM)
                {
                    wt.Write("Summary AMOVA Table (SMM), model: weight genotype\r\n");
                    wt.Write("Source      \td.f.\tSS\tMS\tVar\t%\r\n");

                    if (!(AMOVA_IGNOREIND && regions.Length == 0))
                        wt.Write("Within " + levelstr[0] + "\t" + DFB[0].ToString("F0") + "\t" + SSB2[0].ToString(DECIMAL) + "\t" + MS2[0].ToString(DECIMAL) + "\t" + V2[0].ToString(DECIMAL) + "\t" + (V2[0] * 100.0 / VTOT2).ToString(DECIMAL) + "\r\n");
                    for (int clay = 1; clay < AMOVA_NLAY; ++clay)
                        wt.Write("Among " + levelstr[clay - 1] + "\t" + DFB[clay].ToString("F0") + "\t" + SSB2[clay].ToString(DECIMAL) + "\t" + MS2[clay].ToString(DECIMAL) + "\t" + V2[clay].ToString(DECIMAL) + "\t" + (V2[clay] * 100.0 / VTOT2).ToString(DECIMAL) + "\r\n");
                    wt.Write("Total\t" + DFB[AMOVA_NLAY].ToString("F0") + "\t" + SSB2[AMOVA_NLAY].ToString(DECIMAL) + "\t" + MS2[AMOVA_NLAY].ToString(DECIMAL) + "\t" + VTOT2.ToString(DECIMAL) + "\t" + (VTOT2 * 100.0 / VTOT2).ToString(DECIMAL) + "\r\n");
                    wt.Write("\r\n");
                
                    wt.Write("F-statistics (SMM) \tValue\tPermMean\tPermVar\tP(rand>obs)\tP(rand=obs)\r\n");
                    for (int i = 0; i < AMOVA_NLAY; ++i)
                        for (int j = i + 1; j < AMOVA_NLAY; ++j)
                            wt.Write("F" + levelshortstr[i] + levelshortstr[j] + "\t" + F2[i, j].ToString(DECIMAL)
                                      + (i == 0 ? "\t\t\t\t\r\n" :
                               "\t" + amova_F2[i, j].ToString(DECIMAL)
                               + "\t" + amova_F2sq[i, j].ToString(DECIMAL)
                               + "\t" + (amova_cF2[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                               + "\t" + (amova_eF2[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                               + "\r\n"));
                    wt.Write("\r\n");
                }

                for (int rl = regions.Length - 2; rl >= 0; --rl)
                {
                    wt.Write("SS within each region level " + (rl + 1) + "\r\n");
                    wt.Write("ID\t#Hap");
                    if (AMOVA_IAM) wt.Write("\tIAM");
                    if (AMOVA_SMM) wt.Write("\tSMM");
                    wt.Write("\r\n");
                    for (int i = 0; i < regions[rl].Length; ++i)
                    {
                        SUBPOP tr = regions[rl][i];
                        wt.Write(tr.name + "\t" + tr.nhaplotypes);
                        if (AMOVA_IAM) wt.Write("\t" + tr.SS1.ToString(DECIMAL));
                        if (AMOVA_SMM) wt.Write("\t" + tr.SS2.ToString(DECIMAL));
                        wt.Write("\r\n");
                    }
                    wt.Write("\r\n");
                }

                wt.Write("SS within each population\r\n");
                wt.Write("ID\t#Hap");
                if (AMOVA_IAM) wt.Write("\tIAM");
                if (AMOVA_SMM) wt.Write("\tSMM");
                wt.Write("\r\n");
                foreach (SUBPOP tp in subpops)
                {
                    wt.Write(tp.name + "\t" + tp.nhaplotypes);
                    if (AMOVA_IAM) wt.Write("\t" + tp.SS1.ToString(DECIMAL));
                    if (AMOVA_SMM) wt.Write("\t" + tp.SS2.ToString(DECIMAL));
                    wt.Write("\r\n");
                }
                wt.Write("\r\n");

                if (!AMOVA_IGNOREIND)
                {
                    wt.Write("SS within each individual\r\n");
                    wt.Write("ID\t#Hap");
                    if (AMOVA_IAM) wt.Write("\tIAM");
                    if (AMOVA_SMM) wt.Write("\tSMM");
                    wt.Write("\r\n");
                    foreach (IND ind in inds)
                    {
                        wt.Write(ind.name + "\t" + ind.ploidy);
                        if (AMOVA_IAM) wt.Write("\t" + ind.SS1.ToString(DECIMAL));
                        if (AMOVA_SMM) wt.Write("\t" + ind.SS2.ToString(DECIMAL));
                        wt.Write("\r\n");
                    }
                    wt.Write("\r\n");
                }
            }

            public void CalcAMOVA_ml(StreamWriter wt, bool isgeno)
            {
                //Anisoploid model
                Progress = "Performing AMOVA";
                AMOVA_NLAY = (AMOVA_IGNOREIND ? 1 : 2) + regions.Length;
                if (AMOVA_NLAY == 1) return;
                List<IND> indst = new List<IND>();
                GetInds(total_pop, indst);
                IND[] inds = indst.ToArray();

                int tref = 0;
                VESSEL vs = new VESSEL(total_pop, AMOVA_NLAY, ref tref, -1, 4);
                double[] Fi = new double[AMOVA_NLAY]; //FIS FIC1 FIC2 FIT
                double[,] F1 = new double[AMOVA_NLAY, AMOVA_NLAY]; //FIS FIC1 FIC2 FIT
                AMOVA_NH_ANISO = total_pop.loc.Select(l => l.nhaplotypes).ToArray();
                AMOVA_NH = total_pop.nhaplotypes;
                ProgressValue = 0;
                ProgressMax = AMOVA_NLAY - 1;
                SetProgress(ProgressValue, ProgressMax);

                for (int clay = AMOVA_IGNOREIND ? 0 : 1; clay < AMOVA_NLAY; ++clay)
                {
                    Point4 x = Point4.DownHillSimplex(1, 10, vs.Likelihood, new object[] { clay, isgeno, inds });
                    Fi[clay] = x.real[0];
                    Increment();
                }

                VESSEL.GetF(Fi, ref F1);

                ProgressValue = (AMOVA_NLAY - 1);
                SetProgress(ProgressMax, ProgressMax);

                double[] V1 = new double[AMOVA_NLAY];
                if (!AMOVA_IGNOREIND)
                {
                    V1[0] = 1 - Fi[AMOVA_NLAY - 1];
                    V1[1] = AMOVA_NLAY == 2 ? 1 - V1[0] : Fi[1] * (1.0 - Fi[AMOVA_NLAY - 1]) / (1.0 - Fi[1]);
                    if (AMOVA_NLAY > 2) V1[AMOVA_NLAY - 1] = (Fi[AMOVA_NLAY - 1] - Fi[AMOVA_NLAY - 2]) / (1.0 - Fi[AMOVA_NLAY - 2]);
                    for (int clay = 2; clay < AMOVA_NLAY - 1; ++clay)
                        V1[clay] = (Fi[clay] - Fi[clay - 1]) * (1 - Fi[AMOVA_NLAY - 1]) / ((1 - Fi[clay - 1]) * (1 - Fi[clay]));
                }
                else
                {
                    double[] VV1 = new double[AMOVA_NLAY + 1];
                    VV1[0] = 1 - Fi[AMOVA_NLAY - 1];
                    VV1[1] = AMOVA_NLAY == 2 ? 1 - VV1[0] : Fi[0] * (1.0 - Fi[AMOVA_NLAY - 1]) / (1.0 - Fi[0]);
                    if (AMOVA_NLAY > 1) VV1[AMOVA_NLAY] = (Fi[AMOVA_NLAY - 1] - Fi[AMOVA_NLAY - 2]) / (1.0 - Fi[AMOVA_NLAY - 2]);
                    for (int clay = 1; clay < AMOVA_NLAY - 1; ++clay)
                        VV1[clay + 1] = (Fi[clay] - Fi[clay - 1]) * (1 - Fi[AMOVA_NLAY - 1]) / ((1 - Fi[clay - 1]) * (1 - Fi[clay]));
                    for (int i = 0; i < AMOVA_NLAY; ++i)
                        V1[i] = VV1[i + 1];
                    V1[0] += VV1[0];
                }

                double SSTOT1 = 0;
                for (int l = 0; l < L; ++l)
                {
                    if (total_pop.loc[l].nhaplotypes == 0) continue;
                    double nh = total_pop.loc[l].nhaplotypes;
                    SSTOT1 += (1.0 - 1.0 / total_pop.loc[l].AE) * 0.5 * nh;
                }

                double[,] C = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[,] c = new double[AMOVA_NLAY, AMOVA_NLAY];
                double[] tw = new double[AMOVA_NLAY + 1];
                int[] tid = new int[AMOVA_NLAY + 1];

                vs.InitW();
                for (int l = 0; l < L; ++l)
                {
                    vs.GetCML(c, l, tid, tw);
                    Add(C, C, c);
                }

                double sstot1 = 0;
                for (int i = 0; i < AMOVA_NLAY; ++i)
                    sstot1 += C[AMOVA_NLAY - 1, i] * V1[i];
                double VTOT1 = SSTOT1 / sstot1;
                Mul(V1, V1, VTOT1);
                LinearAlgebra.MatrixBuilder<double> MAT = LinearAlgebra.Matrix<double>.Build;
                double[] SS1 = (MAT.DenseOfArray(C) * MAT.DenseOfColumnArrays(V1).RowSums()).ToArray();

                string[] levelstr = new string[AMOVA_NLAY], levelshortstr = new string[AMOVA_NLAY];

                if (AMOVA_IGNOREIND)
                {
                    levelstr[0] = "Populations";
                    levelshortstr[0] = "S";
                    for (int clay = 1; clay < AMOVA_NLAY; ++clay)
                    {
                        levelstr[clay] = "Regions level " + clay;
                        levelshortstr[clay] = "C" + clay;
                    }
                }
                else
                {
                    levelstr[0] = "Individuals";
                    levelshortstr[0] = "I";
                    levelstr[1] = "Populations";
                    levelshortstr[1] = "S";
                    for (int clay = 2; clay < AMOVA_NLAY; ++clay)
                    {
                        levelstr[clay] = "Regions level " + (clay - 1);
                        levelshortstr[clay] = "C" + (clay - 1);
                    }
                }
                levelstr[AMOVA_NLAY - 1] = "Total";
                levelshortstr[AMOVA_NLAY - 1] = "T";

                Progress = "Permutating AMOVA";
                ProgressValue = 0;
                ProgressMax = AMOVA_PERMUTE * (int)BINOMIAL[AMOVA_IGNOREIND ? AMOVA_NLAY : AMOVA_NLAY - 1, 2];
                SetProgress(ProgressValue, ProgressMax);

                amova_F1 = new double[AMOVA_NLAY, AMOVA_NLAY];
                amova_F1sq = new double[AMOVA_NLAY, AMOVA_NLAY];
                amova_cF1 = new double[AMOVA_NLAY, AMOVA_NLAY];
                amova_eF1 = new double[AMOVA_NLAY, AMOVA_NLAY];

                CallThread(AMOVAThreadML, N_THREAD, new object[] { isgeno, vs, F1, inds }, ProgressMax, ref ProgressValue);

                AMOVA_GD1 = AMOVA_GD2 = null;
                AMOVA_GDL1 = AMOVA_GDL2 = null;

                MulAmova(amova_F1, 1.0 / AMOVA_PERMUTE);
                MulAmova(amova_F1sq, 1.0 / AMOVA_PERMUTE);
                SubSqAmova(amova_F1sq, amova_F1);

                double[] DFB = new double[AMOVA_NLAY + 1];
                double[] SSB1 = new double[AMOVA_NLAY + 1];
                double[] MS1 = new double[AMOVA_NLAY + 1];
                for (int i = 0; i < AMOVA_NLAY; ++i)
                {
                    DFB[i] = Math.Round(i > 0 ? (C[i, 0] - C[i - 1, 0]) : (C[i, 0]));
                    SSB1[i] = i > 0 ? SS1[i] - SS1[i - 1] : SS1[i];
                    MS1[i] = SSB1[i] / DFB[i];
                }
                DFB[AMOVA_NLAY] = C[AMOVA_NLAY - 1, 0];
                SSB1[AMOVA_NLAY] = SS1[AMOVA_NLAY - 1];
                MS1[AMOVA_NLAY] = SSB1[AMOVA_NLAY] / DFB[AMOVA_NLAY];

                wt.Write("Summary AMOVA Table (IAM), model: maximum-likelihood\r\n");
                wt.Write("Source      \td.f.\tSS\tMS\tVar\t%\r\n");

                if (!(AMOVA_IGNOREIND && regions.Length == 0))
                    wt.Write("Within " + levelstr[0] + "\t" + DFB[0].ToString("F0") + "\t" + SSB1[0].ToString(DECIMAL) + "\t" + MS1[0].ToString(DECIMAL) + "\t" + V1[0].ToString(DECIMAL) + "\t" + (V1[0] * 100.0 / VTOT1).ToString(DECIMAL) + "\r\n");
                for (int clay = 1; clay < AMOVA_NLAY; ++clay)
                    wt.Write("Among " + levelstr[clay - 1] + "\t" + DFB[clay].ToString("F0") + "\t" + SSB1[clay].ToString(DECIMAL) + "\t" + MS1[clay].ToString(DECIMAL) + "\t" + V1[clay].ToString(DECIMAL) + "\t" + (V1[clay] * 100.0 / VTOT1).ToString(DECIMAL) + "\r\n");
                wt.Write("Total\t" + DFB[AMOVA_NLAY].ToString("F0") + "\t" + SSB1[AMOVA_NLAY].ToString(DECIMAL) + "\t" + MS1[AMOVA_NLAY].ToString(DECIMAL) + "\t" + VTOT1.ToString(DECIMAL) + "\t" + (VTOT1 * 100.0 / VTOT1).ToString(DECIMAL) + "\r\n");
                wt.Write("\r\n");

                wt.Write("F-statistics (IAM) \tValue\tPermMean\tPermVar\tP(rand>obs)\tP(rand=obs)\r\n");
                for (int i = 0; i < AMOVA_NLAY; ++i)
                    for (int j = i + 1; j < AMOVA_NLAY; ++j)
                        wt.Write("F" + levelshortstr[i] + levelshortstr[j] + "\t" + F1[i, j].ToString(DECIMAL)
                                  + (!AMOVA_IGNOREIND && i == 0 ? "\t\t\t\t\r\n" :
                           "\t" + amova_F1[i, j].ToString(DECIMAL)
                           + "\t" + amova_F1sq[i, j].ToString(DECIMAL)
                           + "\t" + (amova_cF1[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                           + "\t" + (amova_eF1[i, j] / (AMOVA_PERMUTE + 1)).ToString(DECIMAL)
                           + "\r\n"));
                wt.Write("\r\n");
            }

            #endregion

            #region Structure

            public class STRUCTURE
            {
                //parameters and common parts
                public string file;
                public int ntotruns;

                //model
                public bool admix;
                public bool locpriori;
                public bool fmodel;
                public bool allownull;

                //mcmc
                public int seed;
                public int kmin;
                public int kmax;
                public int nburnin;
                public int nreps;
                public int nthinning;
                public int nruns;

                //allele freq and admix burnin
                public double lambda;
                public double stdlambda;
                public double maxlambda;
                public int admburnin;
               // public int nadmburnin = (!STRUCTURE_LOCPRIORI && !STRUCTURE_ADMIXTURE) ? STRUCTURE_ADMBURNIN : 0;
                public bool inferlambda;
                public bool difflambda;

                //admix
                public double alpha0;
                public double stdalpha;
                public double maxalpha;
                public int metrofreq;
                public double alphapriora;
                public double alphapriorb;
                public bool inferalpha;
                public bool diffalpha;
                public bool gammaalpha;

                //loc priori
                public double maxr;
                public double epsr;
                public double epseta;
                public double epsgamma;

                //f model
                public double fpriormean;
                public double fpriorstd;
                public double fstdf;
                public bool fsame;

                //data
                public int N;
                public int S;
                public int L;
                public int Jt;//total number of alleles
                public int Nrecord;
                public int Nburninrec;

                public int[] subpopid;//N
                public string[] indname; //N
                public int[] subpopninds; //S
                public string[] subpopname; //S
                public string[] locusname; //L
                public int[] J; //L number of alleles at each lcous
                public int[] alleleid;//Jt alleleid

                //End of header
                public int[] V;//individual ploidy, N
                public int eL; //eL = J.Count(j => j > 0);
                public int nhaplo;
                public int maxploidy;
                public int[] Jdis; //Jdis[k] = number of loci has k alleles
                public double[,] hap; //nhaplo*Jt //the allele frequency in each haplotype
                public double[] totfreq;

                //Private part
                public int nsummary = 1; 
                public int threadid = -1; //-1 or not done
                public int K; //number of putative subpops

                //Record
                public int rlen;
                public double[] rout;
                public double[,] RZ;//Zs  record N*K
                public double[,] RFreq;//allele frequency record K*Jt
                public double[] trace;

                //End of File
                public int m; //current rep
                public int nr; //n recorded
                public int nt; //n recorded

                public Random rnd;
                public int taskid;//1-based
                public bool binaryq;//is q only takes from 0 and 1

                //Drawing  
                public LOC[][] loc;
                public string res;

                //Buffer
                private double[] buff;
                private FastLog[] flog;

                //Fixed
                private double r;

                private double[,] Freq;//allele frequency K*Jt
                private double[] Lambda;//K Priori dirichlet parameter
                private int[,] Z;//[N] * vt
                private double[,] Q;//N*K, proportion of gene in each cluster
                private double[,] Mi;//N*K, number of haplotypes assigned to each cluster
                private double[,] Ni;//K*Jt, number of alleles in each cluster
                private double[] Alpha;//K

                //LocPriori model
                private double[] Eta;//K
                private double[,] Gamma; //S*K
                private double[,] Di;//S*K, number of individual from s into k

                private double[,] AlphaLocal; //S*K
                private double[] SumAlpha; //S

                //F model, epsilon, ancestral population
                private double[] f;//K   (1-F)/F
                private double[] F;//K    Fst

                private double[] PA; //Epsilon
                private double[] PA1, PA2;

                public int[] PopSeq(bool rearrange)
                {
                    int[] seq = GetIdxSeq(K);

                    if (!rearrange) return seq;
                    List<int> popid = new List<int>();
                    for (int i = 0; i < K; ++i)
                        popid.Add(i);

                    for (int k = 0; k < K - 1; ++k)
                    {
                        int maxk = 0;
                        double maxZ = 0;
                        for (int i = 0; i < N; ++i)
                        {
                            foreach (int j in popid)
                                if (RZ[i, j] > maxZ)
                                {
                                    maxZ = RZ[i, j];
                                    maxk = j;
                                }
                        }
                        seq[k] = maxk;
                        popid.Remove(maxk);
                    }
                    seq[K - 1] = popid[0];

                    return seq;
                }

                public Image Drawplot(ref byte[] VecFile, STRUCTURE[] pars)
                {
                    if (threadid == -1) return null;

                    if (STRUCTURE_STYLE == StructurePlotType.LikelihoodConvergency)
                    {
                        if (pars == null)
                            return BAYESASS.DrawLineplot(Nburninrec, 
                                new double[][] { trace }, new int[] { taskid - 1 }, ntotruns, ref VecFile);
                        else
                        {
                            List<STRUCTURE> plist = pars.Where(p => p.threadid != -1).ToList();
                            plist.Add(this);
                            return BAYESASS.DrawLineplot(Nburninrec,
                                plist.Select(p => p.trace).ToArray(), plist.Select(p => p.taskid - 1).ToArray(),
                                ntotruns, ref VecFile);
                        }
                    }
                    if (K <= 0) return null;
                    int[] popseq = PopSeq(STRUCTURE_REARRANGE);
                    int[] coloridx = new int[K];
                    for (int i = 0; i < K; ++i)
                        coloridx[popseq[i]] = i;

                    float picheight = 150, picwidth = 2400f / N, sepwidth = picwidth;

                    if (STRUCTURE_STYLE == StructurePlotType.BarPlotOriginal)
                    {
                        Color[] co = GetColor(K, ColorMode.BarPlotWhiteBackground);
                        Bitmap bmp = new Bitmap((int)(N * picwidth + 1), (int)picheight);
                        Stream ms = new MemoryStream();
                        Metafile mf = new Metafile(ms, Graphics.FromImage(bmp).GetHdc(),
                            new Rectangle(0, 0, bmp.Width, bmp.Height), MetafileFrameUnit.Pixel, EmfType.EmfPlusDual);
                        Graphics g = Graphics.FromImage(mf);

                        g.Clear(Color.White);
                        Pen[] p = new Pen[K];

                        for (int j = 0; j < K; ++j)
                        {
                            p[j] = new Pen(co[j]);
                            p[j].Width = picwidth;
                        }

                        float cx = (float)picwidth / 2;
                        for (int i = 0; i < N; ++i)
                        {
                            double cp = 0;
                            foreach (int j in popseq)
                            {
                                g.DrawLine(p[coloridx[j]], cx, (float)(picheight * cp), cx, (float)(picheight * (cp + RZ[i, j])));
                                cp += RZ[i, j];
                            }
                            cx += picwidth;
                        }

                        g.Dispose();
                        ms.Seek(0, SeekOrigin.Begin);
                        VecFile = new byte[ms.Length];
                        ms.Read(VecFile, 0, (int)ms.Length);
                        ms.Seek(0, SeekOrigin.Begin);

                        g = Graphics.FromImage(bmp);
                        g.DrawImage(mf, 0, 0, bmp.Width, bmp.Height);
                        MemoryStream m = new MemoryStream();
                        bmp.Save(m, ImageFormat.Png);

                        mf.Dispose();
                        ms.Dispose();
                        g.Dispose();
                        bmp.Dispose();

                        return Image.FromStream(m);
                    }
                    else if (STRUCTURE_STYLE == StructurePlotType.BarPlotGroupByPop)
                    {
                        Color[] co = GetColor(K, ColorMode.BarPlotWhiteBackground);
                        int npops = subpopid.Max() + 1;
                        Bitmap bmp = new Bitmap((int)(N * picwidth + (npops - 1) * sepwidth + 1), (int)picheight + 20);
                        Stream ms = new MemoryStream();
                        Metafile mf = new Metafile(ms, Graphics.FromImage(bmp).GetHdc(), new Rectangle(0, 0, bmp.Width, bmp.Height), MetafileFrameUnit.Pixel, EmfType.EmfPlusDual);
                        Graphics g = Graphics.FromImage(mf);

                        g.Clear(Color.White);
                        Pen[] p = new Pen[K];
                        Pen p2 = new Pen(Color.FromArgb(0), sepwidth);

                        for (int j = 0; j < K; ++j)
                        {
                            p[j] = new Pen(co[j]);
                            p[j].Width = picwidth;
                        }
                        List<int>[] s = new List<int>[npops];
                        for (int i = 0; i < npops; ++i)
                            s[i] = new List<int>();

                        for (int j = 0; j < N; ++j)
                            s[subpopid[j]].Add(j);

                        float cx = 0;
                        StringFormat stf = new StringFormat();
                        stf.Alignment = StringAlignment.Center;
                        stf.LineAlignment = StringAlignment.Near;
                        for (int k = 0; k < s.Length; ++k)
                        {
                            g.DrawLine(p2,
                                cx, picheight + (k % 2 == 0 ? 1 : 3),
                                cx + picwidth * s[k].Count, picheight + (k % 2 == 0 ? 1 : 3));

                            g.DrawString(subpopname[k],
                                new Font("Arial", 10f / DPI_SCALE),
                                new SolidBrush(Color.Black),
                                new RectangleF(
                                    cx, picheight + 2,
                                    picwidth * s[k].Count, 18),
                                stf);

                            for (int i = 0; i < s[k].Count; ++i)
                            {
                                double cp = 0;
                                foreach (int j in popseq)
                                {
                                    g.DrawLine(p[coloridx[j]],
                                        cx + picwidth / 2, (float)(picheight * cp),
                                        cx + picwidth / 2, (float)(picheight * (cp + RZ[s[k][i], j])));
                                    cp += RZ[s[k][i], j];
                                }
                                cx += picwidth;
                            }
                            cx += sepwidth;
                        }

                        g.Dispose();
                        ms.Seek(0, SeekOrigin.Begin);
                        VecFile = new byte[ms.Length];
                        ms.Read(VecFile, 0, (int)ms.Length);
                        ms.Seek(0, SeekOrigin.Begin);

                        g = Graphics.FromImage(bmp);
                        g.DrawImage(mf, 0, 0, bmp.Width, bmp.Height);
                        MemoryStream m = new MemoryStream();
                        bmp.Save(m, ImageFormat.Png);

                        mf.Dispose();
                        ms.Dispose();
                        g.Dispose();
                        bmp.Dispose();

                        return Image.FromStream(m);
                    }
                    else if (STRUCTURE_STYLE == StructurePlotType.BarPlotSortByQ)
                    {
                        Color[] co = GetColor(K, ColorMode.BarPlotWhiteBackground);
                        Bitmap bmp = new Bitmap((int)(N * picwidth + 1), (int)picheight);
                        Stream ms = new MemoryStream();
                        Metafile mf = new Metafile(ms, Graphics.FromImage(bmp).GetHdc(), new Rectangle(0, 0, bmp.Width, bmp.Height), MetafileFrameUnit.Pixel, EmfType.EmfPlusDual);
                        Graphics g = Graphics.FromImage(mf);

                        g.Clear(Color.White);
                        Pen[] p = new Pen[K];

                        StructureSortByQEntry[] spr = new StructureSortByQEntry[N];
                        double[] subpopcount = new double[K];
                        int[] index = GetIdxSeq(N);

                        for (int i = 0; i < N; ++i)
                        {
                            spr[i] = new StructureSortByQEntry();
                            spr[i].pop = -1;
                            spr[i].pr = 0;
                            for (int j = 0; j < K; ++j)
                            {
                                subpopcount[j] += RZ[i, j];
                                if (spr[i].pr < RZ[i, j])
                                {
                                    spr[i].pr = RZ[i, j];
                                    spr[i].pop = j;
                                }
                            }
                        }

                        for (int i = 0; i < N; ++i)
                            for (int j = 0; j < i; ++j)
                                if (spr[index[i]].pop != spr[index[j]].pop && subpopcount[spr[index[i]].pop] > subpopcount[spr[index[j]].pop] ||
                                    spr[index[i]].pop == spr[index[j]].pop && spr[index[i]].pr > spr[index[j]].pr)
                                {
                                    int t = index[i];
                                    index[i] = index[j];
                                    index[j] = t;
                                }

                        for (int j = 0; j < K; ++j)
                        {
                            p[j] = new Pen(co[j]);
                            p[j].Width = picwidth;
                        }

                        float cx = picwidth / 2;
                        for (int i = 0; i < N; ++i)
                        {
                            double cp = 0;
                            foreach (int j in popseq)
                            {
                                g.DrawLine(p[coloridx[j]], cx, (float)(picheight * cp), cx, (float)(picheight * (cp + RZ[index[i], j])));
                                cp += RZ[index[i], j];
                            }
                            cx += picwidth;
                        }

                        g.Dispose();
                        ms.Seek(0, SeekOrigin.Begin);
                        VecFile = new byte[ms.Length];
                        ms.Read(VecFile, 0, (int)ms.Length);
                        ms.Seek(0, SeekOrigin.Begin);

                        g = Graphics.FromImage(bmp);
                        g.DrawImage(mf, 0, 0, bmp.Width, bmp.Height);
                        MemoryStream m = new MemoryStream();
                        bmp.Save(m, ImageFormat.Png);

                        mf.Dispose();
                        ms.Dispose();
                        g.Dispose();
                        bmp.Dispose();

                        return Image.FromStream(m);
                    }
                    return null;
                }

                public void GetParamsString(StringBuilder re)
                {
                    re.Append("Seed=" + seed);
                    re.Append(",#Inds=" + N);
                    re.Append(",#Loci=" + L);
                    re.Append(",Kmin=" + kmin);
                    re.Append(",Kmax=" + kmax);
                    re.Append(",#Burnin=" + nburnin);
                    re.Append(",#Reps=" + nreps);
                    re.Append(",#Thinning=" + nthinning);
                    re.Append(",#Runs=" + nruns);
                    re.Append(",#AdmBurnin=" + admburnin);

                    re.Append(",λ=" + lambda.ToString(DECIMAL));
                    re.Append(",std(λ)=" + stdlambda.ToString(DECIMAL));
                    re.Append(",max(λ)=" + maxlambda.ToString(DECIMAL));
                    re.Append(",Infer λ=" + inferlambda);
                    re.Append(",Diff λ=" + difflambda);

                    re.Append(",α0=" + alpha0.ToString(DECIMAL));
                    re.Append(",std(α)=" + stdalpha.ToString(DECIMAL));
                    re.Append(",max(α)=" + maxalpha.ToString(DECIMAL));
                    re.Append(",Frequency of Metropolis update for Q=" + metrofreq);
                    re.Append(",Infer α=" + inferalpha);
                    re.Append(",Diff α=" + diffalpha);
                    re.Append(",α gamma disributed=" + gammaalpha);
                    re.Append(",α priori A=" + alphapriora.ToString(DECIMAL));
                    re.Append(",α priori B=" + alphapriorb.ToString(DECIMAL));

                    re.Append(",max(r)=" + maxr.ToString(DECIMAL));
                    re.Append(",eps(r)=" + epsr.ToString(DECIMAL));
                    re.Append(",eps(η)=" + epseta.ToString(DECIMAL));
                    re.Append(",eps(γ)=" + epsgamma.ToString(DECIMAL));

                    re.Append(",F priori mean=" + fpriormean.ToString(DECIMAL));
                    re.Append(",F priori std=" + fpriorstd.ToString(DECIMAL));
                    re.Append(",std(f)=" + fstdf.ToString(DECIMAL));

                    re.Append("\r\n\r\nModel: " + (admix ? "ADMIXTURE" : "NO ADMIXTURE") + ", " + (locpriori ? "LOCPRIOR" : "NO LOCPRIOR") + ", " + (fmodel ? (fsame ? "F-MODEL (single F)" : "F-MODEL (multiple F)") : "NO FMODEL") + ", " + (allownull ? "NULLALLELE" : "NO NULLALLELE"));
                }


                public string GetRunString(STRUCTURE[] pars)
                {
                    if (pars == null && threadid == -1)
                        res = "Not finished.";

                    if (res != null && res != "")
                        return res;

                    StringBuilder re = new StringBuilder();
                    re.Append("Results for " + nsummary + (nsummary == 1 ? " run.\r\n" : " runs.\r\n"));
                    GetParamsString(re);

                    if (pars == null)
                        pars = new STRUCTURE[] { this };

                    re.Append("\r\n\r\nid\tK\tMean lnL\tVar lnL\tln PD\r\n");

                    foreach (STRUCTURE p in pars)
                    {
                        if (p.threadid == -1)
                            re.Append(p.taskid + "\tNot finished.\r\n");
                        else
                        {
                            re.Append(
                                p.taskid + "\t" +
                                p.K + "\t" +
                                p.rout[0].ToString(DECIMAL) + "\t" +
                                p.rout[2].ToString(DECIMAL) + "\t" +
                                p.rout[3].ToString(DECIMAL) + "\r\n");
                        }
                    }

                    if (pars.Count(p => threadid != -1) == 0 || K <= 0)
                        return res = re.ToString();

                    re.Append("\r\nEstimated Ln Prob of Data\t= " + rout[3].ToString(DECIMAL));
                    re.Append("\r\nMean value of ln likelihood\t= " + rout[0].ToString(DECIMAL));
                    re.Append("\r\nVariance of ln likelihood\t= " + rout[2].ToString(DECIMAL));

                    int nf = fmodel ? (fsame ? 1 : K) : 0;
                    int na = admix ? (diffalpha ? K : 1) : 0;
                    int nl = difflambda ? K : 1;

                    if (inferlambda)
                    {
                        if (!difflambda)
                            re.Append("\r\nMean value of lambda\t= " + rout[4].ToString(DECIMAL));
                        else for (int j = 0; j < K; ++j)
                                re.Append("\r\nMean value of lambda_" + (j + 1).ToString() + "\t= "
                                          + rout[4 + j].ToString(DECIMAL));
                    }

                    if (locpriori)
                    {
                        re.Append("\r\nMean value of r\t= " + rout[4 + nl].ToString(DECIMAL));
                        re.Append("\r\nMean value of global " + (admix ? "alpha" : "eta"));
                        re.Append("\r\n\tCluster\r\n");
                        for (int j = 0; j < K; ++j)
                            re.Append("\t" + (j + 1).ToString());
                        re.Append("\r\n");
                        for (int j = 0; j < K; ++j)
                            re.Append("\t" + rout[4 + nl + 1 + j].ToString(DECIMAL));
                        re.Append("\r\nMean value of local " + (admix ? "alpha" : "gamma") + " for each location");
                        re.Append("\r\n\tCluster\r\nPop");
                        for (int j = 0; j < K; ++j)
                            re.Append("\t" + (j + 1).ToString());
                        for (int i = 0; i < S; ++i)
                        {
                            re.Append("\r\n" + subpopname[i]);
                            for (int j = 0; j < K; ++j)
                                re.Append("\t" + rout[4 + nl + 1 + K + i * K + j].ToString(DECIMAL));
                        }
                    }
                    else if (admix && inferalpha)
                    {
                        if (!diffalpha)
                            re.Append("\r\nMean value of alpha\t= " + rout[4 + nl].ToString(DECIMAL));
                        else for (int j = 0; j < K; ++j)
                                re.Append("\r\nMean value of alpha_" + (j + 1).ToString() + "\t= "
                                          + rout[4 + nl + j].ToString(DECIMAL));
                    }

                    if (fmodel)
                    {
                        if (fsame)
                            re.Append("\r\nMean value of Fst = " + rout[rout.Length - 1].ToString(DECIMAL));
                        else
                        {
                            re.Append("\r\nMean value of Fst");
                            re.Append("\r\n\tCluster\r\n");
                            for (int j = 0; j < K; ++j)
                                re.Append("\t" + (j + 1).ToString());
                            re.Append("\r\n");
                            for (int i = 0; i < nf; ++i)
                                re.Append("\t" + rout[rout.Length - nf + i].ToString(DECIMAL));
                        }
                    }

                    re.Append("\r\n\r\nProportion of membership of each pre-defined population in each of the " + K + " clusters");
                    re.Append("\r\n\tCluster\r\nPop");
                    for (int j = 0; j < K; ++j)
                        re.Append("\t" + (j + 1).ToString());

                    double[,] pro1 = new double[subpopname.Length, K];
                    for (int i = 0; i < N; ++i)
                        for (int j = 0; j < K; ++j)
                            pro1[subpopid[i], j] += RZ[i, j];

                    for (int i = 0; i < subpopname.Length; ++i)
                    {
                        double st = 0;
                        for (int j = 0; j < K; ++j)
                            st += pro1[i, j];
                        for (int j = 0; j < K; ++j)
                            pro1[i, j] /= st;
                    }

                    for (int i = 0; i < subpopname.Length; ++i)
                    {
                        re.Append("\r\n" + subpopname[i]);
                        for (int j = 0; j < K; ++j)
                            re.Append("\t" + pro1[i, j].ToString(DECIMAL));
                    }

                    double[] H = new double[K];
                    double[,] H2 = new double[K, L];
                    double[,] D = new double[K, K];
                    for (int i = 0; i < K; ++i)
                    {
                        for (int l = 0; l < L; ++l)
                        {
                            double oe = 0;
                            foreach (int a in loc[i][l].freq.Keys)
                                oe += loc[i][l].freq[a] * loc[i][l].freq[a];
                            H[i] += 1 - oe;
                            H2[i, l] = 1 - oe;
                        }
                        H[i] /= L;

                        for (int j = 0; j < i; ++j)
                        {
                            for (int l = 0; l < L; ++l)
                            {
                                double pe = 0;
                                foreach (int a in loc[i][l].freq.Keys)
                                    pe += loc[i][l].freq[a] * loc[j][l].freq[a];
                                D[i, j] += 1 - pe;
                            }
                            D[j, i] = D[i, j] = D[i, j] / L - (H[i] + H[j]) / 2;
                        }
                    }

                    re.Append("\r\n\r\nAllele-frequency divergence among populations (Net nucleotide distance)");
                    re.Append("\r\n\tCluster\r\nCluster");
                    for (int j = 0; j < K; ++j)
                        re.Append("\t" + (j + 1).ToString());

                    for (int i = 0; i < K; ++i)
                    {
                        re.Append("\r\n" + (i + 1).ToString());
                        for (int j = 0; j < K; ++j)
                            re.Append("\t" + D[i, j].ToString(DECIMAL));
                    }

                    re.Append("\r\n\r\nExpected heterozygosity between individuals within the same cluster");
                    re.Append("\r\nCluster\tHe");
                    for (int l = 0; l < L; ++l)
                        re.Append("\t" + locusname[l]);

                    for (int j = 0; j < K; ++j)
                    {
                        re.Append("\r\n" + (j + 1).ToString() + "\t" + H[j].ToString(DECIMAL));
                        for (int l = 0; l < L; ++l)
                            re.Append("\t" + H2[j, l].ToString(DECIMAL));
                    }

                    re.Append("\r\n\r\nInferred ancestry of individuals");
                    re.Append("\r\n\t\tCluster");
                    re.Append("\r\nIndividual\tPopulation");
                    for (int j = 0; j < K; ++j)
                        re.Append("\t" + (j + 1).ToString());

                    for (int i = 0; i < N; ++i)
                    {
                        re.Append("\r\n" + indname[i] + "\t" + subpopname[subpopid[i]]);
                        for (int j = 0; j < K; ++j)
                            re.Append("\t" + RZ[i, j].ToString(DECIMAL));
                    }

                    re.Append("\r\n\r\nEstimated allele frequencies in each cluster");
                    int ct = 0;
                    for (int l = 0; l < L; ++l)
                    {
                        re.Append("\r\nLocus: " + locusname[l] + ", " + J[l] + " alleles");
                        re.Append("\r\n\tCluster\r\nAllele");
                        for (int j = 0; j < K; ++j)
                            re.Append("\t" + (j + 1).ToString());
                        foreach (var x in loc[0][l].freq.OrderBy(f => f.Key))
                        {
                            re.Append("\r\n" + x.Key);
                            for (int k = 0; k < K; ++k)
                                re.Append("\t" + loc[k][l].freq[x.Key].ToString(DECIMAL));
                            ct++;
                        }
                        re.Append("\r\n");
                    }

                    return res = re.ToString();
                }

                public static void WritelnL(STRUCTURE[] pars, string file)
                {
                    if (pars.Length == 0) return;
                    StreamWriter wt = new StreamWriter(new FileStream(file, FileMode.Create, FileAccess.Write), Encoding.UTF8);

                    wt.Write("id");
                    foreach (STRUCTURE par in pars)
                        wt.Write("\t" + par.taskid);

                    wt.Write("\r\nK");
                    foreach (STRUCTURE par in pars)
                        wt.Write("\t" + par.K);

                    wt.Write("\r\nIteration");
                    foreach (STRUCTURE par in pars)
                        wt.Write("\tlnL");

                    int nburnin = pars[0].nburnin;
                    int nthinning = pars[0].nthinning;
                    int nreps = pars[0].nreps;
                    int cp = 0, i = 0, nburninrec = 0;

                    for (i = 0; i < nburnin; i += nthinning, cp++)
                    {
                        wt.Write("\r\n" + (i + 1));
                        foreach (STRUCTURE par in pars)
                            wt.Write((par.threadid == -1 ? "\t" : "\t" + par.trace[cp].ToString(DECIMAL)));
                    }

                    nburninrec = i;
                    for (i = 0; i < nreps; i += nthinning, cp++)
                    {
                        wt.Write("\r\n" + (i + 1 + nburninrec));
                        foreach (STRUCTURE par in pars)
                            wt.Write((par.threadid == -1 ? "\t" : "\t" + par.trace[cp].ToString(DECIMAL)));
                    }
                    wt.Close();
                }

                public void CreateResultFile()
                {
                    int[] fids = new DirectoryInfo(resdir).GetFiles("Structure_*.dat").Select(f => int.Parse(f.Name.Substring(10, f.Name.Length - 14))).ToArray();
                    file = resdir + "Structure_" + (fids.Length == 0 ? 1 : fids.Max(f => f) + 1).ToString() + ".dat";

                    BinaryWriter wt = new BinaryWriter(new FileStream(file, FileMode.Create, FileAccess.Write, FileShare.ReadWrite), Encoding.UTF8);

                    wt.Write(ntotruns);
                    wt.Write(new byte[ntotruns * sizeof(int)]);

                    wt.Write(admix);
                    wt.Write(locpriori);
                    wt.Write(fmodel);
                    wt.Write(allownull);

                    wt.Write(seed);
                    wt.Write(kmin);
                    wt.Write(kmax);
                    wt.Write(nburnin);//i
                    wt.Write(nreps);//i
                    wt.Write(nthinning);//i
                    wt.Write(nruns);//i

                    wt.Write(lambda);//d
                    wt.Write(stdlambda);//d
                    wt.Write(maxlambda);//d
                    wt.Write(admburnin);//i
                    wt.Write(inferlambda);//b
                    wt.Write(difflambda); ;//b

                    wt.Write(alpha0);//d
                    wt.Write(stdalpha);//d
                    wt.Write(maxalpha);//d
                    wt.Write(metrofreq);//i
                    wt.Write(alphapriora);//d
                    wt.Write(alphapriorb);//d
                    wt.Write(inferalpha);//b
                    wt.Write(diffalpha);//b
                    wt.Write(gammaalpha);//b

                    wt.Write(maxr);//d
                    wt.Write(epsr);//d
                    wt.Write(epseta);//d
                    wt.Write(epsgamma);//d

                    wt.Write(fpriormean);//d
                    wt.Write(fpriorstd);//d
                    wt.Write(fstdf);//d
                    wt.Write(fsame);

                    wt.Write(N);
                    wt.Write(S);
                    wt.Write(L);
                    wt.Write(Jt);
                    wt.Write(Nrecord);
                    wt.Write(Nburninrec);

                    for (int i = 0; i < N; ++i)
                        wt.Write(subpopid[i]);

                    for (int i = 0; i < N; ++i)
                        wt.Write(indname[i]);

                    for (int i = 0; i < S; ++i)
                        wt.Write(subpopninds[i]);

                    for (int i = 0; i < S; ++i)
                        wt.Write(subpopname[i]);

                    for (int i = 0; i < L; ++i)
                        wt.Write(locusname[i]);

                    for (int i = 0; i < L; ++i)
                        wt.Write(J[i]);

                    for (int i = 0; i < Jt; ++i)
                        wt.Write(alleleid[i]);

                    wt.Close();
                }

                public struct StructureSortByQEntry
                {
                    //Sort by Q
                    public int pop;
                    public double pr;
                };

                public void WriteRun()
                {
                    if (file == "" || !File.Exists(file))
                        return;

                    lock (subpopid)
                    {
                        BinaryWriter wt = new BinaryWriter(new FileStream(file, FileMode.Open, FileAccess.Write, FileShare.ReadWrite), Encoding.UTF8);
                        int offset = (int)wt.BaseStream.Length;
                        wt.BaseStream.Position = taskid * sizeof(int);
                        wt.Write(offset);
                        wt.BaseStream.Position = offset;

                        //start
                        wt.Write(taskid);
                        wt.Write(K);

                        //r
                        wt.Write(rlen);
                        for (int i = 0; i < rlen; ++i)
                            wt.Write(rout[i]);

                        //Zs
                        for (int i = 0; i < N; ++i)
                            for (int j = 0; j < K; ++j)
                                wt.Write(RZ[i, j]);

                        //cluster
                        for (int i = 0; i < K; ++i)
                            for (int j = 0; j < Jt; ++j)
                                wt.Write(RFreq[i, j]);

                        //trace
                        for (int i = 0; i < trace.Length; ++i)
                            wt.Write(trace[i]);

                        wt.Flush();
                        wt.Close();
                    }
                }

                public static void ReadRuns(StructureResultItem res)
                {
                    if (!File.Exists(res.file))
                    {
                        res.items = new ListViewItem[0];
                        res.str = "";
                        return;
                    }
                    try
                    {
                        StringBuilder re = new StringBuilder();
                        STRUCTURE par = new STRUCTURE(res.file);
                        par.GetParamsString(re);

                        re.Append("\r\n\r\nid\tK\tMean lnL\tVar lnL\tln PD\r\n");
                        ListViewItem[] items = new ListViewItem[par.ntotruns];

                        STRUCTURE[] pars = new STRUCTURE[par.ntotruns];

                        for (int i = 0; i < par.ntotruns; ++i)
                            pars[i] = new STRUCTURE(res.file, i + 1, par);

                        for (int i = 0; i < par.ntotruns; ++i)
                        {
                            STRUCTURE p = pars[i];
                            if (p.threadid == -1)
                            {
                                ListViewItem t = new ListViewItem((i + 1).ToString());
                                t.Tag = p;
                                items[i] = t;
                                re.Append(p.taskid + "\tNot finished.\r\n");
                            }
                            else
                            {
                                ListViewItem t = new ListViewItem(p.taskid.ToString());
                                t.SubItems.Add(p.K.ToString());
                                t.SubItems.Add(p.rout[0].ToString(DECIMAL));
                                t.SubItems.Add(p.rout[2].ToString(DECIMAL));
                                t.SubItems.Add(p.rout[3].ToString(DECIMAL));
                                t.Tag = p;

                                items[i] = t;
                                re.Append(
                                    p.taskid + "\t" +
                                    p.K + "\t" +
                                    p.rout[0].ToString(DECIMAL) + "\t" +
                                    p.rout[2].ToString(DECIMAL) + "\t" +
                                    p.rout[3].ToString(DECIMAL) + "\r\n");
                            }
                        }

                        par.Summary(pars);
                        res.str = par.GetRunString(pars);
                        res.items = items;
                    }
                    catch
                    {
                        res.items = new ListViewItem[0];
                        res.str = "";
                        return;
                    }
                }

                public static ListViewItem ReadResultFile(string file)
                {
                    FileInfo f = new FileInfo(file);
                    ListViewItem re = new ListViewItem(f.Name.Substring(10, f.Name.Length - 14));
                    BinaryReader rt = new BinaryReader(new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.ReadWrite), Encoding.UTF8);
                    int ntotrun = rt.ReadInt32();
                    rt.BaseStream.Position += ntotrun * sizeof(int);
                    bool admixture = rt.ReadBoolean();
                    bool locpriori = rt.ReadBoolean();
                    bool fmodel = rt.ReadBoolean();
                    bool allownullallele = rt.ReadBoolean();

                    int seed = rt.ReadInt32();
                    int kmin = rt.ReadInt32();
                    int kmax = rt.ReadInt32();

                    int nburnin = rt.ReadInt32();
                    int nreps = rt.ReadInt32();
                    int nthinning = rt.ReadInt32();
                    int nruns = rt.ReadInt32();

                    double lambda = rt.ReadDouble();
                    double stdlambda = rt.ReadDouble();
                    double maxlambda = rt.ReadDouble();
                    int admburnin = rt.ReadInt32();
                    bool inferlambda = rt.ReadBoolean();
                    bool difflambda = rt.ReadBoolean();

                    double alpha0 = rt.ReadDouble();
                    double stdalpha = rt.ReadDouble();
                    double maxalpha = rt.ReadDouble();
                    int metrofreq = rt.ReadInt32();
                    double alphapriora = rt.ReadDouble();
                    double alphapriorb = rt.ReadDouble();
                    bool inferalpha = rt.ReadBoolean();
                    bool diffalpha = rt.ReadBoolean();
                    bool gammaalpha = rt.ReadBoolean();

                    double maxr = rt.ReadDouble();
                    double epsr = rt.ReadDouble();
                    double epseta = rt.ReadDouble();
                    double epsgamma = rt.ReadDouble();

                    double fpriormean = rt.ReadDouble();
                    double fpriorstd = rt.ReadDouble();
                    double fstdf = rt.ReadDouble();

                    //rt.BaseStream.Position += 18 * sizeof(double) + 6 * sizeof(int) + 6 * sizeof(bool);
                    bool fsame = rt.ReadBoolean();

                    re.SubItems.Add(f.LastWriteTime.ToShortDateString() + " " + f.LastWriteTime.ToShortTimeString());
                    re.SubItems.Add(kmin + "-" + kmax);
                    re.SubItems.Add((admixture ? "ADM " : "") + (locpriori ? "LOC " : "") + (fmodel ? (fsame ? "F-1 " : "F-K ") : "") + (allownullallele ? "NUL " : ""));
                    re.Tag = new StructureResultItem(file);
                    rt.Close();
                    return re;
                }

                public STRUCTURE(IND[] inds, SUBPOP[] subpops)
                {
                    taskid = -1;
                    rnd = new Random(SEED ^ (taskid + 0x2D3FD76A));//bug fixed on 20220324
                    ntotruns = STRUCTURE_NRUNS * (STRUCTURE_KMAX + 1 - STRUCTURE_KMIN);

                    admix = STRUCTURE_ADMIXTURE;
                    locpriori = STRUCTURE_LOCPRIORI;
                    fmodel = STRUCTURE_FMODEL;
                    allownull = CONSIDER_NULL;

                    seed = SEED;
                    kmin = STRUCTURE_KMIN;
                    kmax = STRUCTURE_KMAX;
                    nburnin = STRUCTURE_NBURNIN;
                    nreps = STRUCTURE_NREPS;
                    nthinning = STRUCTURE_NTHINNING;
                    nruns = STRUCTURE_NRUNS;
                    
                    lambda = STRUCTURE_LAMBDA;
                    stdlambda = STRUCTURE_STDLAMBDA;
                    maxlambda = STRUCTURE_MAXLAMBDA;
                    admburnin = (!STRUCTURE_LOCPRIORI && !STRUCTURE_ADMIXTURE) ? STRUCTURE_ADMBURNIN : 0;
                    inferlambda = STRUCTURE_INFERLAMBDA;
                    difflambda = (!fmodel) && STRUCTURE_DIFFLAMBDA;

                    alpha0 = STRUCTURE_ALPHA0;
                    stdalpha = STRUCTURE_STDALPHA;
                    maxalpha = STRUCTURE_MAXALPHA;
                    metrofreq = STRUCTURE_METROFREQ;
                    alphapriora = STRUCTURE_ALPHAPRIORA;
                    alphapriorb = STRUCTURE_ALPHAPRIORB;
                    inferalpha = STRUCTURE_INFERALPHA;
                    diffalpha = STRUCTURE_DIFFALPHA;
                    gammaalpha = STRUCTURE_GAMMAALPHA;//or gamma alpha

                    maxr = STRUCTURE_MAXR;
                    epsr = STRUCTURE_EPSR;
                    epseta = STRUCTURE_EPSETA;
                    epsgamma = STRUCTURE_EPSGAMMA;

                    fpriormean = STRUCTURE_FPRIORMEAN;
                    fpriorstd = STRUCTURE_FPRIORSTD;
                    fstdf = STRUCTURE_FSTDF;
                    fsame = STRUCTURE_FSAME;

                    SUBPOP total_pop = subpops[0];

                    N = inds.Length;
                    S = subpops.Length;
                    L = total_pop.loc.Length;
                    Jt = total_pop.loc.Sum(l => l.freq.Count);
                    Nrecord = nreps / nthinning;
                    Nburninrec = nburnin / nthinning;

                    subpopid = inds.Select(i => i.subpop.id).ToArray();
                    indname = inds.Select(i => i.subpop.name).ToArray();
                    subpopninds = subpops.Select(s => s.inds.Length).ToArray();
                    subpopname = subpops.Select(s => s.name).ToArray();
                    locusname = total_pop.loc.Select(l => l.name).ToArray();

                    J = total_pop.loc.Select(l => l.freq.Count).ToArray();
                    alleleid = null;

                    V = inds.Select(i => i.ploidy).ToArray();
                    eL = total_pop.loc.Count(l => l.freq.Count > 0);
                    nhaplo = inds.Sum(i => i.ploidy);
                    maxploidy = inds.Max(i => i.ploidy);
                    Jdis = null;
                    hap = null;

                    alleleid = new int[Jt];
                    totfreq = new double[Jt];
                    Jdis = new int[total_pop.loc.Max(l => l.freq.Count) + 1];

                    Dictionary<int, int>[] map1 = new Dictionary<int, int>[L];
                    List<int> maprev = new List<int>();
                    for (int l = 0, cp = 0; l < L; ++l)
                    {
                        map1[l] = new Dictionary<int, int>();
                        LOC lo = total_pop.loc[l];
                        J[l] = lo.freq.Count;
                        Jdis[lo.freq.Count]++;
                        foreach (int a in lo.freq.Keys)
                        {
                            map1[l][a] = map1[l].Count;
                            alleleid[cp++] = a;
                        }
                    }
                    for (int l = 0, lp = 0; l < L; ++l)
                    {
                        LOC lo = total_pop.loc[l];
                        foreach (var a in lo.freq)
                            totfreq[lp + map1[l][a.Key]] = a.Value;
                        lp += lo.freq.Count;
                    }

                    hap = GetHaplotype2(inds, map1, J, Jt, nhaplo);
                }

                public STRUCTURE(string file, int id = -1, STRUCTURE r = null) : this(id, 0, r)
                {
                    BinaryReader rt = new BinaryReader(new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.ReadWrite), Encoding.UTF8);
                    try
                    {
                        if (r == null)
                        {
                            //read header
                            ntotruns = rt.ReadInt32();
                            rt.BaseStream.Position = (ntotruns + 1) * sizeof(int);

                            admix = rt.ReadBoolean();
                            locpriori = rt.ReadBoolean();
                            fmodel = rt.ReadBoolean();
                            allownull = rt.ReadBoolean();

                            seed = rt.ReadInt32();
                            kmin = rt.ReadInt32();
                            kmax = rt.ReadInt32();
                            nburnin = rt.ReadInt32();
                            nreps = rt.ReadInt32();
                            nthinning = rt.ReadInt32();
                            nruns = rt.ReadInt32();

                            lambda = rt.ReadDouble();
                            stdlambda = rt.ReadDouble();
                            maxlambda = rt.ReadDouble();
                            admburnin = rt.ReadInt32();
                            inferlambda = rt.ReadBoolean();
                            difflambda = rt.ReadBoolean();

                            alpha0 = rt.ReadDouble();
                            stdalpha = rt.ReadDouble();
                            maxalpha = rt.ReadDouble();
                            metrofreq = rt.ReadInt32();
                            alphapriora = rt.ReadDouble();
                            alphapriorb = rt.ReadDouble();
                            inferalpha = rt.ReadBoolean();
                            diffalpha = rt.ReadBoolean();
                            gammaalpha = rt.ReadBoolean();

                            maxr = rt.ReadDouble();
                            epsr = rt.ReadDouble();
                            epseta = rt.ReadDouble();
                            epsgamma = rt.ReadDouble();

                            fpriormean = rt.ReadDouble();
                            fpriorstd = rt.ReadDouble();
                            fstdf = rt.ReadDouble();
                            fsame = rt.ReadBoolean();

                            N = rt.ReadInt32();
                            S = rt.ReadInt32();
                            L = rt.ReadInt32();
                            Jt = rt.ReadInt32();
                            Nrecord  = rt.ReadInt32();
                            Nburninrec = rt.ReadInt32();

                            subpopid = new int[N];
                            for (int i = 0; i < N; ++i)
                                subpopid[i] = rt.ReadInt32();

                            indname = new string[N];
                            for (int i = 0; i < N; ++i)
                                indname[i] = rt.ReadString();

                            subpopninds = new int[S];
                            for (int i = 0; i < S; ++i)
                                subpopninds[i] = rt.ReadInt32();

                            subpopname = new string[S];
                            for (int i = 0; i < S; ++i)
                                subpopname[i] = rt.ReadString();

                            locusname = new string[L];
                            for (int i = 0; i < L; ++i)
                                locusname[i] = rt.ReadString();

                            J = new int[L];
                            for (int i = 0; i < L; ++i)
                                J[i] = rt.ReadInt32();

                            alleleid = new int[Jt];
                            for (int i = 0; i < Jt; ++i)
                                alleleid[i] = rt.ReadInt32();
                        }

                        if (id == -1)
                        {
                            taskid = threadid = -1;
                            rt.Close();
                            return;
                        }

                        rt.BaseStream.Position = id * sizeof(int);//1-based
                        rt.BaseStream.Position = rt.ReadInt32();

                        if (rt.BaseStream.Position == 0)
                        {
                            taskid = id;
                            threadid = -1;
                            rt.Close();
                            return;
                        }

                        //start
                        threadid = 0;
                        taskid = rt.ReadInt32();
                        K = rt.ReadInt32();

                        //r
                        rlen = rt.ReadInt32();
                        rout = new double[rlen];
                        for (int i = 0; i < rlen; ++i)
                            rout[i] = rt.ReadDouble();

                        //Zs
                        RZ = new double[N, K];
                        for (int i = 0; i < N; ++i)
                            for (int j = 0; j < K; ++j)
                                RZ[i, j] = rt.ReadDouble();

                        //cluster
                        RFreq = new double[K, Jt];
                        for (int i = 0; i < K; ++i)
                            for (int j = 0; j < Jt; ++j)
                                RFreq[i, j] = rt.ReadDouble();

                        loc = new LOC[K][];
                        for (int k = 0; k < K; ++k)
                        {
                            loc[k] = new LOC[L];
                            for (int l = 0, lp1 = 0; l < L; ++l)
                            {
                                LOC tloc = new LOC();
                                loc[k][l] = tloc;
                                tloc.name = locusname[l];
                                for (int j = 0; j < J[l]; ++j)
                                    tloc.freq[alleleid[lp1 + j]] = RFreq[k, lp1 + j];
                                lp1 += J[l];
                            }
                        }

                        //trace
                        trace = new double[Nburninrec + Nrecord];
                        for (int i = 0; i < trace.Length; ++i)
                            trace[i] = rt.ReadDouble();
                        rt.Close();
                    }
                    catch
                    {
                        taskid = id;
                        threadid = -1;
                        rt.Close();
                    }
                }

                public STRUCTURE(int _taskid, int _K, STRUCTURE r)
                {
                    if (r == null) return;
                    taskid = _taskid;
                    rnd = new Random(SEED ^ (taskid + 0x2D3FD76A));//bug fixed on 20220324
                    K = _K;
                    
                    file = r.file;
                    ntotruns = r.ntotruns;

                    admix = r.admix;
                    locpriori = r.locpriori;
                    fmodel = r.fmodel;
                    allownull = r.allownull;

                    seed = r.seed;
                    kmin = r.kmin;
                    kmax = r.kmax;
                    nburnin = r.nburnin;
                    nreps = r.nreps;
                    nthinning = r.nthinning;
                    nruns = r.nruns;

                    lambda = r.lambda;
                    stdlambda = r.stdlambda;
                    maxlambda = r.maxlambda;
                    admburnin = r.admburnin;
                    inferlambda = r.inferlambda;
                    difflambda = r.difflambda;

                    alpha0 = r.alpha0;
                    stdalpha = r.stdalpha;
                    maxalpha = r.maxalpha;
                    metrofreq = r.metrofreq;
                    alphapriora = r.alphapriora;
                    alphapriorb = r.alphapriorb;
                    inferalpha = r.inferalpha;
                    diffalpha = r.diffalpha;
                    gammaalpha = r.gammaalpha;

                    maxr = r.maxr;
                    epsr = r.epsr;
                    epseta = r.epseta;
                    epsgamma = r.epsgamma;

                    fpriormean = r.fpriormean;
                    fpriorstd = r.fpriorstd;
                    fstdf = r.fstdf;
                    fsame = r.fsame;

                    N = r.N;
                    S = r.S;
                    L = r.L;
                    Jt = r.Jt;
                    Nrecord = r.Nrecord;
                    Nburninrec = r.Nburninrec;

                    subpopid = r.subpopid;
                    indname = r.indname;
                    subpopninds = r.subpopninds;
                    subpopname = r.subpopname;
                    locusname = r.locusname;

                    J = r.J;
                    alleleid = r.alleleid;

                    V = r.V;
                    eL = r.eL;
                    nhaplo = r.nhaplo;
                    maxploidy = r.maxploidy;
                    Jdis = r.Jdis;
                    hap = r.hap;
                    totfreq = r.totfreq;
                }

                public void InitFix()
                {
                    int nf = fmodel ? (fsame ? 1 : K) : 0;
                    int na = admix ? (diffalpha ? K : 1) : 0;
                    int nl = difflambda ? K : 1;

                    if (locpriori) rlen = 4 + nl + 1 + K + K * S + nf;
                    else rlen = 4 + nl + na + nf;

                    rout = new double[rlen];

                    //Jdis
                    J = new int[L];
                    Jt = 0;
                    for (int l = 0; l < L; ++l)
                    {
                        J[l] = all.total_pop.loc[l].freq.Count;
                        Jt += J[l];
                    }

                    nr = 0;
                    r = 1;

                    flog = new FastLog[K];
                    buff = new double[K];
                    RZ = new double[N, K];
                    Freq = new double[K, Jt];
                    RFreq = new double[K, Jt];
                    trace = new double[Nrecord + Nburninrec];

                    Ni = new double[K, Jt];
                    Mi = new double[N, K];
                    Q = new double[N, K]; SetVal(Q, 1.0 / K);
                    Alpha = new double[K]; SetVal(Alpha, alpha0);
                    Lambda = new double[K]; SetVal(Lambda, lambda);
                }

                public void InitAdmix()
                {
                    // Init Z, Z, Mi and Ni
                    Z = new int[N, L * maxploidy];
                    for (int i = 0, st = 0; i < N; ++i)
                    {
                        for (int l = 0, lp = 0, pp = 0; l < L; ++l)
                        {
                            int k2 = J[l];
                            for (int a = 0; a < V[i]; ++a)
                            {
                                ushort k = (ushort)rnd.Next(K);
                                Z[i, pp++] = k; //N, L, maxploidy   [N] * vt
                                Mi[i, k]++;//number of alleles assigned to each cluster
                                AddSec(Ni, k, hap, st + a, lp, k2);
                            }
                            lp += k2;
                        }
                        st += V[i];
                    }
                }

                public void InitLocPriori()
                {
                    if (locpriori)
                    {
                        SumAlpha = new double[S];
                        AlphaLocal = new double[S, K];
                        SetVal(AlphaLocal, alpha0);

                        if (!admix)
                        {
                            Eta = new double[K];
                            SetVal(Eta, 1.0 / K);

                            Gamma = new double[S, K];
                            SetVal(Gamma, 1.0 / K);

                            Di = new double[S, K];
                        }
                    }
                }

                public void InitFmodel()
                {
                    if (fmodel)
                    {
                        f = new double[K];
                        F = new double[K];

                        PA = new double[Jt];
                        PA1 = new double[Jt];
                        PA2 = new double[Jt];

                        SetVal(F, fpriormean);
                        SetVal(f, (1 - fpriormean) / fpriormean);

                        for (int k = 0; k < K; ++k)
                            SetVal(Freq, k, Lambda[k]);

                        SetVal(PA, lambda);
                        for (int l = 0, lp = 0; l < L; ++l)
                        {
                            int k2 = J[l];
                            for (int a = 0; a < k2; ++a)
                                PA[lp + a] = (lambda + totfreq[lp + a] * nhaplo) / (k2 * lambda + nhaplo);
                            lp += k2;
                        }
                    }
                }

                public void UpdateP()
                {
                    //set lambda, dirichlet distribution priori parameter
                    if (fmodel) for (int k = 0; k < K; ++k)
                            Mul(Freq, k, PA, f[k]);
                    else for (int k = 0; k < K; ++k)
                            SetVal(Freq, k, Lambda[k]);

                    //randomly drawn from dirichlet distribution
                    for (int k = 0; k < K; ++k)
                    {
                        for (int l = 0, lp = 0; l < L; ++l)
                        {
                            int k2 = J[l];
                            GetRandDirichlet(rnd, Freq, k, Freq, k, Ni, k, lp, k2);
                            lp += k2;
                        }
                    }
                }

                public void UpdateQNoAdmix()
                {
                    //used by noadmix model
                    Array.Clear(Q, 0, Q.Length);
                    for (int i = 0, st = 0; i < N; ++i)
                    {
                        FastLog.Open(flog);

                        //add priori probability
                        if (locpriori)
                            for (int k = 0; k < K; ++k)
                                flog[k].Charge(Gamma[subpopid[i], k]);
                        //buf[k] += log(Gamma[s * K + k]);

                        for (int l = 0, lp = 0; l < L; ++l)
                        {
                            int k2 = J[l];
                            for (int a = 0; a < V[i]; ++a)
                                for (int k = 0; k < K; ++k)
                                    flog[k].Charge(SumProd(Freq, k, hap, st + a, lp, k2));
                            lp += J[l];
                        }
                        FastLog.Close(flog);

                        int k3 = GetRandCategoricalLnWrite(rnd, flog);
                        Q[i, k3] = 1;
                        Z[i, 0] = k3;
                        st += V[i];
                    }
                    binaryq = true;
                }

                public void UpdateQAdmix()
                {
                    //used by noadmix (in admburnin) and admix model
                    if (locpriori)
                        for (int i = 0; i < N; ++i)
                            GetRandDirichlet(rnd, Q, i, AlphaLocal, subpopid[i], Mi, i, 0, K);
                    else
                        for (int i = 0; i < N; ++i)
                            GetRandDirichlet(rnd, Q, i, Alpha, Mi, i, 0, K);
                    binaryq = false;
                }

                public void UpdateQMetro()
                {
                    //Metropolis-Hastings Update Q
                    //used by admix model
                    for (int i = 0, st = 0; i < N; ++i)
                    {
                        if (locpriori)
                            GetRandDirichlet(rnd, buff, AlphaLocal, subpopid[i], 0, K);
                        else
                            GetRandDirichlet(rnd, buff, Alpha, 0, K);

                        FastLog flog = FastLog.Default;

                        for (int l = 0, lp = 0; l < L; ++l)
                        {
                            int k2 = J[l];
                            for (int a = 0; a < V[i]; ++a)
                            {
                                double s1 = 0, s2 = 0;
                                for (int k3 = 0; k3 < K; ++k3)
                                {
                                    double s3 = SumProd(Freq, k3, hap, st + a, lp, k2);
                                    s1 += Q[i, k3] * s3;
                                    s2 += buff[k3] * s3;
                                }
                                flog.Charge(s2 / s1);
                            }

                            lp += k2;
                        }
                        flog.Close();

                        if (flog.v1 >= 0 || rnd.NextDouble() < Math.Exp(flog.v1))
                            SetVal(Q, i, buff);

                        st += V[i];
                    }
                    binaryq = false;
                }

                public void UpdateQ()
                {
                    //draw gene proportion for each individual
                    if (!admix)
                    {
                        if (m >= admburnin || locpriori)
                            UpdateQNoAdmix();
                        else
                            UpdateQAdmix();

                        if (locpriori)
                        {
                            Array.Clear(Di, 0, S * K);
                            for (int i = 0; i < N; ++i)
                                Add(Di, subpopid[i], Q, i, 0, K);
                        }
                    }
                    else
                    {
                        if (metrofreq > 0 && m % metrofreq == 0)
                            UpdateQMetro(); 
                        else
                            UpdateQAdmix(); 
                    }
                }

                public void UpdateLocPriori()
                {
                    //locpriori
                    if (!locpriori) return;
                    if (admix)
                    {
                        double rm = r - epsr + 2 * rnd.NextDouble() * epsr;
                        if (rm > 0 && rm < maxr)
                        {
                            double dlnL = 0, d = rm - r, dt1 = rm * MyLog(rm) - r * MyLog(r);
                            for (int k = 0; k < K; ++k)
                            {
                                dlnL += S * (Alpha[k] * dt1 - GammaLn(rm * Alpha[k]) + GammaLn(r * Alpha[k]));

                                dlnL += Alpha[k] * d * LogProd(AlphaLocal, 0, S, k, 1) - Sum(AlphaLocal, 0, S, k, 1) * d;

                            }
                            if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                                r = rm;
                        }
                    }
                    else
                    {
                        double rm = r - epsr + 2 * rnd.NextDouble() * epsr;
                        if (rm > 0 && rm < maxr)
                        {
                            double dlnL = GammaLn(rm) - GammaLn(r);
                            for (int k = 0; k < K; ++k)
                                dlnL += GammaLn(r * Eta[k]) - GammaLn(rm * Eta[k]);
                            dlnL *= S;

                            //optimize checked 8
                            for (int k = 0; k < K; ++k)
                                dlnL += (rm - r) * Eta[k] * LogProd(Gamma, 0, S, k, 1);

                            if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                                r = rm;
                        }

                        //update eta
                        if (K >= 2)
                        {
                            int i1 = rnd.Next(K), j1 = NextAvoid(rnd, K, i1);
                            double delta = rnd.NextDouble() * epseta;
                            double e1 = Eta[i1] + delta;
                            double e2 = Eta[j1] - delta;
                            if (e1 < 1 && e2 > 0)
                            {
                                double dlnL = S * (GammaLn(r * Eta[i1]) + GammaLn(r * Eta[j1]) - GammaLn(r * e1) - GammaLn(r * e2));

                                dlnL += r * delta * SubLogProdCol(Gamma, i1, Gamma, j1, S);

                                //for (int s = 0; s < S; ++s)
                                //dlnL += r * delta * MyLog(Gamma[s * K + i1] / Gamma[s * K + j1]);

                                if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                                {
                                    Eta[i1] += delta;
                                    Eta[j1] -= delta;
                                }
                            }
                        }

                        //update gamma
                        if (K >= 2)
                        {
                            for (int s = 0; s < S; ++s)
                            {
                                int i1 = rnd.Next(K), j1 = NextAvoid(rnd, K, i1);
                                double delta = rnd.NextDouble() * epsgamma;

                                if (Gamma[s, i1] + delta < 1 && Gamma[s, j1] - delta > 0)
                                {
                                    double dlnL = (r * Eta[i1] - 1.0 + Di[s, i1]) * MyLog(1 + delta / Gamma[s, i1]) +
                                        (r * Eta[j1] - 1.0 + Di[s, j1]) * MyLog(1 - delta / Gamma[s, j1]);

                                    if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                                    {
                                        Gamma[s, i1] += delta;
                                        Gamma[s, j1] -= delta;
                                    }
                                }
                            }
                        }

                        if (m % 10 == 0)
                        {
                            Unify(Eta);
                            Unify(Gamma);
                        }
                    }
                }

                public void UpdateZ()
                {
                    //Update Z, Mi, Ni
                    Array.Clear(Mi, 0, N * K);
                    Array.Clear(Ni, 0, K * Jt);

                    if (binaryq) for (int i = 0, st = 0; i < N; ++i)
                        {
                            int k = Z[i, 0];
                            SetVal(Z, i, k);
                            Mi[i, k] = V[i];

                            for (int l = 0, lp = 0; l < L; ++l)
                            {
                                int k2 = J[l];
                                for (int a = 0; a < V[i]; ++a)
                                    Add(Ni, k, hap, st + a, lp, k2);
                                lp += J[l];
                            }
                            st += V[i];
                        }
                    else for (int i = 0, st = 0; i < N; ++i)
                        {
                            for (int l = 0, lp = 0, pp = 0; l < L; ++l)
                            {
                                int k2 = J[l];
                                for (int a = 0; a < V[i]; ++a)
                                {
                                    for (int k = 0; k < K; ++k)
                                        buff[k] = Q[i, k] * SumProd(hap, st + a, Freq, k, lp, k2);

                                    int k3 = GetRandCategorical(rnd, buff, K);
                                    Z[i, pp++] = k3;
                                    Mi[i, k3]++;
                                    AddSec(Ni, k3, hap, st + a, lp, k2);
                                }
                                lp += k2;
                            }
                            st += V[i];
                        }
                }

                public void UpdateAlpha()
                {
                    if (locpriori && admix)
                    {
                        //UpdateAlphaLocPrior
                        //update AlphaGlobal
                        for (int k = 0; k < K; ++k)
                        {
                            double am = GetRandNorm(rnd, Alpha[k], stdalpha);
                            if (am > 0 && am < maxalpha)
                            {
                                double d = am - Alpha[k];
                                double dlnL = S * (d * r * MyLog(r) + GammaLn(r * Alpha[k]) - GammaLn(r * am));

                                //optimize checked 9
                                dlnL += r * d * LogProd(AlphaLocal, 0, S, k, 1);

                                //for (int s = 0; s < S; ++s)
                                //dlnL += r * d * log(AlphaLocal[s * K + k]);

                                if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                                    Alpha[k] = am;
                            }
                        }

                        //update SumAlpha
                        if (m % 10 == 0) for (int s = 0; s < S; ++s)
                                SumAlpha[s] = SumRow(AlphaLocal, s);

                        //update AlphaLocal
                        for (int s = 0; s < S; ++s)
                        {
                            for (int k = 0; k < K; ++k)
                            {
                                double ao = AlphaLocal[s, k];
                                double am = GetRandNorm(rnd, ao, stdalpha);
                                if (am > 0 && am < maxalpha)
                                {
                                    double d = am - ao;
                                    double dlnL = (r * Alpha[k] - 1) * MyLog(am / ao) - d * r +
                                        subpopninds[s] * (GammaLn(SumAlpha[s] + d) - GammaLn(am)
                                                        - GammaLn(SumAlpha[s]) + GammaLn(ao));

                                    //optimize checked 10
                                    FastLog flog = FastLog.Default;
                                    for (int i = 0; i < N; ++i)
                                        if (subpopid[i] == s)
                                            flog.Charge(Q[i, k]);
                                    dlnL += d * flog.Close();

                                    if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                                    {
                                        AlphaLocal[s, k] = am;
                                        SumAlpha[s] += d;
                                    }
                                }
                            }
                        }
                    }
                    else if (inferalpha)
                    {
                        if (!admix && m >= admburnin) return;
                        //for admix and not locpriori

                        if (diffalpha)
                        {
                            double sumalpha = 0;
                            for (int k = 0; k < K; ++k)
                                sumalpha += Alpha[k];

                            for (int k = 0; k < K; ++k)
                            {
                                double am = GetRandNorm(rnd, Alpha[k], stdalpha);
                                if (am <= 0 || (am >= maxalpha && !gammaalpha)) continue;
                                double ao = Alpha[k];
                                double d = am - ao;
                                double dlnL = !gammaalpha ? 0 : ((alphapriora - 1) * MyLog(am / ao) + (ao - am) / alphapriorb);

                                dlnL += (am - ao) * LogProd(Q, 0, N, k, 1) + (GammaLn(sumalpha + d) - GammaLn(sumalpha) - GammaLn(am) + GammaLn(ao)) * N;
                                if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                                    Alpha[k] = am;
                            }
                        }
                        else
                        {
                            double am = GetRandNorm(rnd, Alpha[0], stdalpha);
                            if (am <= 0 || (am >= maxalpha && !gammaalpha)) return;
                            double ao = Alpha[0];
                            double dlnL = !gammaalpha ? 0 : ((alphapriora - 1) * MyLog(am / ao) + (ao - am) / alphapriorb);

                            dlnL += (am - ao) * LogProd(Q, 0, N, 0, K) + (GammaLn(K * am) - GammaLn(K * ao) - K * GammaLn(am) + K * GammaLn(ao)) * N;
                            if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                                for (int k = 0; k < K; ++k)
                                    Alpha[k] = am;
                        }
                    }
                }

                public void UpdateLambda()
                {
                    if (!inferlambda) return;
                    if (difflambda) for (int k = 0; k < K; ++k)
                        {
                            double lo = Lambda[k];
                            double lm = GetRandNorm(rnd, lo, stdlambda);
                            if (lm <= 0 || lm >= maxlambda) continue;
                            double dlnL = 0;
                            double gd = GammaLn(lo) - GammaLn(lm);

                            for (int i = 2; i < Jdis.Length; ++i)
                                dlnL += Jdis[i] * (GammaLn(i * lm) - GammaLn(i * lo) + i * gd);

                            dlnL += (lm - lo) * LogProd(Freq, k, 1, 0, Jt);


                            if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                                Lambda[k] = lm;
                        }
                    else
                    {
                        int npop = fmodel ? 1 : K;
                        double lo = Lambda[0];
                        double lm = GetRandNorm(rnd, lo, stdlambda);
                        if (lm <= 0 || lm >= maxlambda) return;
                        double dlnL = 0;
                        double gd = GammaLn(lo) - GammaLn(lm);

                        for (int i = 2; i < Jdis.Length; ++i)
                            dlnL += Jdis[i] * npop * (GammaLn(i * lm) - GammaLn(i * lo) + i * gd);

                        dlnL += (lm - lo) * (fmodel ? LogProd(PA, 0, Jt) : LogProd(Freq, 0, K, 0, Jt));

                        if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                            SetVal(Lambda, lm);
                    }
                }

                public void UpdatePA()
                {
                    //F model, uppdate allele frequency of ancestral population
                    if (!fmodel) return;
                    double lam = Lambda[0];//single lambda in F model

                    if (rnd.NextDouble() < 0.5)
                    {
                        //Independent update PA
                        SetVal(PA1, lam);

                        for (int k = 0; k < K; ++k)
                            AddMul(PA1, Freq, k, f[k]);

                        for (int l = 0, lp = 0; l < L; ++l)
                        {
                            int k2 = J[l];
                            GetRandDirichlet(rnd, PA2, PA1, lp, k2);

                            double dlnL = 0;
                            for (int a = 0; a < k2; ++a)
                                dlnL += (PA1[lp + a] - lam) * (MyLog(PA[lp + a] / PA2[lp + a]));

                            for (int k = 0; k < K; ++k)
                            {
                                double fr = f[k];
                                for (int a = 0; a < k2; ++a)
                                    dlnL += GammaLn(fr * PA[lp + a]) - GammaLn(fr * PA2[lp + a])
                                        + fr * (PA2[lp + a] - PA[lp + a]) * MyLog(Freq[k, lp + a]);
                            }

                            if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                                SetVal(PA, PA2, lp, k2);

                            lp += k2;
                        }
                    }
                    else
                    {
                        for (int l = 0, lp = 0; l < L; ++l)
                        {
                            int k2 = J[l];
                            int m1 = rnd.Next(k2), n1 = NextAvoid(rnd, k2, m1);

                            double delta = rnd.NextDouble() * Math.Pow(N, -0.5);
                            double pm0 = PA[lp + m1], pm1 = pm0 + delta;
                            double pn0 = PA[lp + n1], pn1 = pn0 - delta;
                            if (pm1 >= 1 || pn1 <= 0)
                            {
                                lp += k2;
                                continue;
                            }
                            double dlnL = 0;

                            for (int k = 0; k < K; ++k)
                            {
                                double fr = f[k];
                                dlnL += GammaLn(fr * pm0) + GammaLn(fr * pn0)
                                    - GammaLn(fr * pm1) - GammaLn(fr * pn1)
                                        + (fr * delta) * MyLog(Freq[k, m1] / Freq[k, n1]);
                            }
                            dlnL += (lam - 1) * MyLog(pm1 * pn1 / pm0 / pn0);

                            if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                            {
                                PA[lp + m1] = pm1;
                                PA[lp + n1] = pn1;
                            }

                            lp += k2;
                        }
                    }
                }

                public void UpdateF()
                {
                    //F model
                    if (!fmodel) return;

                    // Update F/Fst
                    for (int k = 0; k < K; ++k)
                    {
                        double Fo = F[k];
                        double Fm = GetRandNorm(rnd, Fo, fstdf);
                        if (Fm < 0 || Fm > 1)
                        {
                            if (fsame) break;
                            else continue;
                        }

                        double fo = f[k], fm = (1 - Fm) / Fm;
                        double dlnL = fpriormean * (Fo - Fm) / (fpriorstd * fpriorstd)
                            + (fpriormean * fpriormean / (fpriorstd * fpriorstd) - 1) * MyLog(Fm / Fo)
                                + (fsame ? K : 1) * eL * (GammaLn(fm) - GammaLn(fo));

                        for (int k2 = k; k2 < K; ++k2)
                        {
                            for (int a = 0; a < Jt; ++a)
                                dlnL += PA[a] * (fm - fo) * MyLog(Freq[k2, a])
                                    - GammaLn(fm * PA[a]) + GammaLn(fo * PA[a]);
                            if (!fsame) break;
                        }

                        if (dlnL >= 0 || rnd.NextDouble() < Math.Exp(dlnL))
                        {
                            if (fsame)
                            {
                                SetVal(F, Fm);
                                SetVal(f, fm);
                            }
                            else
                            {
                                F[k] = Fm;
                                f[k] = fm;
                            }
                        }

                        if (fsame) break;
                    }
                }

                public void Finish(int nr)
                {
                    Unify(RZ);
                    Mul(rout, rout, 1.0 / nr);
                    rout[2] = rout[1] - rout[0] * rout[0];//lnPD
                    rout[3] = rout[0] - rout[2] / 2;//var
                    Mul(RFreq, RFreq, 1.0 / nr);
                }

                public double GetCurrentLikelihood()
                {
                    FastLog flog = FastLog.Default;
                    for (int i = 0, st = 0; i < N; ++i)
                    {
                        for (int l = 0, lp = 0; l < L; ++l)
                        {
                            int k2 = J[l];
                            for (int a = 0; a < V[i]; ++a)
                                flog.Charge(SumProd(Q, i, Freq, K, hap, st + a, lp, k2));
                            lp += k2;
                        }
                        st += V[i];
                    }
                    return flog.Close();
                }

                public void Summary(STRUCTURE[] pars)
                {
                    if (pars.Length == 0 || 
                        (nsummary = pars.Count(p => p.threadid != -1)) == 0)
                        return;

                    threadid = 0;
                    int nK = pars.Select(p => p.K).Distinct().Count();

                    if (nK == 1)
                    {
                        K = pars[0].K;

                        rlen = pars[0].rlen;
                        RZ = new double[N, K];
                        rout = new double[rlen];
                        RFreq = new double[K, Jt];

                        Nrecord = pars[0].Nrecord;
                        Nburninrec = pars[0].Nburninrec;
                        trace = new double[Nrecord + Nburninrec];

                        foreach (STRUCTURE par in pars)
                        {
                            if (par.threadid == -1) continue;
                            int[] popseq = par.PopSeq(true);
                            AddById(RZ, RZ, par.RZ, popseq, 1);
                            Add(rout, rout, par.rout);
                            AddById(RFreq, RFreq, par.RFreq, popseq, 0);
                            Add(trace, trace, par.trace);
                        }

                        Mul(trace, trace, 1.0 / nsummary);
                        Finish(nsummary);

                        loc = new LOC[K][];
                        for (int k = 0; k < K; ++k)
                        {
                            loc[k] = new LOC[L];
                            for (int l = 0, lp1 = 0; l < L; ++l)
                            {
                                LOC tloc = new LOC();
                                loc[k][l] = tloc;
                                tloc.name = locusname[l];
                                for (int j = 0; j < J[l]; ++j)
                                    tloc.freq[alleleid[lp1 + j]] = RFreq[k, lp1 + j];
                                lp1 += J[l];
                            }
                        }
                    }
                    else
                    {
                        K = -1;

                        Nrecord = pars[0].Nrecord;
                        Nburninrec = pars[0].Nburninrec;
                        trace = new double[Nrecord + Nburninrec];

                        for (int i = 0; i < pars.Length; ++i)
                        {
                            STRUCTURE p = pars[i];
                            if (p.threadid == -1) continue;
                            Add(trace, trace, p.trace);
                        }

                        Mul(trace, trace, 1.0 / nsummary);
                    }


                }

                public void Record()
                {
                    if (m >= nburnin + admburnin && (m - nburnin - admburnin) % nthinning == 0)
                    {
                        Add(RZ, RZ, Mi);

                        //add to result
                        double li = trace[nt + nr++] = GetCurrentLikelihood();

                        rout[0] += li;
                        rout[1] += li * li;
                        //rout[2] += lnPD
                        //rout[3] += Likelihood;

                        int nf = fmodel ? (fsame ? 1 : K) : 0;
                        int na = admix ? (diffalpha ? K : 1) : 0;
                        int nl = difflambda ? K : 1;

                        Add(rout, 4,
                            rout, 4, Lambda, 0, nl);
                        if (locpriori)
                        {
                            rout[4 + nl] += r;
                            Add(rout, 4 + nl + 1,
                                rout, 4 + nl + 1, admix ? Alpha : Eta, 0, K);
                            Add(rout, 4 + nl + 1 + K,
                                rout, 4 + nl + 1 + K, admix ? AlphaLocal : Gamma);
                        }
                        else if (admix)
                            Add(rout, 4 + nl,
                                rout, 4 + nl, Alpha, 0, na);

                        for (int i = 0; i < nf; ++i)
                            rout[rlen - nf + i] += F[i];

                        Add(RFreq, RFreq, Freq);
                    }
                    else if (m >= admburnin && (m - admburnin) % nthinning == 0)
                        trace[nt++] = GetCurrentLikelihood();
                }

                public void MCMC()
                {
                    InitFix();
                    InitAdmix();
                    InitLocPriori();
                    InitFmodel();

                    int nmcmc = nburnin + admburnin + nreps;

                    for (m = 0; m < nmcmc; ++m)
                    {
                        binaryq = false;
                        UpdateP();//Allele frequency
                        UpdateQ();//Individual priori gene proportion
                        UpdateLocPriori();//LocPriori r, eta gamma
                        UpdateZ();//Individual gene origin
                        UpdateAlpha();//LocPriori+Admix
                        UpdateLambda();//
                        UpdatePA();//
                        UpdateF();//
                        Record();
                        all.Increment();
                    }
                    Finish(nr);
                }

            }

            public void CalcStructure()
            {
                Progress = "Performing structure analyses";

                int admburnin = (!STRUCTURE_LOCPRIORI && !STRUCTURE_ADMIXTURE) ? STRUCTURE_ADMBURNIN : 0;
                ProgressValue = 0;
                ProgressMax = STRUCTURE_NRUNS * (STRUCTURE_KMAX - STRUCTURE_KMIN + 1) * (STRUCTURE_NBURNIN + STRUCTURE_NREPS + admburnin);
                SetProgress(ProgressValue, ProgressMax);

                STRUCTURE par = new STRUCTURE(inds, subpops);
                par.CreateResultFile();

                int ntotruns = STRUCTURE_NRUNS * (STRUCTURE_KMAX + 1 - STRUCTURE_KMIN);
                STRUCTURE[] tasks = new STRUCTURE[ntotruns];
                for (int k = STRUCTURE_KMIN, cp = 0; k <= STRUCTURE_KMAX; ++k)
                    for (int i = 0; i < STRUCTURE_NRUNS; ++i)
                        tasks[cp++] = new STRUCTURE(cp, k, par);

                Permute(tasks, new Random());
                CallThread(StructureThread, N_THREAD, 
                           new object[] { tasks },
                           ProgressMax, ref ProgressValue);
            }

            public void StructureThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                STRUCTURE[] tasks = (STRUCTURE[])((object[])obj)[2];

                for (int i = 0; i < tasks.Length; ++i)
                {
                    if (tasks[i].threadid != -1) continue;
                    lock (tasks)
                    {
                        if (tasks[i].threadid == -1)
                            tasks[i].threadid = id;
                    }
                    if (tasks[i].threadid != id) continue;

                    tasks[i].threadid = id;
                    tasks[i].MCMC();
                    tasks[i].WriteRun();
                }
            }

            #endregion

            #region BayesAss3

            public class BAYESASS
            {
                public string file;
                public int ntotruns;
                public BayesAssType type;
                public int nburnin;
                public int nreps;
                public int nthinning;
                public int nruns;
                public bool nolikelihood;

                public double deltaA;
                public double deltaF;
                public double deltaM;
                public int seed;

                public IND[] inds;
                public SUBPOP[] subpops;

                public int N;
                public int P;//npops
                public int L;//nloci
                public int[] V;//ploidy, N elements
                public int[] S;//sampled pop, N elements

                public int[,] missing;//indid, locid
                public int Nmissing;
                public int Nrecord;
                public int Nburninrec;
                public int[][] alleles;//alleles at loc l

                //not write
                public ConcurrentDictionary<uint, PHENOBODY>[,] pbdict;
                public Dictionary<uint, PHENOTYPE>[,] phdict;
                public ConcurrentDictionary<uint, GENOBODY>[,] cdict;

                public double[] traceS
                {
                    get
                    {
                        double[] re = new double[traceG.Length];
                        Add(re, traceG, traceM);
                        return re; 
                    }
                }

                //Variable
                public int taskid;//1-based
                public int threadid;//0-based

                //Record
                public int iter;
                public int nr;
                public int nt;
                public double cLiG = 0, cLiM = 0, cLiS = 0;
                public double LiG = 0, Li2G = 0;
                public double LiM = 0, Li2M = 0;
                public double LiS = 0, Li2S = 0;
                public double[] traceG; //likelihood genotype
                public double[] traceM; //likelihood migration ancestry x generation

                public double[,] Rm; //P x P
                public double[,] Rm2; //P x P
                public double[] RF;  //P
                public double[] RF2;  //P
                public double[,] RMt; //N x (2P - 1)
                public Dictionary<int, double>[,] Rfreq; //P x L
                public Dictionary<int, double>[,] Rfreq2; //P x L

                //mean m, var m
                public double Avgm, Avgm2;
                public Random rnd;
                public PHENOTYPE[,] pheno;

                public int[] Mt;//migrant ancestry and generation, N elements
                public int[,] Nlqt;//count of migrant ancestry and generation, P x 2P - 1 elements
                public List<int>[] Blqt; //save existing migrant ancestry and generation for each pop, S elements
                public double[] F;//inbreeding coef, P elements
                public double[,] m;//migration rate, P x P elements
                public Dictionary<int, double>[,] freq;//allele freq at pop p and loc l
                public Dictionary<int, double>[] tfreq;//alleles at loc l

                //private int[] buf1;
                private double[] buf2;
                private string res;
                public string res_detail;
                private int nsummary = 1;

                public void Summary(BAYESASS[] pars)
                {
                    if ((nsummary = pars.Count(p => p.threadid != -1)) == 0) return;
                    threadid = 0;

                    Rm = new double[P, P];
                    Rm2 = new double[P, P];
                    RF = new double[P];
                    RF2 = new double[P];
                    RMt = new double[N, 2 * P - 1];
                    Rfreq2 = new Dictionary<int, double>[P, L];
                    Rfreq = new Dictionary<int, double>[P, L];

                    Nrecord = pars[0].Nrecord;
                    Nburninrec = pars[0].Nburninrec;
                    traceG = new double[Nrecord + Nburninrec];
                    traceM = new double[Nrecord + Nburninrec];

                    for (int i = 0; i < P; ++i)
                        for (int j = 0; j < L; ++j)
                        {
                            Rfreq[i, j] = new Dictionary<int, double>();
                            Rfreq2[i, j] = new Dictionary<int, double>();
                            foreach (int a in alleles[j])
                                Rfreq2[i, j][a] = Rfreq[i, j][a] = 0;
                        }

                    foreach (BAYESASS par in pars)
                    {
                        if (par.threadid == -1) continue;

                        Avgm += par.Avgm;
                        Avgm2 += par.Avgm2;

                        LiG += par.LiG;
                        Li2G += par.Li2G;
                        
                        LiM += par.LiM;
                        Li2M += par.Li2M;
                        
                        LiS += par.LiS;
                        Li2S += par.Li2S;

                        Add(traceG, traceG, par.traceG);
                        Add(traceM, traceM, par.traceM);

                        Add(Rm, Rm, par.Rm);
                        Add(Rm2, Rm2, par.Rm2);

                        Add(RF, RF, par.RF);
                        Add(RF2, RF2, par.RF2);

                        Add(RMt, RMt, par.RMt);

                        for (int p = 0; p < P; ++p)
                            for (int l = 0; l < L; ++l)
                            {
                                Add(Rfreq[p, l], Rfreq[p, l], par.Rfreq[p, l]);
                                AddSquare(Rfreq2[p, l], Rfreq2[p, l], par.Rfreq2[p, l]);
                            }
                    }

                    Mul(traceG, traceG, 1.0 / nsummary);
                    Mul(traceM, traceM, 1.0 / nsummary);
                    Finish(nsummary);
                }

                public static string GetBayesAssTypeString(BayesAssType type)
                {
                    string typestr = "";
                    switch (type)
                    {
                        case BayesAssType.FixedDummy:
                            typestr = "Fix Dummy";
                            break;
                        case BayesAssType.VariableDummy:
                            typestr = "Var Dummy";
                            break;
                        case BayesAssType.FixedGenotype:
                            typestr = "Fix Geno";
                            break;
                        case BayesAssType.VariableGenotype:
                            typestr = "Var Geno";
                            break;
                        case BayesAssType.Phenotype:
                            typestr = "Pheno";
                            break;
                    }
                    return typestr;
                }

                public void CreateResultFile()
                {
                    int[] fids = new DirectoryInfo(resdir).GetFiles("BayesAss_*.dat").Select(f => int.Parse(f.Name.Substring(9, f.Name.Length - 13))).ToArray();
                    file = resdir + "BayesAss_" + (fids.Length == 0 ? 1 : fids.Max(f => f) + 1).ToString() + ".dat";

                    BinaryWriter wt = new BinaryWriter(new FileStream(file, FileMode.Create, FileAccess.Write, FileShare.ReadWrite), Encoding.UTF8);
                    wt.Write(ntotruns);

                    wt.Write(new byte[ntotruns * sizeof(int)]);

                    wt.Write((int)type);
                    wt.Write(nburnin);
                    wt.Write(nreps);
                    wt.Write(nthinning);
                    wt.Write(nruns);
                    wt.Write(nolikelihood);

                    wt.Write(deltaA);
                    wt.Write(deltaF);
                    wt.Write(deltaM);
                    wt.Write(seed);

                    wt.Write(N);
                    wt.Write(P);
                    wt.Write(L);

                    wt.Write(Nrecord);
                    wt.Write(Nburninrec);
                    wt.Write(Nmissing);

                    for (int i = 0; i < N; ++i)
                        wt.Write(V[i]);

                    for (int i = 0; i < N; ++i)
                        wt.Write(S[i]);

                    for (int p = 0; p < P; ++p)
                        wt.Write(subpops[p].name);

                    for (int i = 0; i < N; ++i)
                        wt.Write(inds[i].name);

                    for (int l = 0; l < L; ++l)
                        wt.Write(subpops[0].loc[l].name);

                    for (int l = 0; l < L; ++l)
                        wt.Write(alleles[l].Length);

                    for (int l = 0; l < L; ++l)
                        foreach (int a in alleles[l])
                            wt.Write(a);
                    
                    wt.Close();
                }

                public void WriteRun()
                {
                    if (file == "" || !File.Exists(file))
                        return;

                    lock (inds)
                    {
                        BinaryWriter wt = new BinaryWriter(new FileStream(file, FileMode.Open, FileAccess.Write, FileShare.ReadWrite));
                        int offset = (int)wt.BaseStream.Length;
                        wt.BaseStream.Position = taskid * sizeof(int);
                        wt.Write(offset);
                        wt.BaseStream.Position = offset;

                        //start
                        wt.Write(taskid);
                        wt.Write(nr);

                        wt.Write(LiG);
                        wt.Write(Li2G);
                        wt.Write(LiM);
                        wt.Write(Li2M);
                        wt.Write(LiS);
                        wt.Write(Li2S);

                        for (int i = 0; i < traceG.Length; ++i)
                            wt.Write(traceG[i]);

                        for (int i = 0; i < traceM.Length; ++i)
                            wt.Write(traceM[i]);

                        for (int i = 0; i < P; ++i)
                            for (int j = 0; j < P; ++j)
                                wt.Write(Rm[i, j]);

                        for (int i = 0; i < P; ++i)
                            for (int j = 0; j < P; ++j)
                                wt.Write(Rm2[i, j]);

                        for (int i = 0; i < P; ++i)
                            wt.Write(RF[i]);

                        for (int i = 0; i < P; ++i)
                            wt.Write(RF2[i]);

                        for (int i = 0; i < N; ++i)
                            for (int j = 0; j < 2 * P - 1; ++j)
                                wt.Write(RMt[i, j]);

                        for (int i = 0; i < P; ++i)
                            for (int l = 0; l < L; ++l)
                                foreach (int a in alleles[l])
                                    wt.Write(Rfreq[i, l][a]);

                        for (int i = 0; i < P; ++i)
                            for (int l = 0; l < L; ++l)
                                foreach (int a in alleles[l])
                                    wt.Write(Rfreq2[i, l][a]);

                        wt.Flush();
                        wt.Close();
                    }
                }

                public Image Drawplot(ref byte[] VecFile, BAYESASS[] pars)
                {
                    if (threadid == -1) return null;

                    if (pars == null)
                    {
                        switch (BAYESASS_PLOTSTYLE)
                        {
                            case BayesAssPlotType.logGConvergency:
                                return DrawLineplot(Nburninrec, new double[][] { traceG }, new int[] { taskid - 1 }, ntotruns, ref VecFile);
                            case BayesAssPlotType.logMConvergency:
                                return DrawLineplot(Nburninrec, new double[][] { traceM }, new int[] { taskid - 1 }, ntotruns, ref VecFile);
                            case BayesAssPlotType.logSConvergency:
                                return DrawLineplot(Nburninrec, new double[][] { traceS }, new int[] { taskid - 1 }, ntotruns, ref VecFile);
                        }
                    }
                    else
                    {
                        List<BAYESASS> plist = pars.Where(p => p.threadid != -1).ToList();
                        plist.Add(this);

                        switch (BAYESASS_PLOTSTYLE)
                        {
                            case BayesAssPlotType.logGConvergency:
                                return DrawLineplot(Nburninrec, plist.Select(p => p.traceG).ToArray(), plist.Select(p => p.taskid - 1).ToArray(), ntotruns, ref VecFile);
                            case BayesAssPlotType.logMConvergency:
                                return DrawLineplot(Nburninrec, plist.Select(p => p.traceM).ToArray(), plist.Select(p => p.taskid - 1).ToArray(), ntotruns, ref VecFile);
                            case BayesAssPlotType.logSConvergency:
                                return DrawLineplot(Nburninrec, plist.Select(p => p.traceS).ToArray(), plist.Select(p => p.taskid - 1).ToArray(), ntotruns, ref VecFile);
                        }
                    }


                    bool group = BAYESASS_PLOTSTYLE == BayesAssPlotType.BarPlotAncestryGroupbyPop
                                      || BAYESASS_PLOTSTYLE == BayesAssPlotType.BarPlotAncestryxAgeGroupbyPop
                                      || BAYESASS_PLOTSTYLE == BayesAssPlotType.BarPlotAgeGroupbyPop;
                    float picheight = 150, groupheight = group ? 20 : 0, picwidth = 2400f / N, sepwidth = group ? picwidth : 0;
                    Bitmap bmp = new Bitmap((int)(N * picwidth + sepwidth * (P - 1) + 1), (int)(picheight + groupheight));

                    Stream ms = new MemoryStream();
                    Metafile mf = new Metafile(ms, Graphics.FromImage(bmp).GetHdc(),
                        new Rectangle(0, 0, bmp.Width, bmp.Height), MetafileFrameUnit.Pixel, EmfType.EmfPlusDual);
                    Graphics g = Graphics.FromImage(mf);
                    g.Clear(Color.White);

                    int ncat = (BAYESASS_PLOTSTYLE == BayesAssPlotType.BarPlotAncestry || BAYESASS_PLOTSTYLE == BayesAssPlotType.BarPlotAncestryGroupbyPop) ? P :
                               (BAYESASS_PLOTSTYLE == BayesAssPlotType.BarPlotAge || BAYESASS_PLOTSTYLE == BayesAssPlotType.BarPlotAgeGroupbyPop ? 3 : P * 2);
                    int ncolor = BAYESASS_PLOTSTYLE == BayesAssPlotType.BarPlotAge || BAYESASS_PLOTSTYLE == BayesAssPlotType.BarPlotAgeGroupbyPop ? 3 : P;

                    Color[] co = GetColor(ncolor, ColorMode.BarPlotWhiteBackground);
                    StringFormat stf = new StringFormat();
                    stf.Alignment = StringAlignment.Center;
                    stf.LineAlignment = StringAlignment.Near;

                    if (BAYESASS_PLOTSTYLE == BayesAssPlotType.BarPlotAncestryxAge ||
                        BAYESASS_PLOTSTYLE == BayesAssPlotType.BarPlotAncestryxAgeGroupbyPop)
                    {
                        Color[] co2 = new Color[ncolor * 2];
                        for (int i = 0; i < ncolor; ++i)
                        {
                            co2[i * 2] = co[i];
                            co2[i * 2 + 1] = GetDarkerColor(co[i]);
                        }
                        co = co2;
                    }

                    Pen[] p1 = new Pen[ncat];

                    for (int j = 0; j < ncat; ++j)
                        p1[j] = new Pen(co[j], picwidth);

                    float cx = picwidth / 2;
                    IND[] inds2 = group ?
                    (from p in subpops from ind in p.inds select ind).ToArray() : inds;

                    foreach (IND ind in inds2)
                    {
                        int id = ind.id;

                        if (group && ind == ind.subpop.inds[0])
                        {
                            if (ind != inds2[0])
                                cx += sepwidth;
                            g.DrawString(ind.subpop.name,
                                new Font("Arial", 10f / DPI_SCALE),
                                new SolidBrush(Color.Black),
                                new RectangleF(
                                    cx, picheight + 2,
                                    picwidth * ind.subpop.inds.Length, 18),
                                stf);
                        }

                        double cp = 0;
                        for (int c = 0; c < ncat; ++c)
                        {
                            double pr = 0;
                            switch (BAYESASS_PLOTSTYLE)
                            {
                                case BayesAssPlotType.BarPlotAncestry:
                                case BayesAssPlotType.BarPlotAncestryGroupbyPop:
                                    if (c == S[id])
                                        pr = RMt[id, 0];
                                    else
                                    {
                                        int Mtid = GetMtid(S[id], c, 1);
                                        pr = RMt[id, Mtid] + RMt[id, Mtid + 1];
                                    }
                                    break;
                                case BayesAssPlotType.BarPlotAge:
                                case BayesAssPlotType.BarPlotAgeGroupbyPop:
                                    if (c == 0)
                                        pr = RMt[id, 0];
                                    else for (int j = c; j < 2 * P - 1; j += 2)
                                        pr += RMt[id, j];
                                    break;
                                case BayesAssPlotType.BarPlotAncestryxAge:
                                case BayesAssPlotType.BarPlotAncestryxAgeGroupbyPop:
                                    if (c == S[id] * 2)
                                        pr = RMt[id, 0];
                                    else if (c == S[id] * 2 + 1)
                                        pr = 0;
                                    else
                                        pr = RMt[id, GetMtid(S[id], c / 2, c % 2 + 1)];
                                    break;
                            }

                            g.DrawLine(p1[c], cx, (float)(picheight * cp), cx, (float)(picheight * (cp + pr)));
                            cp += pr;
                        }
                        cx += picwidth;
                    }


                    g.Dispose();
                    ms.Seek(0, SeekOrigin.Begin);
                    VecFile = new byte[ms.Length];
                    ms.Read(VecFile, 0, (int)ms.Length);
                    ms.Seek(0, SeekOrigin.Begin);

                    g = Graphics.FromImage(bmp);
                    g.DrawImage(mf, 0, 0, bmp.Width, bmp.Height);
                    MemoryStream m = new MemoryStream();
                    bmp.Save(m, ImageFormat.Png);

                    mf.Dispose();
                    ms.Dispose();
                    g.Dispose();
                    bmp.Dispose();

                    return Image.FromStream(m);
                }

                public static Image DrawLineplot(double nburninrec, double[][] Trace, int[] colorid, int ncolor, ref byte[] VecFile)
                {
                    if (Trace.Length == 0) return null;

                    double[] trace = Trace[0];
                    int nrecord = trace.Length, interval = 1;
                    if (trace.Length > 2000)
                    {
                        interval = (int)Math.Ceiling(trace.Length / 2000.0);
                        nrecord /= interval;
                        nburninrec /= interval;
                    }

                    float picheight = 150f, picwidth = 2400f;

                    Bitmap bmp = new Bitmap((int)picwidth, (int)picheight);
                    Stream ms = new MemoryStream();
                    Metafile mf = new Metafile(ms, Graphics.FromImage(bmp).GetHdc(),
                        new Rectangle(0, 0, bmp.Width, bmp.Height), MetafileFrameUnit.Pixel, EmfType.EmfPlusDual);
                    Graphics g = Graphics.FromImage(mf);

                    g.FillRectangle(new SolidBrush(Color.Black), 0, 0, bmp.Width, bmp.Height);

                    double min = Trace.Min(t => t.Min()), max = Trace.Max(t => t.Max()) + 1e-6;
                    double xspan = 1, yspan = 0.98;
                    double xcoef = (picwidth * xspan) / nrecord, xadd = nrecord * (1 - xspan) / 2;
                    double yadd = picheight * (1 - yspan) / 2, ycoef = picheight * yspan / (max - min);

                    Color[] co = GetColor(ncolor, ColorMode.LinePlotBlackBackground);

                    for (int i = 0; i < Trace.Length; ++i)
                    {
                        double[] tr = Trace[i];
                        PointF[] points = new PointF[nrecord];

                        for (int j = 0, cp = 0; j < nrecord; ++j, cp += interval)
                            points[j] = new PointF((float)(xadd + j * xcoef), (float)(yadd + (max - tr[cp]) * ycoef));

                        g.DrawLines(colorid[i] < 0 ? new Pen(Color.Red, 2) : new Pen(co[colorid[i]], 2), points);
                    }

                    g.DrawLine(new Pen(Color.LightGreen, 4),
                        new PointF((float)(xadd + nburninrec * xcoef), 0),
                        new PointF((float)(xadd + nburninrec * xcoef), picheight));

                    g.Dispose();
                    ms.Seek(0, SeekOrigin.Begin);
                    VecFile = new byte[ms.Length];
                    ms.Read(VecFile, 0, (int)ms.Length);
                    ms.Seek(0, SeekOrigin.Begin);

                    g = Graphics.FromImage(bmp);
                    g.DrawImage(mf, 0, 0, bmp.Width, bmp.Height);
                    MemoryStream m = new MemoryStream();
                    bmp.Save(m, ImageFormat.Png);

                    mf.Dispose();
                    ms.Dispose();
                    g.Dispose();
                    bmp.Dispose();

                    return Image.FromStream(m);
                }

                public void GetParamsString(StringBuilder re)
                {
                    re.Append("Seed=" + seed);
                    re.Append(",Type=" + GetBayesAssTypeString(type));
                    re.Append(",#Inds=" + N);
                    re.Append(",#Pops=" + P);
                    re.Append(",#Loci=" + L);
                    re.Append(",#Burnin=" + nburnin);
                    re.Append(",#Reps=" + nreps);
                    re.Append(",#Thinning=" + nthinning);
                    re.Append(",#Runs=" + nruns);
                    re.Append(",NoLikelihood=" + nolikelihood);
                    re.Append(",#MissingData=" + Nmissing);
                    re.Append(",MinPloidyLevel=" + V.Min());
                    re.Append(",MaxPloidyLevel=" + V.Max());

                    re.Append(",deltaA=" + deltaA.ToString(DECIMAL));
                    re.Append(",deltaF=" + deltaF.ToString(DECIMAL));
                    re.Append(",deltaM=" + deltaM.ToString(DECIMAL));
                }

                public string GetRunString(BAYESASS[] pars)
                {
                    if (pars == null && threadid == -1)
                        res = res_detail = "Not finished.";

                    if (res != null && res != "")
                        return res;

                    StringBuilder re = new StringBuilder();
                    re.Append("Results for " + nsummary + (nsummary == 1 ? " run.\r\n" : " runs.\r\n"));
                    GetParamsString(re);

                    if (pars == null)
                        pars = new BAYESASS[] { this };

                    re.Append("\r\n\r\nSummary\r\nid\tMean m\tSD m\tMean lnL(G)\tVar lnL(G)\tMean lnP(M)\tVar lnP(M)\tMean lnL\tVar lnL\r\n");

                    foreach (BAYESASS p in pars)
                    {
                        if (p.threadid == -1)
                            re.Append(p.taskid + "\tNot finished.\r\n");
                        else
                        {
                            re.Append(p.taskid + "\t" +
                                p.Avgm.ToString(DECIMAL) + "\t" +
                                Math.Sqrt(p.Avgm2 - p.Avgm * p.Avgm).ToString(DECIMAL) + "\t" +
                                p.LiG.ToString(DECIMAL) + "\t" +
                                (p.Li2G - p.LiG * p.LiG).ToString(DECIMAL) + "\t" +
                                p.LiM.ToString(DECIMAL) + "\t" +
                                (p.Li2M - p.LiM * p.LiM).ToString(DECIMAL) + "\t" +
                                p.LiS.ToString(DECIMAL) + "\t" +
                                (p.Li2S - p.LiS * p.LiS).ToString(DECIMAL) + "\r\n");
                        }
                    }

                    if (pars.Count(p => threadid != -1) == 0)
                        return res = re.ToString();

                    re.Append("\r\nMean of 1st generation migrant proportion\t= " + Avgm.ToString(DECIMAL));
                    re.Append("\r\nStandard deviation of 1st generation migrant proportion\t= " + Math.Sqrt(Avgm2 - Avgm * Avgm).ToString(DECIMAL));
                    re.Append("\r\nMean of log genotype likelihood\t= " + LiG.ToString(DECIMAL));
                    re.Append("\r\nVariance of log genotype likelihood\t= " + (Li2G - LiG * LiG).ToString(DECIMAL));
                    re.Append("\r\nMean of log probability of migrant configuration\t= " + LiM.ToString(DECIMAL));
                    re.Append("\r\nVariance of log probability of migrant configuration\t= " + (Li2M - LiM * LiM).ToString(DECIMAL));
                    re.Append("\r\nMean of log total likelihood\t= " + LiS.ToString(DECIMAL));
                    re.Append("\r\nVariance of log total likelihood\t= " + (Li2S - LiS * LiS).ToString(DECIMAL));

                    re.Append("\r\n\r\nMigration rate");
                    re.Append("\r\nPop");
                    for (int i = 0; i < P; ++i)
                        re.Append("\t" + subpops[i].name);

                    for (int i = 0; i < P; ++i)
                    {
                        re.Append("\r\n");
                        re.Append(subpops[i].name);
                        for (int j = 0; j < P; ++j)
                            re.Append("\t" + Rm[i, j].ToString(DECIMAL));
                    }

                    res = re.ToString();

                    re.Append("\r\n\r\nStandard deviation of migration rate");
                    re.Append("\r\nPop");
                    for (int i = 0; i < P; ++i)
                        re.Append("\t" + subpops[i].name);

                    for (int i = 0; i < P; ++i)
                    {
                        re.Append("\r\n");
                        re.Append(subpops[i].name);
                        for (int j = 0; j < P; ++j)
                            re.Append("\t" + Math.Sqrt(Rm2[i, j] - Rm[i, j] * Rm[i, j]).ToString(DECIMAL));
                    }

                    re.Append("\r\n\r\nInbreeding coefficient");
                    re.Append("\r\nPop\tPloidy\tN\tAvg(F)\tSD(F)");
                    for (int i = 0; i < P; ++i)
                    {
                        re.Append("\r\n");
                        re.Append(subpops[i].name);
                        re.Append("\t" + subpops[i].ploidy);
                        re.Append("\t" + subpops[i].n);
                        re.Append("\t" + RF[i].ToString(DECIMAL));
                        re.Append("\t" + Math.Sqrt(RF2[i] - RF[i] * RF[i]).ToString(DECIMAL));
                    }

                    re.Append("\r\n\r\nIndividual migration ancestry and generation");

                    re.Append("\r\n\t\t");
                    for (int M = 0; M < P; ++M)
                        re.Append("\t" + subpops[M].name + "\t");

                    re.Append("\r\nName\tSampled\tPloidy");
                    for (int M = 0; M < P; ++M)
                        re.Append("\t1st\t2nd");

                    for (int i = 0; i < N; ++i)
                    {
                        re.Append("\r\n");
                        re.Append(inds[i].name+ "\t" + subpops[S[i]].name + "\t" + V[i]);
                        for (int M = 0; M < P; ++M)
                            for (int t = 1; t < 3; ++t)
                            {
                                int Mtid = GetMtid(S[i], M, t);
                                if (S[i] == M && t == 2)
                                    re.Append("\t-");
                                else
                                    re.Append("\t" + RMt[i, Mtid].ToString(DECIMAL));
                            }
                    }

                    int maxJ = alleles.Max(a => a.Length);
                    re.Append("\r\n\r\nAllele Frequency");
                    for (int i = 0; i < P; ++i)
                    {
                        re.Append("\r\n" + subpops[i].name);
                        re.Append("\r\n");
                        for (int l = 0; l < L; ++l)
                            re.Append(subpops[0].loc[l].name + (l < L - 1 ? "\tMean\tSD\t" : "\tMean\tSD"));

                        for (int j = 0; j < maxJ; ++j)
                        {
                            re.Append("\r\n");
                            for (int l = 0; l < L; ++l)
                            {
                                if (j >= alleles[l].Length)
                                {
                                    re.Append("\t\t\t");
                                    continue;
                                }
                                int a = alleles[l][j];
                                re.Append(a + "\t" +
                                    Rfreq[i, l][a].ToString(DECIMAL) + "\t" +
                                    Math.Sqrt(Rfreq2[i, l][a] - Rfreq[i, l][a] * Rfreq[i, l][a]).ToString(DECIMAL) + (l < L - 1 ? "\t" : ""));
                            }
                        }
                    }

                    res_detail = re.ToString();
                    return res;
                }

                public static void WritelnL(BAYESASS[] pars, string file)
                {
                    if (pars.Length == 0) return;
                    StreamWriter wt = new StreamWriter(new FileStream(file, FileMode.Create, FileAccess.Write), Encoding.UTF8);

                    wt.Write("id");
                    foreach (BAYESASS par in pars)
                        wt.Write("\t" + par.taskid + "\t\t");

                    wt.Write("\r\nIteration");
                    foreach (BAYESASS par in pars)
                        wt.Write("\tlnL(G)\tlnP(M)\tlnL");

                    int nburnin = pars[0].nburnin;
                    int nthinning = pars[0].nthinning;
                    int nreps = pars[0].nreps;
                    int cp = 0, i = 0, nburninrec = 0;
                    for (i = 0; i < nburnin; i += nthinning, cp++)
                    {
                        wt.Write("\r\n" + (i + 1));
                        foreach (BAYESASS par in pars)
                            wt.Write((par.threadid == -1 ? "\t\t\t" :
                                "\t" + par.traceG[cp].ToString(DECIMAL) +
                                "\t" + par.traceM[cp].ToString(DECIMAL) +
                                "\t" + (par.traceG[cp] + par.traceM[cp]).ToString(DECIMAL)));
                    }

                    nburninrec = i;
                    for (i = 0; i < nreps; i += nthinning, cp++)
                    {
                        wt.Write("\r\n" + (i + 1 + nburninrec));
                        foreach (BAYESASS par in pars)
                            wt.Write((par.threadid == -1 ? "\t\t\t" :
                                "\t" + par.traceG[cp].ToString(DECIMAL) +
                                "\t" + par.traceM[cp].ToString(DECIMAL) +
                                "\t" + (par.traceG[cp] + par.traceM[cp]).ToString(DECIMAL)));
                    }
                    wt.Close();
                }

                public static void ReadRuns(BayesAssResultItem res)
                {
                    if (!File.Exists(res.file)) res.items = new ListViewItem[0];
                    try
                    {
                        BAYESASS par = new BAYESASS(res.file);
                        ListViewItem[] items = new ListViewItem[par.ntotruns];
                        BAYESASS[] pars = new BAYESASS[par.ntotruns];
                        for (int i = 0; i < par.ntotruns; ++i)
                            pars[i] = new BAYESASS(res.file, i + 1, par);

                        for (int i = 0; i < par.ntotruns; ++i)
                        {
                            BAYESASS p = pars[i] = new BAYESASS(res.file, i + 1, par);
                            ListViewItem t = null;
                            if (p.threadid == -1)
                                t = new ListViewItem((i + 1).ToString());
                            else
                            {
                                t = new ListViewItem(p.taskid.ToString());
                                t.SubItems.Add(p.Avgm.ToString(DECIMAL));
                                t.SubItems.Add(p.LiS.ToString(DECIMAL));
                                t.SubItems.Add(p.Li2S.ToString(DECIMAL));
                            }
                            t.Tag = p;
                            items[i] = t;
                        }

                        par.Summary(pars);
                        res.str = par.GetRunString(pars);
                        res.items = items;
                    }
                    catch
                    {
                        res.str = "";
                        res.items = new ListViewItem[0];
                    }
                }

                public static Dictionary<string, BayesAssResultItem> resultitems = new Dictionary<string, BayesAssResultItem>();

                public static ListViewItem ReadResultFile(string file)
                {
                    FileInfo f = new FileInfo(file);
                    if (resultitems.ContainsKey(file))
                    {
                        BayesAssResultItem res = resultitems[file];
                        if (f.CreationTime == res.time)
                            return res.item;
                        else
                            resultitems.Remove(file);
                    }

                    ListViewItem re = new ListViewItem(f.Name.Substring(9, f.Name.Length - 13));
                    BinaryReader rt = new BinaryReader(new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.ReadWrite), Encoding.UTF8);
                    
                    int ntotruns = rt.ReadInt32();
                    rt.BaseStream.Position += ntotruns * sizeof(int);

                    BayesAssType type = (BayesAssType)rt.ReadInt32();
                    int nburnin = rt.ReadInt32();
                    int nreps = rt.ReadInt32();
                    int nthinning = rt.ReadInt32();
                    int nruns = rt.ReadInt32();
                    bool nolikelihood = rt.ReadBoolean();

                    double deltaA = rt.ReadDouble();
                    double deltaF = rt.ReadDouble();
                    double deltaM = rt.ReadDouble();
                    int seed = rt.ReadInt32();

                    int N = rt.ReadInt32();
                    int P = rt.ReadInt32();
                    int L = rt.ReadInt32();
                    rt.Close();

                    re.SubItems.Add(f.LastWriteTime.ToShortDateString() + " " + f.LastWriteTime.ToShortTimeString());
                    re.SubItems.Add(N + " x " + P + " x " + L);
                    re.SubItems.Add(GetBayesAssTypeString(type));
                    re.Tag = resultitems[file] = new BayesAssResultItem(file, re);
                    return re;
                }

                public BAYESASS(int _taskid, BAYESASS p)
                {
                    if (p == null) return;
                    taskid = _taskid;
                    threadid = -1;
                    rnd = new Random(SEED ^ (taskid + 0x7FC8E91B));//bug fixed on 20220324

                    file = p.file;
                    ntotruns = p.ntotruns;

                    type = p.type;
                    nburnin = p.nburnin;
                    nreps = p.nreps;
                    nthinning = p.nthinning;
                    nruns = p.nruns;
                    nolikelihood = p.nolikelihood;

                    deltaA = p.deltaA;
                    deltaF = p.deltaF;
                    deltaM = p.deltaM;

                    seed = p.seed;

                    inds = p.inds;
                    subpops = p.subpops;

                    N = p.N;
                    P = p.P;
                    L = p.L;
                    V = p.V;
                    S = p.S;

                    missing = p.missing;
                    Nmissing = p.Nmissing;
                    Nrecord = p.Nrecord;
                    Nburninrec = p.Nburninrec;
                    alleles = p.alleles;
                    pbdict = p.pbdict;
                    cdict = p.cdict;
                }

                public BAYESASS(string file, int id = -1, BAYESASS r = null) : this(id, r)
                {
                    BinaryReader rt = new BinaryReader(new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.ReadWrite), Encoding.UTF8);

                    try
                    {
                        if (r == null)
                        {
                            //read header
                            ntotruns = rt.ReadInt32();

                            rt.BaseStream.Position += ntotruns * sizeof(int);

                            type = (BayesAssType)rt.ReadInt32();
                            nburnin = rt.ReadInt32();
                            nreps = rt.ReadInt32();
                            nthinning = rt.ReadInt32();
                            nruns = rt.ReadInt32();
                            nolikelihood = rt.ReadBoolean();

                            deltaA = rt.ReadDouble();
                            deltaF = rt.ReadDouble();
                            deltaM = rt.ReadDouble();
                            seed = rt.ReadInt32();

                            N = rt.ReadInt32();
                            P = rt.ReadInt32();
                            L = rt.ReadInt32();

                            Nrecord = rt.ReadInt32();
                            Nburninrec = rt.ReadInt32();
                            Nmissing = rt.ReadInt32();

                            V = new int[N];
                            for (int i = 0; i < N; ++i)
                                V[i] = rt.ReadInt32();

                            S = new int[N];
                            for (int i = 0; i < N; ++i)
                                S[i] = rt.ReadInt32();

                            inds = new IND[N];
                            subpops = new SUBPOP[P];

                            for (int p = 0; p < P; ++p)
                                subpops[p] = new SUBPOP(p, rt.ReadString(), L);

                            for (int i = 0; i < N; ++i)
                                inds[i] = new IND(i, rt.ReadString(), V[i], subpops[S[i]]);

                            for (int p = 0; p < P; ++p)
                            {
                                subpops[p].inds = inds.Where(i => i.subpop.id == p).OrderBy(i => i.id).ToArray();
                                subpops[p].n = subpops[p].inds.Length;
                                subpops[p].ploidy = subpops[p].inds[0].ploidy;
                            }

                            subpops[0].loc = new LOC[L];
                            for (int l = 0; l < L; ++l)
                                subpops[0].loc[l] = new LOC(rt.ReadString(), l);

                            alleles = new int[L][];
                            for (int l = 0; l < L; ++l)
                                alleles[l] = new int[rt.ReadInt32()];
                            for (int l = 0; l < L; ++l)
                                for (int j = 0; j < alleles[l].Length; ++j)
                                    alleles[l][j] = rt.ReadInt32();
                        }

                        if (id == -1)
                        {
                            taskid = threadid = -1;
                            rt.Close();
                            return;
                        }

                        rt.BaseStream.Position = id * sizeof(int);//1-based
                        rt.BaseStream.Position = rt.ReadInt32();

                        if (rt.BaseStream.Position == 0)
                        {
                            taskid = id;
                            threadid = -1;
                            rt.Close();
                            return;
                        }

                        threadid = 0;
                        taskid = rt.ReadInt32();
                        nr = rt.ReadInt32();
                        LiG = rt.ReadDouble();
                        Li2G = rt.ReadDouble();
                        LiM = rt.ReadDouble();
                        Li2M = rt.ReadDouble();
                        LiS = rt.ReadDouble();
                        Li2S = rt.ReadDouble();

                        traceG = new double[Nrecord + Nburninrec];
                        for (int i = 0; i < Nrecord + Nburninrec; ++i)
                            traceG[i] = rt.ReadDouble();

                        traceM = new double[Nrecord + Nburninrec];
                        for (int i = 0; i < Nrecord + Nburninrec; ++i)
                            traceM[i] = rt.ReadDouble();

                        Rm = new double[P, P];
                        for (int i = 0; i < P; ++i)
                        {
                            for (int j = 0; j < P; ++j)
                                Rm[i, j] = rt.ReadDouble();
                            Avgm += 1 - Rm[i, i];
                            Avgm2 += (1 - Rm[i, i]) * (1 - Rm[i, i]);
                        }
                        Avgm /= P;
                        Avgm2 /= P;

                        Rm2 = new double[P, P];
                        for (int i = 0; i < P; ++i)
                            for (int j = 0; j < P; ++j)
                                Rm2[i, j] = rt.ReadDouble();

                        RF = new double[P];
                        for (int i = 0; i < P; ++i)
                            RF[i] = rt.ReadDouble();

                        RF2 = new double[P];
                        for (int i = 0; i < P; ++i)
                            RF2[i] = rt.ReadDouble();

                        RMt = new double[N, 2 * P - 1];
                        for (int i = 0; i < N; ++i)
                            for (int j = 0; j < 2 * P - 1; ++j)
                                RMt[i, j] = rt.ReadDouble();

                        Rfreq = new Dictionary<int, double>[P, L];
                        for (int i = 0; i < P; ++i)
                            for (int j = 0; j < L; ++j)
                            {
                                Rfreq[i, j] = new Dictionary<int, double>();
                                foreach (int a in alleles[j])
                                    Rfreq[i, j][a] = rt.ReadDouble();
                            }

                        Rfreq2 = new Dictionary<int, double>[P, L];
                        for (int i = 0; i < P; ++i)
                            for (int j = 0; j < L; ++j)
                            {
                                Rfreq2[i, j] = new Dictionary<int, double>();
                                foreach (int a in alleles[j])
                                    Rfreq2[i, j][a] = rt.ReadDouble();
                            }

                        rt.Close();
                    }
                    catch
                    {
                        taskid = id;
                        threadid = -1;
                        rt.Close();
                    }
                }

                public BAYESASS(IND[] _inds, SUBPOP[] _subpops)
                {
                    taskid = -1;
                    rnd = new Random(SEED ^ (taskid + 0x2FC8E91B));//bug fixed on 20220324
                    ntotruns = BAYESASS_NRUNS;

                    type = BAYESASS_TYPE;
                    nburnin = BAYESASS_NBURNIN;
                    nreps = BAYESASS_NREPS;
                    nthinning = BAYESASS_NTHINNING;
                    nruns = BAYESASS_NRUNS;
                    nolikelihood = BAYESASS_NOLIKELIHOOD;

                    deltaA = BAYESASS_DELTAA;
                    deltaF = BAYESASS_DELTAF;
                    deltaM = BAYESASS_DELTAM;
                    seed = SEED;

                    inds = _inds;
                    subpops = _subpops;

                    N = inds.Length;
                    P = subpops.Length;
                    L = subpops[0].loc.Length;

                    V = new int[N];
                    S = new int[N];

                    for (int i = 0; i < N; ++i)
                    {
                        V[i] = inds[i].ploidy;
                        S[i] = inds[i].subpop.id;
                    }

                    List<long> missing2 = new List<long>();

                    for (int i = 0; i < inds.Length; ++i)
                        for (int l = 0; l < L; ++l)
                            if (inds[i].g[l].hash == 0)
                                missing2.Add(((long)i << 32) | (long)l);

                    missing = new int[missing2.Count, 2];
                    Nmissing = missing2.Count;
                    for (int i = 0; i < Nmissing; ++i)
                    {
                        missing[i, 0] = (int)(missing2[i] >> 32);
                        missing[i, 1] = (int)(missing2[i] & 0xFFFFFFFF);
                    }

                    Nrecord = nreps / nthinning;
                    Nburninrec = nburnin / nthinning;

                    alleles = new int[L][];
                    for (int l = 0; l < L; ++l)
                        alleles[l] = subpops[0].loc[l].freq.Keys.OrderBy(a => a).ToArray();

                    pbdict = new ConcurrentDictionary<uint, PHENOBODY>[MAX_PLOIDY + 1, L];
                    cdict = new ConcurrentDictionary<uint, GENOBODY>[MAX_PLOIDY + 1, L];
                    for (int p = 1; p <= MAX_PLOIDY; ++p)
                        for (int l = 0; l < L; ++l)
                        {
                            pbdict[p, l] = new ConcurrentDictionary<uint, PHENOBODY>();
                            cdict[p, l] = new ConcurrentDictionary<uint, GENOBODY>();
                        }
                }

                public void Initialize()
                {
                    //Prepare dict
                    phdict = new Dictionary<uint, PHENOTYPE>[MAX_PLOIDY + 1, L];
                    for (int p = 1; p <= MAX_PLOIDY; ++p)
                        for (int l = 0; l < L; ++l)
                            phdict[p, l] = new Dictionary<uint, PHENOTYPE>();

                    //Resample genotype and missing genotype
                    pheno = new PHENOTYPE[N, L];
                    for (int i = 0; i < inds.Length; ++i)
                    {
                        IND ind = inds[i];
                        for (int l = 0; l < L; ++l)
                        {
                            PHENOTYPE ph = null;
                            if (ind.g[l].hash == 0)
                            {
                                int[] als = GetRandGenotypeUniform((type == BayesAssType.FixedDummy || type == BayesAssType.VariableDummy ? 2 : V[i]), l);
                                ph = new PHENOTYPE(als.Length, als, false);
                                if (type == BayesAssType.Phenotype) ph = ph.GetPhenotype();
                            }
                            else switch (type)
                            {
                                case BayesAssType.FixedDummy:
                                case BayesAssType.VariableDummy:
                                    ph = new PHENOTYPE(2, ind.g[l].GetRandomGenotype(rnd).GetDummyGenotypeTruncate(rnd).alleles2, false);
                                    break;
                                case BayesAssType.FixedGenotype:
                                case BayesAssType.VariableGenotype:
                                    ph = new PHENOTYPE(ind.ploidy, ind.g[l].GetRandomGenotype(rnd).alleles2, false);
                                    break;
                                case BayesAssType.Phenotype:
                                    ph = new PHENOTYPE(ind.g[l].body);
                                    break;
                            }

                            //process new phenotypes
                            if (phdict[V[i], l].ContainsKey(ph.hash))
                                ph = phdict[V[i], l][ph.hash];
                            else
                            {
                                //save body in a global dict
                                if (pbdict[V[i], l].ContainsKey(ph.hash))
                                    ph.body = pbdict[V[i], l][ph.hash];
                                else
                                    pbdict[V[i], l][ph.hash] = ph.body;

                                ph.GetGenotypes();
                                ph.GetSemiGenotypes(cdict[V[i], l], type != BayesAssType.Phenotype);
                                phdict[V[i], l][ph.hash] = ph;
                            }
                            pheno[i, l] = ph;
                        }
                    }

                    //all individuals are initially natives
                    Mt = new int[N];
                    Nlqt = new int[P, 2 * P - 1];
                    for (int i = 0; i < N; ++i)
                    {
                        int mtid = Mt[i] = 0;
                        Nlqt[S[i], mtid]++;
                    }

                    //there is only mtid = 0 for each pop
                    Blqt = new List<int>[P];
                    for (int p = 0; p < P; ++p)
                        Blqt[p] = new List<int>() { 0 };

                    F = new double[P];
                    m = new double[P, P];

                    SetVal(m, 1 / (3.0 * P));
                    for (int p = 0; p < P; ++p)
                        m[p, p] = 1 - (P - 1) / (3.0 * P);

                    //Initialize allele frequency
                    freq = new Dictionary<int, double>[P, L];
                    for (int p = 0; p < P; ++p)
                        for (int l = 0; l < L; ++l)
                        {
                            freq[p, l] = Clone(subpops[p].loc[l].freq);
                            Unify(freq[p, l], 1e-4);
                        }

                    tfreq = new Dictionary<int, double>[L];
                    for (int l = 0; l < L; ++l)
                        tfreq[l] = Clone(subpops[0].loc[l].freq);

                    //buf1 = new int[N];
                    buf2 = new double[P];


                    //Record
                    iter = 0;
                    nr = 0;
                    cLiG = LiG = Li2G = 0;
                    cLiM = LiM = Li2M = 0;
                    cLiS = LiS = Li2S = 0;
                    traceG = new double[Nrecord + Nburninrec];
                    traceM = new double[Nrecord + Nburninrec];
                    Rm = new double[P, P];
                    Rm2 = new double[P, P];
                    RF = new double[P];
                    RF2 = new double[P];
                    RMt = new double[N, 2 * P - 1];
                    Rfreq = new Dictionary<int, double>[P, L];
                    Rfreq2 = new Dictionary<int, double>[P, L];
                    for (int p = 0; p < P; ++p)
                        for (int l = 0; l < L; ++l)
                        {
                            Rfreq[p, l] = Clone(subpops[p].loc[l].freq);
                            Rfreq2[p, l] = Clone(subpops[p].loc[l].freq);
                        }
                    cLiG = GetGenotypeLikelihood();
                    cLiM = GetMigrantLikelihood();
                }

                public double GetGenotypeLikelihood()
                {
                    FastLog flog = FastLog.Default;
                    for (int i = 0; i < N; ++i)
                        Likelihood(ref flog, true, i);
                    return flog.Close();
                }
                
                public double GetMigrantLikelihood()
                {
                    double re = 0;
                    for (int s = 0; s < P; ++s)
                    {
                        int ntot = subpops[s].n;
                        re += GammaLn(ntot + 1);
                        for (int mtid = 0; mtid < 2 * P - 1; ++mtid)
                        {
                            int M = -1, t = -1;
                            GetMtFromIndex(mtid, s, out M, out t);
                            double n = Nlqt[s, mtid];
                            re += n * Math.Log(t == 0 ? 3 * m[s, s] - 2 : t == 1 ? m[s, M] : 2 * m[s, M]) - GammaLn(n + 1);
                        }
                    }
                    return re;
                }

                public int[] GetRandGenotypeUniform(int v, int l)
                {
                    int[] all = alleles[l], als = new int[v];
                    for (int j = 0; j < v; ++j)
                        als[j] = all[rnd.Next(all.Length)];
                    return als;
                }

                public void GetMtFromIndex(int Mtid, int s, out int M, out int t)
                {
                    if (Mtid == 0)
                    {
                        M = s;
                        t = 0;
                    }
                    else
                    {
                        if ((M = --Mtid >> 1) >= s) M++;
                        t = Mtid % 2 + 1;
                    }
                }

                public int GetMtid(int s, int M, int t)
                {
                    if (t == 0 || M == s) return 0;
                    if (M > s) M--;
                    return 1 + (M << 1) + (t - 1);
                }

                public void Likelihood(ref FastLog flog, bool ismul, int id, int M, int t, int l, 
                                       Dictionary<int, double> fs, Dictionary<int, double> fm)
                {
                    // freq
                    Likelihood(ref flog, ismul, id, M, t, l, fs, fm, F[S[id]], F[M]);
                }

                public void Likelihood(ref FastLog flog, bool ismul, int id, int M, int t)
                {
                    // Mt
                    Likelihood(ref flog, ismul, id, M, t, -1, null, null, F[S[id]], F[M]);
                }

                public void Likelihood(ref FastLog flog, bool ismul, int id, int M, int t, double Fs, double Fm)
                {
                    // inbreeding
                    Likelihood(ref flog, ismul, id, M, t, -1, null, null, Fs, Fm);
                }

                public void Likelihood(ref FastLog flog, bool ismul, int id, int loc = -1)
                {
                    // genotype
                    int M = 0, t = 0, s = S[id];
                    GetMtFromIndex(Mt[id], s, out M, out t);
                    Likelihood(ref flog, ismul, id, M, t, loc, loc == -1 ? null : freq[s, loc], loc == -1 ? null : freq[M, loc], F[s], F[M]);
                }

                public void Likelihood(ref FastLog flog, bool ismul, int id, int M, int t,
                    int loc, Dictionary<int, double> fs, Dictionary<int, double> fm,
                    double Fs, double Fm)
                {
                    int s = S[id], v = V[id];
                    double pr = 0;

                    for (int l = (loc == -1 ? 0 : loc); l < (loc == -1 ? L : loc + 1); ++l)
                    {
                        if (loc == -1)
                        {
                            fs = freq[s, l];
                            fm = freq[M, l];
                        }

                        switch (t)
                        {
                            case 0:
                                pr = pheno[id, l].PFZ(type != BayesAssType.Phenotype, fs, Fs);
                                break;
                            case 1:
                                pr = pheno[id, l].PFZ(type != BayesAssType.Phenotype, fm, Fm);
                                break;
                            case 2:
                                switch (type)
                                {
                                    case BayesAssType.FixedDummy:
                                    case BayesAssType.VariableDummy:
                                        //2nd generation hybrid, genotype AB/AABB/AAABBB/AAAABBBB/AAAAABBBBB 
                                        //the prob that sampling two alleles are both AA or BB
                                        //where A and B are domestic and foreign alleles 
                                        double pAA = (v - 2) / (double)(4 * v - 4);
                                        double pAB = v / (double)(2 * v - 2);
                                        pr = (pAA == 0 ? 0 : pAA * (pheno[id, l].PFZ(type != BayesAssType.Phenotype, fs, Fs) + 
                                                                    pheno[id, l].PFZ(type != BayesAssType.Phenotype, fm, Fm))) +
                                             (pAB == 0 ? 0 : pAB * pheno[id, l].PFZ(fs, Fs, fm, Fm));
                                        break;
                                    default:
                                        //enumerate subgenotype pairs
                                        pr = pheno[id, l].PFZ(fs, Fs, fm, Fm);
                                        break;
                                }
                                break;
                        }
                        flog.Charge(ismul ? pr : 1 / pr);
                    }
                }

                public double LnProbMtDiff(int s, int r, double[] m2)
                {
                    int Mtid = GetMtid(s, r, 1);
                    return Nlqt[s, 0] * Math.Log((3 * m2[s] - 2) / (3 * m[s, s] - 2)) +
                           (Nlqt[s, Mtid] + Nlqt[s, Mtid + 1]) * Math.Log(m2[r] / m[s, r]);

                    //m0' ^ n0 / n0!      /       m0 ^ n0 / n0!
                    //m1' ^ n1 / n1!      /       m1 ^ n1 / n1!
                    //2m1' ^ n2 / n2!     /      2m1 ^ n2 / n2!

                    //m0' ^ n0       /       m0 ^ n0 
                    //m1' ^ n1       /       m1 ^ n1 
                    //2m1' ^ n2      /       2m1 ^ n2 

                    //(m0'/m0) ^ n0
                    //(m1'/m1) ^ n1
                    //(2m1'/2m1) ^ n2

                    //(m0'/m0) ^ n0      *     (m1'/m1) ^ (n1+n2)
                }

                public double ProbMtQuotient(int s, int Mt1, int M1, int t1, int Mt2, int M2, int t2)
                {
                    return Nlqt[s, Mt1] * (t2 == 0 ? 3 * m[s, s] - 2 : t2 == 1 ? m[s, M2] : 2 * m[s, M2]) /
                           ((t1 == 0 ? 3 * m[s, s] - 2 : t1 == 1 ? m[s, M1] : 2 * m[s, M1]) * (Nlqt[s, Mt2] + 1));

                    //ps1 ^ (n1-1) / (n1-1)!     /     ps1 ^ n1 / n1!     *
                    //ps2 ^ (n2+1) / (n2+1)!     /     ps2 ^ n2 / n2!

                    //  n1     /     ps1
                    // ps2     /     (n2+1)
                }

                public void UpdateAncestryAge()
                {

                    int s = 0, Mt1 = 0, M1 = 0, t1 = 0, Mt2 = 0, M2 = 0, t2 = 0, i = 0;

                    /*
                    if (debug && Math.Abs(cLiG - GetGenotypeLikelihood()) > 0.0001)
                        cLiG = cLiG;
                    if (debug && Math.Abs(cLiM - GetMigrantLikelihood()) > 0.0001)
                        cLiM = cLiM;
                    */
                    if (false)
                    {
                        //randomly select an individual
                        i = rnd.Next(N);
                        s = S[i];
                        Mt1 = Mt[i];
                        Mt2 = NextAvoid(rnd, 2 * P - 1, Mt1);
                    }
                    else
                    {
                        //randomly select a sampled pop
                        s = rnd.Next(P);

                        //randomly select an existing migration ancestry
                        Mt1 = Blqt[s][rnd.Next(Blqt[s].Count)];

                        //randomly select an individual in s pop with Mt1 ancestry
                        int ir = rnd.Next(Nlqt[s, Mt1]);
                        
                        //pick the individual
                        foreach (IND ind in subpops[s].inds)
                        {
                            if (Mt[ind.id] == Mt1)
                            {
                                if (ir == 0)
                                {
                                    i = ind.id;
                                    break;
                                }
                                else
                                    ir--;
                            }
                        }

                        //randomly select another migration ancestry
                        Mt2 = NextAvoid(rnd, 2 * P - 1, Mt1);
                    }

                    GetMtFromIndex(Mt1, s, out M1, out t1);
                    GetMtFromIndex(Mt2, s, out M2, out t2);

                    FastLog flog = FastLog.Default;
                    Likelihood(ref flog, true, i, M2, t2);
                    Likelihood(ref flog, false, i, M1, t1);
                    double dlnLG = flog.Close();

                    double dlnLM = Math.Log(ProbMtQuotient(s, Mt1, M1, t1, Mt2, M2, t2));

                    double dlnL = nolikelihood ? dlnLM : dlnLM + dlnLG;

                    if (dlnL >= 0 || dlnL >= -36 && rnd.NextDouble() < Math.Exp(dlnL))
                    {
                        Mt[i] = Mt2;
                        Nlqt[s, Mt1]--;
                        Nlqt[s, Mt2]++;
                        if (Nlqt[s, Mt1] == 0)
                            Blqt[s].Remove(Mt1);
                        if (Nlqt[s, Mt2] == 1)
                            Blqt[s].Add(Mt2);


                        cLiG += dlnLG;
                        cLiM += dlnLM;

                        /*
                        if (debug && Math.Abs(cLiG - GetGenotypeLikelihood()) > 0.0001)
                            cLiG = cLiG;

                        if (debug && Math.Abs(cLiM - GetMigrantLikelihood()) > 0.0001)
                            cLiM = cLiM;
                        */
                    }
                }

                public void UpdateMigrationRate()
                {
                    /*
                if (debug && Math.Abs(cLiG - GetGenotypeLikelihood()) > 0.0001)
                    cLiG = cLiG;
                if (debug && Math.Abs(cLiM - GetMigrantLikelihood()) > 0.0001)
                    cLiG = cLiG;
                */

                    int s = rnd.Next(P), r = NextAvoid(rnd, P, s);
                    for (int j = 0; j < P; ++j)
                        buf2[j] = m[s, j];

                    buf2[r] += (rnd.NextDouble() - 0.5) * deltaM;
                    double ubound = m[s, s] + m[s, r] - 2.0 / 3;
                    while (buf2[r] < 0 || buf2[r] > ubound)
                    {
                        if (buf2[r] < 0) buf2[r] = -buf2[r];
                        if (buf2[r] > ubound) buf2[r] = 2 * ubound - buf2[r];
                    }
                    buf2[s] -= buf2[r] - m[s, r];

                    double dlnLM = LnProbMtDiff(s, r, buf2);

                    if (dlnLM >= 0 || dlnLM > -36 && rnd.NextDouble() < Math.Exp(dlnLM))
                    {
                        m[s, r] = buf2[r];
                        m[s, s] = buf2[s];
                        cLiM += dlnLM;

                        /*
                        if (debug && Math.Abs(cLiG - GetGenotypeLikelihood()) > 0.0001)
                            cLiG = cLiG;

                        if (debug && Math.Abs(cLiM - GetMigrantLikelihood()) > 0.0001)
                            cLiM = cLiM;
                        */
                    }
                }

                public void UpdateAlleleFreq()
                {
                    if (debug && Math.Abs(cLiG - GetGenotypeLikelihood()) > 0.0001)
                        cLiG = cLiG;
                    int l = rnd.Next(L), s = rnd.Next(P), k = rnd.Next(alleles[l].Length);
                    Dictionary<int, double> frn = tfreq[l], fro = freq[s, l];

                    int al = alleles[l][k];
                    double afold = freq[s, l][al];
                    double afnew = frn[al] = afold + (rnd.NextDouble() - 0.5) * deltaA;

                    while (afnew < 0 || afnew > 1)
                    {
                        if (afnew < 0) afnew = -afnew;
                        if (afnew > 1) afnew = afnew - 1;
                    }

                    double coef = (1.0 - afnew) / (1.0 - afold);
                    foreach (int a in alleles[l])
                        if (a != al)
                            frn[a] = fro[a] * coef;
                    frn[al] = afnew;
                    Unify(frn);
                    //Unify(frn, 1e-4);

                    FastLog flog = FastLog.Default;
                    for (int i = 0; i < N; ++i)
                    {
                        int iS = S[i], iM = 0, it = 0;
                        GetMtFromIndex(Mt[i], iS, out iM, out it);
                        if (iS == s && it != 1 || iM == s && it != 0)
                        {
                            Likelihood(ref flog, true, i, iM, it, l, iS == s ? frn : freq[iS, l], iM == s ? frn : freq[iM, l]);
                            Likelihood(ref flog, false, i, iM, it, l, iS == s ? fro : freq[iS, l], iM == s ? fro : freq[iM, l]);
                        }
                    }
                    /*
                    double[] lnLold = new double[N], lnLnew = new double[N];
                    for (int i = 0; i < N; ++i)
                    {
                        int iS = S[i], iM = 0, it = 0;
                        GetMtFromIndex(Mt[i], iS, out iM, out it);
                        flog = FastLog.Default;
                        Likelihood(ref flog, true, i, iM, it, l, iS == s ? frn : freq[iS, l], iM == s ? frn : freq[iM, l]);
                        lnLnew[i]= flog.Close();
                        flog = FastLog.Default;
                        Likelihood(ref flog, true, i, iM, it, l, iS == s ? fro : freq[iS, l], iM == s ? fro : freq[iM, l]);
                        lnLold[i] = flog.Close();
                    }

                    */
                    double dlnL = flog.Close();
                    if (nolikelihood) flog = FastLog.Default;

                    if (flog.v1 >= 0 || flog.v1 > -36 && rnd.NextDouble() < Math.Exp(flog.v1))
                    {
                        foreach (int a in alleles[l])
                            fro[a] = frn[a];
                        cLiG += dlnL;

                        //if (debug && Math.Abs(cLiG - GetGenotypeLikelihood()) > 0.0001)
                            //cLiG = cLiG;
                    }
                }

                public void UpdateInbreeding()
                {

                    //if (debug && Math.Abs(cLiG - GetGenotypeLikelihood()) > 0.0001)
                        //cLiG = cLiG;
                    int s = rnd.Next(P);
                    double fo = F[s], fn = fo + (rnd.NextDouble() - 0.5) * deltaF;

                    while (fn < 0 || fn > 1)
                    {
                        if (fn < 0) fn = -fn;
                        if (fn > 1) fn = 2 - fn;
                    }

                    FastLog flog = FastLog.Default;
                    for (int i = 0; i < N; ++i)
                    {
                        int iS = S[i], iM = 0, it = 0;
                        GetMtFromIndex(Mt[i], iS, out iM, out it);
                        if (iS == s && it != 1 || iM == s && it != 0)
                        {
                            Likelihood(ref flog, true, i, iM, it, iS == s ? fn : F[iS], iM == s ? fn : F[iM]);
                            Likelihood(ref flog, false, i, iM, it, iS == s ? fo : F[iS], iM == s ? fo : F[iM]);
                        }
                    }
                    double dlnL = flog.Close();
                    if (nolikelihood) flog = FastLog.Default;

                    if (flog.v1 >= 0 || flog.v1 > -36 && rnd.NextDouble() < Math.Exp(flog.v1))
                    {
                        cLiG += dlnL;
                        F[s] = fn;

                        //if (debug && Math.Abs(cLiG - GetGenotypeLikelihood()) > 0.0001)
                            //cLiG = cLiG;
                    }
                }

                public void UpdateGenotype()
                {
                    //if (debug && Math.Abs(cLiG - GetGenotypeLikelihood()) > 0.0001)
                        //cLiG = cLiG;

                    while (type == BayesAssType.VariableDummy || type == BayesAssType.VariableGenotype)
                    {
                        int i = rnd.Next(N), l = rnd.Next(L);
                        PHENOTYPE p = inds[i].g[l];
                        if (p.hash == 0) continue;

                        FastLog flog = FastLog.Default;
                        Likelihood(ref flog, false, i, l);
                        PHENOTYPE po = pheno[i, l];

                        PHENOTYPE pn = pheno[i, l] = type == BayesAssType.VariableDummy ?
                                   new PHENOTYPE(2, p.GetRandomGenotype(rnd).GetDummyGenotypeTruncate(rnd).alleles2, false) :
                                   new PHENOTYPE(V[i], p.GetRandomGenotype(rnd).alleles2, false);

                        //process new phenotypes
                        if (phdict[V[i], l].ContainsKey(pn.hash))
                            pn = phdict[V[i], l][pn.hash];
                        else
                        {
                            //save body in a global dict
                            if (pbdict[V[i], l].ContainsKey(pn.hash))
                                pn.body = pbdict[V[i], l][pn.hash];
                            else
                                pbdict[V[i], l][pn.hash] = pn.body;

                            pn.GetGenotypes();
                            pn.GetSemiGenotypes(cdict[V[i], l], type != BayesAssType.Phenotype);
                            phdict[V[i], l][pn.hash] = pn;
                        }
                        pheno[i, l] = pn;

                        Likelihood(ref flog, true, i, l);

                        double dlnL = flog.Close();
                        if (nolikelihood) flog = FastLog.Default;

                        if (flog.v1 >= 0 || flog.v1 > -36 && rnd.NextDouble() < Math.Exp(flog.v1))
                        {
                            cLiG += dlnL;

                            //if (debug && Math.Abs(cLiG - GetGenotypeLikelihood()) > 0.0001)
                                //cLiG = cLiG;
                        }
                        else
                            pheno[i, l] = po;
                        break;
                    }
                }

                public void UpdateMissingData()
                {
                    if (Nmissing == 0) return;
                    if (debug && Math.Abs(cLiG - GetGenotypeLikelihood()) > 0.0001)
                        cLiG = cLiG;
                    int pick = rnd.Next(Nmissing);
                    int i = missing[pick, 0], l = missing[pick, 1];

                    FastLog flog = FastLog.Default;
                    Likelihood(ref flog, false, i, l);
                    PHENOTYPE po = pheno[i, l];

                    int[] als = GetRandGenotypeUniform((type == BayesAssType.FixedDummy || type == BayesAssType.VariableDummy ? 2 : V[i]), l);
                    PHENOTYPE pn = pheno[i, l] = new PHENOTYPE(als.Length, als, false);
                    if (type == BayesAssType.Phenotype) pn = pn.GetPhenotype();

                    //process new phenotypes
                    if (phdict[V[i], l].ContainsKey(pn.hash))
                        pn = phdict[V[i], l][pn.hash];
                    else
                    {
                        //save body in a global dict
                        if (pbdict[V[i], l].ContainsKey(pn.hash))
                            pn.body = pbdict[V[i], l][pn.hash];
                        else
                            pbdict[V[i], l][pn.hash] = pn.body;

                        pn.GetGenotypes();
                        pn.GetSemiGenotypes(cdict[V[i], l], type != BayesAssType.Phenotype);
                        phdict[V[i], l][pn.hash] = pn;
                    }
                    pheno[i, l] = pn;

                    Likelihood(ref flog, true, i, l);

                    double dlnL = flog.Close();
                    if (nolikelihood) flog = FastLog.Default;

                    if (flog.v1 >= 0 || flog.v1 > -36 && rnd.NextDouble() < Math.Exp(flog.v1))
                    {
                        cLiG += dlnL;

                        //if (debug && Math.Abs(cLiG - GetGenotypeLikelihood()) > 0.0001)
                            //cLiG = cLiG;
                    }
                    else
                        pheno[i, l] = po;
                }

                public void Record()
                {
                    if (iter >= nburnin && (iter - nburnin) % nthinning == 0)
                    {
                        traceG[nt + nr] = cLiG;
                        traceM[nt + nr++] = cLiM;

                        LiG += cLiG;
                        Li2G += cLiG * cLiG;

                        LiM += cLiM;
                        Li2M += cLiM * cLiM;

                        cLiS = cLiG + cLiM;
                        LiS += cLiS;
                        Li2S += cLiS * cLiS;

                        Add(Rm, Rm, m);
                        AddSquare(Rm2, Rm, m);

                        Add(RF, RF, F);
                        AddSquare(RF2, RF2, F);

                        for (int i = 0; i < N; ++i)
                            RMt[i, Mt[i]]++;

                        for (int p = 0; p < P; ++p)
                            for (int l = 0; l < L; ++l)
                            {
                                Add(Rfreq[p, l], Rfreq[p, l], freq[p, l]);
                                AddSquare(Rfreq2[p, l], Rfreq2[p, l], freq[p, l]);
                            }
                    }
                    else if (iter < nburnin && iter % nthinning == 0)
                    {
                        traceG[nt] = cLiG;
                        traceM[nt++] = cLiM;
                    }
                }

                public void Finish(int nr)
                {
                    Avgm /= nr;
                    Avgm2 /= nr;

                    LiG /= nr;
                    Li2G /= nr;

                    LiM /= nr;
                    Li2M /= nr;

                    LiS /= nr;
                    Li2S /= nr;

                    Mul(Rm, Rm, 1.0 / nr);
                    Mul(Rm2, Rm2, 1.0 / nr);

                    Mul(RF, RF, 1.0 / nr);
                    Mul(RF2, RF2, 1.0 / nr);

                    Mul(RMt, RMt, 1.0 / nr);

                    for (int p = 0; p < P; ++p)
                        for (int l = 0; l < L; ++l)
                        {
                            Mul(Rfreq[p, l], Rfreq[p, l], 1.0 / nr);
                            Mul(Rfreq2[p, l], Rfreq2[p, l], 1.0 / nr);
                        }
                }

                public void MCMC()
                {
                    Initialize();

                    for (iter = 0; iter < nburnin + nreps; ++iter)
                    {
                        Record();
                        UpdateAncestryAge();
                        UpdateMigrationRate();
                        UpdateAlleleFreq();
                        UpdateInbreeding();
                        UpdateGenotype();
                        UpdateMissingData();
                        all.Increment();
                    }
                    Finish(nr);
                }
            }

            public void CalcBayesAss()
            {
                Progress = "Performing migration rate estimation";

                ProgressValue = 0;
                ProgressMax = BAYESASS_NRUNS * (BAYESASS_NBURNIN + BAYESASS_NREPS);
                SetProgress(ProgressValue, ProgressMax);

                BAYESASS par = new BAYESASS(inds, subpops);
                par.CreateResultFile();
                BAYESASS[] tasks = new BAYESASS[BAYESASS_NRUNS];
                for (int i = 0; i < BAYESASS_NRUNS; ++i)
                    tasks[i] = new BAYESASS(i + 1, par);

                CallThread(BayesAssThread, N_THREAD,
                           new object[] { tasks },
                           ProgressMax, ref ProgressValue);
            }

            public void BayesAssThread(object obj)
            {
                int id = (int)((object[])obj)[0];
                int nthreads = (int)((object[])obj)[1];
                BAYESASS[] tasks = (BAYESASS[])((object[])obj)[2];

                for (int i = 0; i < tasks.Length; ++i)
                {
                    if (tasks[i].threadid != -1) continue;
                    lock (tasks)
                    {
                        if (tasks[i].threadid == -1)
                            tasks[i].threadid = id;
                    }
                    if (tasks[i].threadid != id) continue;

                    tasks[i].threadid = id;
                    tasks[i].MCMC();
                    tasks[i].WriteRun();
                }
            }

            public static bool debug = false;
            #endregion
        }
        #endregion

    }
}
